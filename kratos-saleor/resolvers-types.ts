import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * The `Date` scalar type represents a Date
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  Date: any;
  /**
   * The `DateTime` scalar type represents a DateTime
   * value as specified by
   * [iso8601](https://en.wikipedia.org/wiki/ISO_8601).
   */
  DateTime: any;
  /**
   * The `GenericScalar` scalar type represents a generic
   * GraphQL scalar value that could be:
   * String, Boolean, Int, Float, List or Object.
   */
  GenericScalar: any;
  JSONString: any;
  /**
   * Metadata is a map of key-value pairs, both keys and values are `String`.
   *
   * Example:
   * ```
   * {
   *     "key1": "value1",
   *     "key2": "value2"
   * }
   * ```
   */
  Metadata: any;
  /**
   * Positive Decimal scalar implementation.
   *
   * Should be used in places where value must be positive.
   */
  PositiveDecimal: any;
  UUID: any;
  /** Variables of this type must be set to null in mutations. They will be replaced with a filename from a following multipart part containing a binary file. See: https://github.com/jaydenseric/graphql-multipart-request-spec. */
  Upload: any;
  WeightScalar: any;
  /** _Any value scalar as defined by Federation spec. */
  _Any: any;
};

/** Create a new address for the customer. Requires one of the following permissions: AUTHENTICATED_USER. */
export type AccountAddressCreate = {
  __typename?: 'AccountAddressCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address?: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was created. */
  user?: Maybe<User>;
};

/** Delete an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER. */
export type AccountAddressDelete = {
  __typename?: 'AccountAddressDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address?: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was deleted. */
  user?: Maybe<User>;
};

/** Updates an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER. */
export type AccountAddressUpdate = {
  __typename?: 'AccountAddressUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address?: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user object for which the address was edited. */
  user?: Maybe<User>;
};

/** Remove user account. Requires one of the following permissions: AUTHENTICATED_USER. */
export type AccountDelete = {
  __typename?: 'AccountDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user?: Maybe<User>;
};

export type AccountError = {
  __typename?: 'AccountError';
  /** A type of address that causes the error. */
  addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: AccountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum AccountErrorCode {
  AccountNotConfirmed = 'ACCOUNT_NOT_CONFIRMED',
  ActivateOwnAccount = 'ACTIVATE_OWN_ACCOUNT',
  ActivateSuperuserAccount = 'ACTIVATE_SUPERUSER_ACCOUNT',
  ChannelInactive = 'CHANNEL_INACTIVE',
  DeactivateOwnAccount = 'DEACTIVATE_OWN_ACCOUNT',
  DeactivateSuperuserAccount = 'DEACTIVATE_SUPERUSER_ACCOUNT',
  DeleteNonStaffUser = 'DELETE_NON_STAFF_USER',
  DeleteOwnAccount = 'DELETE_OWN_ACCOUNT',
  DeleteStaffAccount = 'DELETE_STAFF_ACCOUNT',
  DeleteSuperuserAccount = 'DELETE_SUPERUSER_ACCOUNT',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Inactive = 'INACTIVE',
  Invalid = 'INVALID',
  InvalidCredentials = 'INVALID_CREDENTIALS',
  InvalidPassword = 'INVALID_PASSWORD',
  JwtDecodeError = 'JWT_DECODE_ERROR',
  JwtInvalidCsrfToken = 'JWT_INVALID_CSRF_TOKEN',
  JwtInvalidToken = 'JWT_INVALID_TOKEN',
  JwtMissingToken = 'JWT_MISSING_TOKEN',
  JwtSignatureExpired = 'JWT_SIGNATURE_EXPIRED',
  LeftNotManageablePermission = 'LEFT_NOT_MANAGEABLE_PERMISSION',
  MissingChannelSlug = 'MISSING_CHANNEL_SLUG',
  NotFound = 'NOT_FOUND',
  OutOfScopeGroup = 'OUT_OF_SCOPE_GROUP',
  OutOfScopePermission = 'OUT_OF_SCOPE_PERMISSION',
  OutOfScopeUser = 'OUT_OF_SCOPE_USER',
  PasswordEntirelyNumeric = 'PASSWORD_ENTIRELY_NUMERIC',
  PasswordTooCommon = 'PASSWORD_TOO_COMMON',
  PasswordTooShort = 'PASSWORD_TOO_SHORT',
  PasswordTooSimilar = 'PASSWORD_TOO_SIMILAR',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type AccountInput = {
  /** Billing address of the customer. */
  defaultBillingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  defaultShippingAddress?: InputMaybe<AddressInput>;
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User language code. */
  languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
};

/** Register a new user. */
export type AccountRegister = {
  __typename?: 'AccountRegister';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** Informs whether users need to confirm their email address. */
  requiresConfirmation?: Maybe<Scalars['Boolean']>;
  user?: Maybe<User>;
};

export type AccountRegisterInput = {
  /** Slug of a channel which will be used to notify users. Optional when only one channel exists. */
  channel?: InputMaybe<Scalars['String']>;
  /** The email address of the user. */
  email: Scalars['String'];
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User language code. */
  languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** User public metadata. */
  metadata?: InputMaybe<Array<MetadataInput>>;
  /** Password. */
  password: Scalars['String'];
  /** Base of frontend URL that will be needed to create confirmation URL. */
  redirectUrl?: InputMaybe<Scalars['String']>;
};

/** Sends an email with the account removal link for the logged-in user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type AccountRequestDeletion = {
  __typename?: 'AccountRequestDeletion';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
};

/** Sets a default address for the authenticated user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type AccountSetDefaultAddress = {
  __typename?: 'AccountSetDefaultAddress';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user?: Maybe<User>;
};

/** Updates the account of the logged-in user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type AccountUpdate = {
  __typename?: 'AccountUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user?: Maybe<User>;
};

/** Represents user address data. */
export type Address = Node & {
  __typename?: 'Address';
  city: Scalars['String'];
  cityArea: Scalars['String'];
  companyName: Scalars['String'];
  /** Shop's default country. */
  country: CountryDisplay;
  countryArea: Scalars['String'];
  firstName: Scalars['String'];
  id: Scalars['ID'];
  /** Address is user's default billing address. */
  isDefaultBillingAddress?: Maybe<Scalars['Boolean']>;
  /** Address is user's default shipping address. */
  isDefaultShippingAddress?: Maybe<Scalars['Boolean']>;
  lastName: Scalars['String'];
  phone?: Maybe<Scalars['String']>;
  postalCode: Scalars['String'];
  streetAddress1: Scalars['String'];
  streetAddress2: Scalars['String'];
};

/** Creates user address. Requires one of the following permissions: MANAGE_USERS. */
export type AddressCreate = {
  __typename?: 'AddressCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address?: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was created. */
  user?: Maybe<User>;
};

/** Deletes an address. Requires one of the following permissions: MANAGE_USERS. */
export type AddressDelete = {
  __typename?: 'AddressDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address?: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user instance for which the address was deleted. */
  user?: Maybe<User>;
};

export type AddressInput = {
  /** City. */
  city?: InputMaybe<Scalars['String']>;
  /** District. */
  cityArea?: InputMaybe<Scalars['String']>;
  /** Company or organization. */
  companyName?: InputMaybe<Scalars['String']>;
  /** Country. */
  country?: InputMaybe<CountryCode>;
  /** State or province. */
  countryArea?: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Phone number. */
  phone?: InputMaybe<Scalars['String']>;
  /** Postal code. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** Address. */
  streetAddress1?: InputMaybe<Scalars['String']>;
  /** Address. */
  streetAddress2?: InputMaybe<Scalars['String']>;
};

/** Sets a default address for the given user. Requires one of the following permissions: MANAGE_USERS. */
export type AddressSetDefault = {
  __typename?: 'AddressSetDefault';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user?: Maybe<User>;
};

/** An enumeration. */
export enum AddressTypeEnum {
  Billing = 'BILLING',
  Shipping = 'SHIPPING'
}

/** Updates an address. Requires one of the following permissions: MANAGE_USERS. */
export type AddressUpdate = {
  __typename?: 'AddressUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  address?: Maybe<Address>;
  errors: Array<AccountError>;
  /** A user object for which the address was edited. */
  user?: Maybe<User>;
};

export type AddressValidationData = {
  __typename?: 'AddressValidationData';
  addressFormat: Scalars['String'];
  addressLatinFormat: Scalars['String'];
  allowedFields: Array<Scalars['String']>;
  cityAreaChoices: Array<ChoiceValue>;
  cityAreaType: Scalars['String'];
  cityChoices: Array<ChoiceValue>;
  cityType: Scalars['String'];
  countryAreaChoices: Array<ChoiceValue>;
  countryAreaType: Scalars['String'];
  countryCode: Scalars['String'];
  countryName: Scalars['String'];
  postalCodeExamples: Array<Scalars['String']>;
  postalCodeMatchers: Array<Scalars['String']>;
  postalCodePrefix: Scalars['String'];
  postalCodeType: Scalars['String'];
  requiredFields: Array<Scalars['String']>;
  upperFields: Array<Scalars['String']>;
};

/** Represents allocation. */
export type Allocation = Node & {
  __typename?: 'Allocation';
  id: Scalars['ID'];
  /** Quantity allocated for orders. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  quantity: Scalars['Int'];
  /** The warehouse were items were allocated. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  warehouse: Warehouse;
};

/** Represents app data. */
export type App = Node & ObjectWithMetadata & {
  __typename?: 'App';
  /** Description of this app. */
  aboutApp?: Maybe<Scalars['String']>;
  /** JWT token used to authenticate by thridparty app. */
  accessToken?: Maybe<Scalars['String']>;
  /** Url to iframe with the app. */
  appUrl?: Maybe<Scalars['String']>;
  /** Url to iframe with the configuration for the app. */
  configurationUrl?: Maybe<Scalars['String']>;
  /** The date and time when the app was created. */
  created?: Maybe<Scalars['DateTime']>;
  /** Description of the data privacy defined for this app. */
  dataPrivacy?: Maybe<Scalars['String']>;
  /** Url to details about the privacy policy on the app owner page. */
  dataPrivacyUrl?: Maybe<Scalars['String']>;
  /** Added in Saleor 3.1. App's dashboard extensions. Note: this feature is in a preview state and can be subject to changes at later point. */
  extensions: Array<AppExtension>;
  /** Homepage of the app. */
  homepageUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Determine if app will be set active or not. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** Name of the app. */
  name?: Maybe<Scalars['String']>;
  /** List of the app's permissions. */
  permissions?: Maybe<Array<Permission>>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Support page for the app. */
  supportUrl?: Maybe<Scalars['String']>;
  /** Last 4 characters of the tokens. */
  tokens?: Maybe<Array<AppToken>>;
  /** Type of the app. */
  type?: Maybe<AppTypeEnum>;
  /** Version number of the app. */
  version?: Maybe<Scalars['String']>;
  /** List of webhooks assigned to this app. */
  webhooks?: Maybe<Array<Webhook>>;
};


/** Represents app data. */
export type AppMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents app data. */
export type AppMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents app data. */
export type AppPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents app data. */
export type AppPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Activate the app. Requires one of the following permissions: MANAGE_APPS. */
export type AppActivate = {
  __typename?: 'AppActivate';
  app?: Maybe<App>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

export type AppCountableConnection = {
  __typename?: 'AppCountableConnection';
  edges: Array<AppCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type AppCountableEdge = {
  __typename?: 'AppCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: App;
};

/** Creates a new app. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
export type AppCreate = {
  __typename?: 'AppCreate';
  app?: Maybe<App>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  /** The newly created authentication token. */
  authToken?: Maybe<Scalars['String']>;
  errors: Array<AppError>;
};

/** Deactivate the app. Requires one of the following permissions: MANAGE_APPS. */
export type AppDeactivate = {
  __typename?: 'AppDeactivate';
  app?: Maybe<App>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/** Deletes an app. Requires one of the following permissions: MANAGE_APPS. */
export type AppDelete = {
  __typename?: 'AppDelete';
  app?: Maybe<App>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/** Delete failed installation. Requires one of the following permissions: MANAGE_APPS. */
export type AppDeleteFailedInstallation = {
  __typename?: 'AppDeleteFailedInstallation';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  appInstallation?: Maybe<AppInstallation>;
  errors: Array<AppError>;
};

export type AppError = {
  __typename?: 'AppError';
  /** The error code. */
  code: AppErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of permissions which causes the error. */
  permissions?: Maybe<Array<PermissionEnum>>;
};

/** An enumeration. */
export enum AppErrorCode {
  Forbidden = 'FORBIDDEN',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  InvalidManifestFormat = 'INVALID_MANIFEST_FORMAT',
  InvalidPermission = 'INVALID_PERMISSION',
  InvalidStatus = 'INVALID_STATUS',
  InvalidUrlFormat = 'INVALID_URL_FORMAT',
  ManifestUrlCantConnect = 'MANIFEST_URL_CANT_CONNECT',
  NotFound = 'NOT_FOUND',
  OutOfScopeApp = 'OUT_OF_SCOPE_APP',
  OutOfScopePermission = 'OUT_OF_SCOPE_PERMISSION',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

/** Represents app data. */
export type AppExtension = Node & {
  __typename?: 'AppExtension';
  /** JWT token used to authenticate by thridparty app extension. */
  accessToken?: Maybe<Scalars['String']>;
  app: App;
  id: Scalars['ID'];
  /** Label of the extension to show in the dashboard. */
  label: Scalars['String'];
  /** Place where given extension will be mounted. */
  mount: AppExtensionMountEnum;
  /** List of the app extension's permissions. */
  permissions: Array<Permission>;
  /** Type of way how app extension will be opened. */
  target: AppExtensionTargetEnum;
  /** URL of a view where extension's iframe is placed. */
  url: Scalars['String'];
};

export type AppExtensionCountableConnection = {
  __typename?: 'AppExtensionCountableConnection';
  edges: Array<AppExtensionCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type AppExtensionCountableEdge = {
  __typename?: 'AppExtensionCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AppExtension;
};

export type AppExtensionFilterInput = {
  mount?: InputMaybe<Array<AppExtensionMountEnum>>;
  target?: InputMaybe<AppExtensionTargetEnum>;
};

/** All places where app extension can be mounted. */
export enum AppExtensionMountEnum {
  NavigationCatalog = 'NAVIGATION_CATALOG',
  NavigationCustomers = 'NAVIGATION_CUSTOMERS',
  NavigationDiscounts = 'NAVIGATION_DISCOUNTS',
  NavigationOrders = 'NAVIGATION_ORDERS',
  NavigationPages = 'NAVIGATION_PAGES',
  NavigationTranslations = 'NAVIGATION_TRANSLATIONS',
  ProductDetailsMoreActions = 'PRODUCT_DETAILS_MORE_ACTIONS',
  ProductOverviewCreate = 'PRODUCT_OVERVIEW_CREATE',
  ProductOverviewMoreActions = 'PRODUCT_OVERVIEW_MORE_ACTIONS'
}

/**
 * All available ways of opening an app extension.
 *
 *     POPUP - app's extension will be mounted as a popup window
 *     APP_PAGE - redirect to app's page
 */
export enum AppExtensionTargetEnum {
  AppPage = 'APP_PAGE',
  Popup = 'POPUP'
}

/** Fetch and validate manifest. Requires one of the following permissions: MANAGE_APPS. */
export type AppFetchManifest = {
  __typename?: 'AppFetchManifest';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
  manifest?: Maybe<Manifest>;
};

export type AppFilterInput = {
  isActive?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<AppTypeEnum>;
};

export type AppInput = {
  /** Name of the app. */
  name?: InputMaybe<Scalars['String']>;
  /** List of permission code names to assign to this app. */
  permissions?: InputMaybe<Array<PermissionEnum>>;
};

/** Install new app by using app manifest. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
export type AppInstall = {
  __typename?: 'AppInstall';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  appInstallation?: Maybe<AppInstallation>;
  errors: Array<AppError>;
};

export type AppInstallInput = {
  /** Determine if app will be set active or not. */
  activateAfterInstallation?: InputMaybe<Scalars['Boolean']>;
  /** Name of the app to install. */
  appName?: InputMaybe<Scalars['String']>;
  /** Url to app's manifest in JSON format. */
  manifestUrl?: InputMaybe<Scalars['String']>;
  /** List of permission code names to assign to this app. */
  permissions?: InputMaybe<Array<PermissionEnum>>;
};

/** Represents ongoing installation of app. */
export type AppInstallation = Job & Node & {
  __typename?: 'AppInstallation';
  appName: Scalars['String'];
  /** Created date time of job in ISO 8601 format. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  manifestUrl: Scalars['String'];
  /** Job message. */
  message?: Maybe<Scalars['String']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  updatedAt: Scalars['DateTime'];
};

export type AppManifestExtension = {
  __typename?: 'AppManifestExtension';
  /** Label of the extension to show in the dashboard. */
  label: Scalars['String'];
  /** Place where given extension will be mounted. */
  mount: AppExtensionMountEnum;
  /** List of the app extension's permissions. */
  permissions: Array<Permission>;
  /** Type of way how app extension will be opened. */
  target: AppExtensionTargetEnum;
  /** URL of a view where extension's iframe is placed. */
  url: Scalars['String'];
};

/** Retry failed installation of new app. Requires one of the following permissions: MANAGE_APPS. */
export type AppRetryInstall = {
  __typename?: 'AppRetryInstall';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  appInstallation?: Maybe<AppInstallation>;
  errors: Array<AppError>;
};

export enum AppSortField {
  /** Sort apps by creation date. */
  CreationDate = 'CREATION_DATE',
  /** Sort apps by name. */
  Name = 'NAME'
}

export type AppSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort apps by the selected field. */
  field: AppSortField;
};

/** Represents token data. */
export type AppToken = Node & {
  __typename?: 'AppToken';
  /** Last 4 characters of the token. */
  authToken?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Name of the authenticated token. */
  name?: Maybe<Scalars['String']>;
};

/** Creates a new token. Requires one of the following permissions: MANAGE_APPS. */
export type AppTokenCreate = {
  __typename?: 'AppTokenCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  appToken?: Maybe<AppToken>;
  /** The newly created authentication token. */
  authToken?: Maybe<Scalars['String']>;
  errors: Array<AppError>;
};

/** Deletes an authentication token assigned to app. Requires one of the following permissions: MANAGE_APPS. */
export type AppTokenDelete = {
  __typename?: 'AppTokenDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  appToken?: Maybe<AppToken>;
  errors: Array<AppError>;
};

export type AppTokenInput = {
  /** ID of app. */
  app: Scalars['ID'];
  /** Name of the token. */
  name?: InputMaybe<Scalars['String']>;
};

/** Verify provided app token. */
export type AppTokenVerify = {
  __typename?: 'AppTokenVerify';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
  /** Determine if token is valid or not. */
  valid: Scalars['Boolean'];
};

/** Enum determining type of your App. */
export enum AppTypeEnum {
  /** Local Saleor App. The app is fully manageable from dashboard. You can change assigned permissions, add webhooks, or authentication token */
  Local = 'LOCAL',
  /** Third party external App. Installation is fully automated. Saleor uses a defined App manifest to gather all required information. */
  Thirdparty = 'THIRDPARTY'
}

/** Updates an existing app. Requires one of the following permissions: MANAGE_APPS. */
export type AppUpdate = {
  __typename?: 'AppUpdate';
  app?: Maybe<App>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  appErrors: Array<AppError>;
  errors: Array<AppError>;
};

/** An enumeration. */
export enum AreaUnitsEnum {
  SqCm = 'SQ_CM',
  SqFt = 'SQ_FT',
  SqInch = 'SQ_INCH',
  SqKm = 'SQ_KM',
  SqM = 'SQ_M',
  SqYd = 'SQ_YD'
}

/** Assigns storefront's navigation menus. Requires one of the following permissions: MANAGE_MENUS, MANAGE_SETTINGS. */
export type AssignNavigation = {
  __typename?: 'AssignNavigation';
  errors: Array<MenuError>;
  /** Assigned navigation menu. */
  menu?: Maybe<Menu>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

/** Added in Saleor 3.1. Represents assigned attribute to variant with variant selection attached. */
export type AssignedVariantAttribute = {
  __typename?: 'AssignedVariantAttribute';
  /** Attribute assigned to variant. */
  attribute: Attribute;
  /** Determines, whether assigned attribute is allowed for variant selection. Supported variant types for variant selection are: ['dropdown', 'boolean', 'swatch', 'numeric'] */
  variantSelection: Scalars['Boolean'];
};

/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type Attribute = Node & ObjectWithMetadata & {
  __typename?: 'Attribute';
  /** Whether the attribute can be displayed in the admin product list. Requires one of the following permissions: PagePermissions.MANAGE_PAGES, PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES, ProductPermissions.MANAGE_PRODUCTS, ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  availableInGrid: Scalars['Boolean'];
  /** List of attribute's values. */
  choices?: Maybe<AttributeValueCountableConnection>;
  /** The entity type which can be used as a reference. */
  entityType?: Maybe<AttributeEntityTypeEnum>;
  /** Whether the attribute can be filtered in dashboard. Requires one of the following permissions: PagePermissions.MANAGE_PAGES, PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES, ProductPermissions.MANAGE_PRODUCTS, ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  filterableInDashboard: Scalars['Boolean'];
  /** Whether the attribute can be filtered in storefront. Requires one of the following permissions: PagePermissions.MANAGE_PAGES, PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES, ProductPermissions.MANAGE_PRODUCTS, ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  filterableInStorefront: Scalars['Boolean'];
  id: Scalars['ID'];
  /** The input type to use for entering attribute values in the dashboard. */
  inputType?: Maybe<AttributeInputTypeEnum>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** Name of an attribute displayed in the interface. */
  name?: Maybe<Scalars['String']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  productTypes: ProductTypeCountableConnection;
  productVariantTypes: ProductTypeCountableConnection;
  /** Internal representation of an attribute name. */
  slug?: Maybe<Scalars['String']>;
  /** The position of the attribute in the storefront navigation (0 by default). Requires one of the following permissions: PagePermissions.MANAGE_PAGES, PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES, ProductPermissions.MANAGE_PRODUCTS, ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  storefrontSearchPosition: Scalars['Int'];
  /** Returns translated attribute fields for the given language code. */
  translation?: Maybe<AttributeTranslation>;
  /** The attribute type. */
  type?: Maybe<AttributeTypeEnum>;
  /** The unit of attribute values. */
  unit?: Maybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. Requires one of the following permissions: PagePermissions.MANAGE_PAGES, PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES, ProductPermissions.MANAGE_PRODUCTS, ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  valueRequired: Scalars['Boolean'];
  /** Whether the attribute should be visible or not in storefront. Requires one of the following permissions: PagePermissions.MANAGE_PAGES, PageTypePermissions.MANAGE_PAGE_TYPES_AND_ATTRIBUTES, ProductPermissions.MANAGE_PRODUCTS, ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  visibleInStorefront: Scalars['Boolean'];
  /** Flag indicating that attribute has predefined choices. */
  withChoices: Scalars['Boolean'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeChoicesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AttributeValueFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<AttributeChoicesSortingInput>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeMetafieldArgs = {
  key: Scalars['String'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeProductTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeProductVariantTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Custom attribute of a product. Attributes can be assigned to products and variants at the product type level. */
export type AttributeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Deletes attributes. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type AttributeBulkDelete = {
  __typename?: 'AttributeBulkDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AttributeError>;
};

export enum AttributeChoicesSortField {
  /** Sort attribute choice by name. */
  Name = 'NAME',
  /** Sort attribute choice by slug. */
  Slug = 'SLUG'
}

export type AttributeChoicesSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort attribute choices by the selected field. */
  field: AttributeChoicesSortField;
};

export type AttributeCountableConnection = {
  __typename?: 'AttributeCountableConnection';
  edges: Array<AttributeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type AttributeCountableEdge = {
  __typename?: 'AttributeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Attribute;
};

/** Creates an attribute. */
export type AttributeCreate = {
  __typename?: 'AttributeCreate';
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

export type AttributeCreateInput = {
  /** Whether the attribute can be displayed in the admin product list. */
  availableInGrid?: InputMaybe<Scalars['Boolean']>;
  /** The entity type which can be used as a reference. */
  entityType?: InputMaybe<AttributeEntityTypeEnum>;
  /** Whether the attribute can be filtered in dashboard. */
  filterableInDashboard?: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute can be filtered in storefront. */
  filterableInStorefront?: InputMaybe<Scalars['Boolean']>;
  /** The input type to use for entering attribute values in the dashboard. */
  inputType?: InputMaybe<AttributeInputTypeEnum>;
  /** Whether the attribute is for variants only. */
  isVariantOnly?: InputMaybe<Scalars['Boolean']>;
  /** Name of an attribute displayed in the interface. */
  name: Scalars['String'];
  /** Internal representation of an attribute name. */
  slug?: InputMaybe<Scalars['String']>;
  /** The position of the attribute in the storefront navigation (0 by default). */
  storefrontSearchPosition?: InputMaybe<Scalars['Int']>;
  /** The attribute type. */
  type: AttributeTypeEnum;
  /** The unit of attribute values. */
  unit?: InputMaybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. */
  valueRequired?: InputMaybe<Scalars['Boolean']>;
  /** List of attribute's values. */
  values?: InputMaybe<Array<AttributeValueCreateInput>>;
  /** Whether the attribute should be visible or not in storefront. */
  visibleInStorefront?: InputMaybe<Scalars['Boolean']>;
};

/** Deletes an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type AttributeDelete = {
  __typename?: 'AttributeDelete';
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

/** An enumeration. */
export enum AttributeEntityTypeEnum {
  Page = 'PAGE',
  Product = 'PRODUCT'
}

export type AttributeError = {
  __typename?: 'AttributeError';
  /** The error code. */
  code: AttributeErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum AttributeErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type AttributeFilterInput = {
  availableInGrid?: InputMaybe<Scalars['Boolean']>;
  /**
   * Specifies the channel by which the data should be filtered.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  filterableInDashboard?: InputMaybe<Scalars['Boolean']>;
  filterableInStorefront?: InputMaybe<Scalars['Boolean']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  inCategory?: InputMaybe<Scalars['ID']>;
  inCollection?: InputMaybe<Scalars['ID']>;
  isVariantOnly?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<AttributeTypeEnum>;
  valueRequired?: InputMaybe<Scalars['Boolean']>;
  visibleInStorefront?: InputMaybe<Scalars['Boolean']>;
};

export type AttributeInput = {
  /** The boolean value of the attribute. */
  boolean?: InputMaybe<Scalars['Boolean']>;
  /** The date range that the returned values should be in. In case of date/time attributes, the UTC midnight of the given date is used. */
  date?: InputMaybe<DateRangeInput>;
  /** The date/time range that the returned values should be in. */
  dateTime?: InputMaybe<DateTimeRangeInput>;
  /** Internal representation of an attribute name. */
  slug: Scalars['String'];
  /** Internal representation of a value (unique per attribute). */
  values?: InputMaybe<Array<Scalars['String']>>;
  /** The range that the returned values should be in. */
  valuesRange?: InputMaybe<IntRangeInput>;
};

/** An enumeration. */
export enum AttributeInputTypeEnum {
  Boolean = 'BOOLEAN',
  Date = 'DATE',
  DateTime = 'DATE_TIME',
  Dropdown = 'DROPDOWN',
  File = 'FILE',
  Multiselect = 'MULTISELECT',
  Numeric = 'NUMERIC',
  Reference = 'REFERENCE',
  RichText = 'RICH_TEXT',
  Swatch = 'SWATCH'
}

/** Reorder the values of an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type AttributeReorderValues = {
  __typename?: 'AttributeReorderValues';
  /** Attribute from which values are reordered. */
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

export enum AttributeSortField {
  /** Sort attributes based on whether they can be displayed or not in a product grid. */
  AvailableInGrid = 'AVAILABLE_IN_GRID',
  /** Sort attributes by the filterable in dashboard flag */
  FilterableInDashboard = 'FILTERABLE_IN_DASHBOARD',
  /** Sort attributes by the filterable in storefront flag */
  FilterableInStorefront = 'FILTERABLE_IN_STOREFRONT',
  /** Sort attributes by the variant only flag */
  IsVariantOnly = 'IS_VARIANT_ONLY',
  /** Sort attributes by name */
  Name = 'NAME',
  /** Sort attributes by slug */
  Slug = 'SLUG',
  /** Sort attributes by their position in storefront */
  StorefrontSearchPosition = 'STOREFRONT_SEARCH_POSITION',
  /** Sort attributes by the value required flag */
  ValueRequired = 'VALUE_REQUIRED',
  /** Sort attributes by visibility in the storefront */
  VisibleInStorefront = 'VISIBLE_IN_STOREFRONT'
}

export type AttributeSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort attributes by the selected field. */
  field: AttributeSortField;
};

export type AttributeTranslatableContent = Node & {
  __typename?: 'AttributeTranslatableContent';
  /**
   * Custom attribute of a product.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  attribute?: Maybe<Attribute>;
  id: Scalars['ID'];
  name: Scalars['String'];
  /** Returns translated attribute fields for the given language code. */
  translation?: Maybe<AttributeTranslation>;
};


export type AttributeTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for an attribute. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type AttributeTranslate = {
  __typename?: 'AttributeTranslate';
  attribute?: Maybe<Attribute>;
  errors: Array<TranslationError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type AttributeTranslation = Node & {
  __typename?: 'AttributeTranslation';
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name: Scalars['String'];
};

/** An enumeration. */
export enum AttributeTypeEnum {
  PageType = 'PAGE_TYPE',
  ProductType = 'PRODUCT_TYPE'
}

/** Updates attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type AttributeUpdate = {
  __typename?: 'AttributeUpdate';
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  errors: Array<AttributeError>;
};

export type AttributeUpdateInput = {
  /** New values to be created for this attribute. */
  addValues?: InputMaybe<Array<AttributeValueUpdateInput>>;
  /** Whether the attribute can be displayed in the admin product list. */
  availableInGrid?: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute can be filtered in dashboard. */
  filterableInDashboard?: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute can be filtered in storefront. */
  filterableInStorefront?: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute is for variants only. */
  isVariantOnly?: InputMaybe<Scalars['Boolean']>;
  /** Name of an attribute displayed in the interface. */
  name?: InputMaybe<Scalars['String']>;
  /** IDs of values to be removed from this attribute. */
  removeValues?: InputMaybe<Array<Scalars['ID']>>;
  /** Internal representation of an attribute name. */
  slug?: InputMaybe<Scalars['String']>;
  /** The position of the attribute in the storefront navigation (0 by default). */
  storefrontSearchPosition?: InputMaybe<Scalars['Int']>;
  /** The unit of attribute values. */
  unit?: InputMaybe<MeasurementUnitsEnum>;
  /** Whether the attribute requires values to be passed or not. */
  valueRequired?: InputMaybe<Scalars['Boolean']>;
  /** Whether the attribute should be visible or not in storefront. */
  visibleInStorefront?: InputMaybe<Scalars['Boolean']>;
};

/** Represents a value of an attribute. */
export type AttributeValue = Node & {
  __typename?: 'AttributeValue';
  /** Represents the boolean value of the attribute value. */
  boolean?: Maybe<Scalars['Boolean']>;
  /** Represents the date value of the attribute value. */
  date?: Maybe<Scalars['Date']>;
  /** Represents the date/time value of the attribute value. */
  dateTime?: Maybe<Scalars['DateTime']>;
  /** Represents file URL and content type (if attribute value is a file). */
  file?: Maybe<File>;
  id: Scalars['ID'];
  /** The input type to use for entering attribute values in the dashboard. */
  inputType?: Maybe<AttributeInputTypeEnum>;
  /** Name of a value displayed in the interface. */
  name?: Maybe<Scalars['String']>;
  /** The ID of the attribute reference. */
  reference?: Maybe<Scalars['ID']>;
  /** Represents the text (JSON) of the attribute value. */
  richText?: Maybe<Scalars['JSONString']>;
  /** Internal representation of a value (unique per attribute). */
  slug?: Maybe<Scalars['String']>;
  /** Returns translated attribute value fields for the given language code. */
  translation?: Maybe<AttributeValueTranslation>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  value?: Maybe<Scalars['String']>;
};


/** Represents a value of an attribute. */
export type AttributeValueTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Deletes values of attributes. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type AttributeValueBulkDelete = {
  __typename?: 'AttributeValueBulkDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AttributeError>;
};

export type AttributeValueCountableConnection = {
  __typename?: 'AttributeValueCountableConnection';
  edges: Array<AttributeValueCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type AttributeValueCountableEdge = {
  __typename?: 'AttributeValueCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: AttributeValue;
};

/** Creates a value for an attribute. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type AttributeValueCreate = {
  __typename?: 'AttributeValueCreate';
  /** The updated attribute. */
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  attributeValue?: Maybe<AttributeValue>;
  errors: Array<AttributeError>;
};

export type AttributeValueCreateInput = {
  /** File content type. */
  contentType?: InputMaybe<Scalars['String']>;
  /** URL of the file attribute. Every time, a new value is created. */
  fileUrl?: InputMaybe<Scalars['String']>;
  /** Name of a value displayed in the interface. */
  name: Scalars['String'];
  /** Represents the text (JSON) of the attribute value. */
  richText?: InputMaybe<Scalars['JSONString']>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  value?: InputMaybe<Scalars['String']>;
};

/** Deletes a value of an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type AttributeValueDelete = {
  __typename?: 'AttributeValueDelete';
  /** The updated attribute. */
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  attributeValue?: Maybe<AttributeValue>;
  errors: Array<AttributeError>;
};

export type AttributeValueFilterInput = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  search?: InputMaybe<Scalars['String']>;
};

export type AttributeValueInput = {
  /** Represents the boolean value of the attribute value. */
  boolean?: InputMaybe<Scalars['Boolean']>;
  /** File content type. */
  contentType?: InputMaybe<Scalars['String']>;
  /** Represents the date value of the attribute value. */
  date?: InputMaybe<Scalars['Date']>;
  /** Represents the date/time value of the attribute value. */
  dateTime?: InputMaybe<Scalars['DateTime']>;
  /** URL of the file attribute. Every time, a new value is created. */
  file?: InputMaybe<Scalars['String']>;
  /** ID of the selected attribute. */
  id?: InputMaybe<Scalars['ID']>;
  /** List of entity IDs that will be used as references. */
  references?: InputMaybe<Array<Scalars['ID']>>;
  /** Text content in JSON format. */
  richText?: InputMaybe<Scalars['JSONString']>;
  /** The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created. */
  values?: InputMaybe<Array<Scalars['String']>>;
};

export type AttributeValueTranslatableContent = Node & {
  __typename?: 'AttributeValueTranslatableContent';
  /**
   * Represents a value of an attribute.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  attributeValue?: Maybe<AttributeValue>;
  id: Scalars['ID'];
  name: Scalars['String'];
  richText?: Maybe<Scalars['JSONString']>;
  /** Returns translated attribute value fields for the given language code. */
  translation?: Maybe<AttributeValueTranslation>;
};


export type AttributeValueTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for an attribute value. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type AttributeValueTranslate = {
  __typename?: 'AttributeValueTranslate';
  attributeValue?: Maybe<AttributeValue>;
  errors: Array<TranslationError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type AttributeValueTranslation = Node & {
  __typename?: 'AttributeValueTranslation';
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name: Scalars['String'];
  richText?: Maybe<Scalars['JSONString']>;
};

export type AttributeValueTranslationInput = {
  name?: InputMaybe<Scalars['String']>;
  richText?: InputMaybe<Scalars['JSONString']>;
};

/** Updates value of an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type AttributeValueUpdate = {
  __typename?: 'AttributeValueUpdate';
  /** The updated attribute. */
  attribute?: Maybe<Attribute>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  attributeErrors: Array<AttributeError>;
  attributeValue?: Maybe<AttributeValue>;
  errors: Array<AttributeError>;
};

export type AttributeValueUpdateInput = {
  /** File content type. */
  contentType?: InputMaybe<Scalars['String']>;
  /** URL of the file attribute. Every time, a new value is created. */
  fileUrl?: InputMaybe<Scalars['String']>;
  /** Name of a value displayed in the interface. */
  name?: InputMaybe<Scalars['String']>;
  /** Represents the text (JSON) of the attribute value. */
  richText?: InputMaybe<Scalars['JSONString']>;
  /** Represent value of the attribute value (e.g. color values for swatch attributes). */
  value?: InputMaybe<Scalars['String']>;
};

export type BulkAttributeValueInput = {
  /** The boolean value of an attribute to resolve. If the passed value is non-existent, it will be created. */
  boolean?: InputMaybe<Scalars['Boolean']>;
  /** ID of the selected attribute. */
  id?: InputMaybe<Scalars['ID']>;
  /** The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created. */
  values?: InputMaybe<Array<Scalars['String']>>;
};

export type BulkProductError = {
  __typename?: 'BulkProductError';
  /** List of attributes IDs which causes the error. */
  attributes?: Maybe<Array<Scalars['ID']>>;
  /** List of channel IDs which causes the error. */
  channels?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** Index of an input list item that caused the error. */
  index?: Maybe<Scalars['Int']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values?: Maybe<Array<Scalars['ID']>>;
  /** List of warehouse IDs which causes the error. */
  warehouses?: Maybe<Array<Scalars['ID']>>;
};

export type BulkStockError = {
  __typename?: 'BulkStockError';
  /** List of attributes IDs which causes the error. */
  attributes?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** Index of an input list item that caused the error. */
  index?: Maybe<Scalars['Int']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values?: Maybe<Array<Scalars['ID']>>;
};

export type CardInput = {
  /** Payment method nonce, a token returned by the appropriate provider's SDK. */
  code: Scalars['String'];
  /** Card security code. */
  cvc?: InputMaybe<Scalars['String']>;
  /** Information about currency and amount. */
  money: MoneyInput;
};

export type CatalogueInput = {
  /** Categories related to the discount. */
  categories?: InputMaybe<Array<Scalars['ID']>>;
  /** Collections related to the discount. */
  collections?: InputMaybe<Array<Scalars['ID']>>;
  /** Products related to the discount. */
  products?: InputMaybe<Array<Scalars['ID']>>;
  /** Added in Saleor 3.1. Product variant related to the discount. */
  variants?: InputMaybe<Array<Scalars['ID']>>;
};

/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type Category = Node & ObjectWithMetadata & {
  __typename?: 'Category';
  /** List of ancestors of the category. */
  ancestors?: Maybe<CategoryCountableConnection>;
  backgroundImage?: Maybe<Image>;
  /** List of children of the category. */
  children?: Maybe<CategoryCountableConnection>;
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Description of the category (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  level: Scalars['Int'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  parent?: Maybe<Category>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** List of products in the category. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  products?: Maybe<ProductCountableConnection>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  slug: Scalars['String'];
  /** Returns translated category fields for the given language code. */
  translation?: Maybe<CategoryTranslation>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryBackgroundImageArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront. */
export type CategoryTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Deletes categories. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CategoryBulkDelete = {
  __typename?: 'CategoryBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type CategoryCountableConnection = {
  __typename?: 'CategoryCountableConnection';
  edges: Array<CategoryCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type CategoryCountableEdge = {
  __typename?: 'CategoryCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Category;
};

/** Creates a new category. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CategoryCreate = {
  __typename?: 'CategoryCreate';
  category?: Maybe<Category>;
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type CategoryCreated = {
  __typename?: 'CategoryCreated';
  /** Added in Saleor 3.2. Look up a category. Note: this feature is in a preview state and can be subject to changes at later point. */
  category?: Maybe<Category>;
};

/** Deletes a category. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CategoryDelete = {
  __typename?: 'CategoryDelete';
  category?: Maybe<Category>;
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type CategoryDeleted = {
  __typename?: 'CategoryDeleted';
  /** Added in Saleor 3.2. Look up a category. Note: this feature is in a preview state and can be subject to changes at later point. */
  category?: Maybe<Category>;
};

export type CategoryFilterInput = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
};

export type CategoryInput = {
  /** Background image file. */
  backgroundImage?: InputMaybe<Scalars['Upload']>;
  /** Alt text for a product media. */
  backgroundImageAlt?: InputMaybe<Scalars['String']>;
  /** Category description (JSON). */
  description?: InputMaybe<Scalars['JSONString']>;
  /** Category name. */
  name?: InputMaybe<Scalars['String']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Category slug. */
  slug?: InputMaybe<Scalars['String']>;
};

export enum CategorySortField {
  /** Sort categories by name. */
  Name = 'NAME',
  /** Sort categories by product count. */
  ProductCount = 'PRODUCT_COUNT',
  /** Sort categories by subcategory count. */
  SubcategoryCount = 'SUBCATEGORY_COUNT'
}

export type CategorySortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort categories by the selected field. */
  field: CategorySortField;
};

export type CategoryTranslatableContent = Node & {
  __typename?: 'CategoryTranslatableContent';
  /**
   * Represents a single category of products.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  category?: Maybe<Category>;
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Description of the category (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  /** Returns translated category fields for the given language code. */
  translation?: Maybe<CategoryTranslation>;
};


export type CategoryTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a category. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type CategoryTranslate = {
  __typename?: 'CategoryTranslate';
  category?: Maybe<Category>;
  errors: Array<TranslationError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type CategoryTranslation = Node & {
  __typename?: 'CategoryTranslation';
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the product (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name?: Maybe<Scalars['String']>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
};

/** Updates a category. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CategoryUpdate = {
  __typename?: 'CategoryUpdate';
  category?: Maybe<Category>;
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type CategoryUpdated = {
  __typename?: 'CategoryUpdated';
  /** Added in Saleor 3.2. Look up a category. Note: this feature is in a preview state and can be subject to changes at later point. */
  category?: Maybe<Category>;
};

/** Represents channel. */
export type Channel = Node & {
  __typename?: 'Channel';
  currencyCode: Scalars['String'];
  /** Added in Saleor 3.1. Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  defaultCountry: CountryDisplay;
  /** Whether a channel has associated orders. Requires one of the following permissions: MANAGE_CHANNELS. */
  hasOrders: Scalars['Boolean'];
  id: Scalars['ID'];
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  slug: Scalars['String'];
};

/** Activate a channel. Requires one of the following permissions: MANAGE_CHANNELS. */
export type ChannelActivate = {
  __typename?: 'ChannelActivate';
  /** Activated channel. */
  channel?: Maybe<Channel>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

/** Creates new channel. Requires one of the following permissions: MANAGE_CHANNELS. */
export type ChannelCreate = {
  __typename?: 'ChannelCreate';
  channel?: Maybe<Channel>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

export type ChannelCreateInput = {
  /** List of shipping zones to assign to the channel. */
  addShippingZones?: InputMaybe<Array<Scalars['ID']>>;
  /** Currency of the channel. */
  currencyCode: Scalars['String'];
  /** Added in Saleor 3.1. Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  defaultCountry: CountryCode;
  /** isActive flag. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** Name of the channel. */
  name: Scalars['String'];
  /** Slug of the channel. */
  slug: Scalars['String'];
};

export type ChannelCreated = {
  __typename?: 'ChannelCreated';
  /** Added in Saleor 3.2. Look up a channel. Note: this feature is in a preview state and can be subject to changes at later point. */
  channel?: Maybe<Channel>;
};

/** Deactivate a channel. Requires one of the following permissions: MANAGE_CHANNELS. */
export type ChannelDeactivate = {
  __typename?: 'ChannelDeactivate';
  /** Deactivated channel. */
  channel?: Maybe<Channel>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

/** Delete a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed. Requires one of the following permissions: MANAGE_CHANNELS. */
export type ChannelDelete = {
  __typename?: 'ChannelDelete';
  channel?: Maybe<Channel>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

export type ChannelDeleteInput = {
  /** ID of channel to migrate orders from origin channel. */
  channelId: Scalars['ID'];
};

export type ChannelDeleted = {
  __typename?: 'ChannelDeleted';
  /** Added in Saleor 3.2. Look up a channel. Note: this feature is in a preview state and can be subject to changes at later point. */
  channel?: Maybe<Channel>;
};

export type ChannelError = {
  __typename?: 'ChannelError';
  /** The error code. */
  code: ChannelErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of shipping zone IDs which causes the error. */
  shippingZones?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum ChannelErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  ChannelsCurrencyMustBeTheSame = 'CHANNELS_CURRENCY_MUST_BE_THE_SAME',
  ChannelWithOrders = 'CHANNEL_WITH_ORDERS',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type ChannelStatusChanged = {
  __typename?: 'ChannelStatusChanged';
  /** Added in Saleor 3.2. Look up a channel. Note: this feature is in a preview state and can be subject to changes at later point. */
  channel?: Maybe<Channel>;
};

/** Update a channel. Requires one of the following permissions: MANAGE_CHANNELS. */
export type ChannelUpdate = {
  __typename?: 'ChannelUpdate';
  channel?: Maybe<Channel>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  channelErrors: Array<ChannelError>;
  errors: Array<ChannelError>;
};

export type ChannelUpdateInput = {
  /** List of shipping zones to assign to the channel. */
  addShippingZones?: InputMaybe<Array<Scalars['ID']>>;
  /** Added in Saleor 3.1. Default country for the channel. Default country can be used in checkout to determine the stock quantities or calculate taxes when the country was not explicitly provided. */
  defaultCountry?: InputMaybe<CountryCode>;
  /** isActive flag. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** Name of the channel. */
  name?: InputMaybe<Scalars['String']>;
  /** List of shipping zones to unassign from the channel. */
  removeShippingZones?: InputMaybe<Array<Scalars['ID']>>;
  /** Slug of the channel. */
  slug?: InputMaybe<Scalars['String']>;
};

export type ChannelUpdated = {
  __typename?: 'ChannelUpdated';
  /** Added in Saleor 3.2. Look up a channel. Note: this feature is in a preview state and can be subject to changes at later point. */
  channel?: Maybe<Channel>;
};

/** Checkout object. */
export type Checkout = Node & ObjectWithMetadata & {
  __typename?: 'Checkout';
  /** Added in Saleor 3.1. Collection points that can be used for this order. Note: this feature is in a preview state and can be subject to changes at later point. */
  availableCollectionPoints: Array<Warehouse>;
  /** List of available payment gateways. */
  availablePaymentGateways: Array<PaymentGateway>;
  /**
   * Shipping methods that can be used with this checkout.
   * @deprecated This field will be removed in Saleor 4.0. Use `shippingMethods` instead.
   */
  availableShippingMethods: Array<ShippingMethod>;
  billingAddress?: Maybe<Address>;
  channel: Channel;
  created: Scalars['DateTime'];
  /** Added in Saleor 3.1. The delivery method selected for this checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  deliveryMethod?: Maybe<DeliveryMethod>;
  discount?: Maybe<Money>;
  discountName?: Maybe<Scalars['String']>;
  /** Email of a customer. */
  email?: Maybe<Scalars['String']>;
  /** List of gift cards associated with this checkout. */
  giftCards: Array<GiftCard>;
  id: Scalars['ID'];
  /** Returns True, if checkout requires shipping. */
  isShippingRequired: Scalars['Boolean'];
  /** Checkout language code. */
  languageCode: LanguageCodeEnum;
  lastChange: Scalars['DateTime'];
  /** A list of checkout lines, each containing information about an item in the checkout. */
  lines: Array<CheckoutLine>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  note: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** The number of items purchased. */
  quantity: Scalars['Int'];
  shippingAddress?: Maybe<Address>;
  /**
   * The shipping method related with checkout.
   * @deprecated This field will be removed in Saleor 4.0. Use `deliveryMethod` instead.
   */
  shippingMethod?: Maybe<ShippingMethod>;
  /** Shipping methods that can be used with this checkout. */
  shippingMethods: Array<ShippingMethod>;
  /** The price of the shipping, with all the taxes included. */
  shippingPrice: TaxedMoney;
  /** Added in Saleor 3.1. Date when oldest stock reservation for this checkout  expires or null if no stock is reserved. */
  stockReservationExpires?: Maybe<Scalars['DateTime']>;
  /** The price of the checkout before shipping, with taxes included. */
  subtotalPrice: TaxedMoney;
  /** The checkout's token. */
  token: Scalars['UUID'];
  /** The sum of the the checkout line prices, with all the taxes,shipping costs, and discounts included. */
  totalPrice: TaxedMoney;
  translatedDiscountName?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
  voucherCode?: Maybe<Scalars['String']>;
};


/** Checkout object. */
export type CheckoutMetafieldArgs = {
  key: Scalars['String'];
};


/** Checkout object. */
export type CheckoutMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Checkout object. */
export type CheckoutPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Checkout object. */
export type CheckoutPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Adds a gift card or a voucher to a checkout. */
export type CheckoutAddPromoCode = {
  __typename?: 'CheckoutAddPromoCode';
  /** The checkout with the added gift card or voucher. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Update billing address in the existing checkout. */
export type CheckoutBillingAddressUpdate = {
  __typename?: 'CheckoutBillingAddressUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Completes the checkout. As a result a new order is created and a payment charge is made. This action requires a successful payment before it can be performed. In case additional confirmation step as 3D secure is required confirmationNeeded flag will be set to True and no order created until payment is confirmed with second call of this mutation. */
export type CheckoutComplete = {
  __typename?: 'CheckoutComplete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  /** Confirmation data used to process additional authorization steps. */
  confirmationData?: Maybe<Scalars['JSONString']>;
  /** Set to true if payment needs to be confirmed before checkout is complete. */
  confirmationNeeded: Scalars['Boolean'];
  errors: Array<CheckoutError>;
  /** Placed order. */
  order?: Maybe<Order>;
};

export type CheckoutCountableConnection = {
  __typename?: 'CheckoutCountableConnection';
  edges: Array<CheckoutCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type CheckoutCountableEdge = {
  __typename?: 'CheckoutCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Checkout;
};

/** Create a new checkout. */
export type CheckoutCreate = {
  __typename?: 'CheckoutCreate';
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  /**
   * Whether the checkout was created or the current active one was returned. Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart with an active checkout.
   * @deprecated This field will be removed in Saleor 4.0. Always returns `true`.
   */
  created?: Maybe<Scalars['Boolean']>;
  errors: Array<CheckoutError>;
};

export type CheckoutCreateInput = {
  /** Billing address of the customer. */
  billingAddress?: InputMaybe<AddressInput>;
  /** Slug of a channel in which to create a checkout. */
  channel?: InputMaybe<Scalars['String']>;
  /** The customer's email address. */
  email?: InputMaybe<Scalars['String']>;
  /** Checkout language code. */
  languageCode?: InputMaybe<LanguageCodeEnum>;
  /** A list of checkout lines, each containing information about an item in the checkout. */
  lines: Array<CheckoutLineInput>;
  /** The mailing address to where the checkout will be shipped. Note: the address will be ignored if the checkout doesn't contain shippable items. */
  shippingAddress?: InputMaybe<AddressInput>;
};

export type CheckoutCreated = {
  __typename?: 'CheckoutCreated';
  /** Added in Saleor 3.2. Look up a Checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  checkout?: Maybe<Checkout>;
};

/** Sets the customer as the owner of the checkout. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER. */
export type CheckoutCustomerAttach = {
  __typename?: 'CheckoutCustomerAttach';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Removes the user assigned as the owner of the checkout. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER. */
export type CheckoutCustomerDetach = {
  __typename?: 'CheckoutCustomerDetach';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Added in Saleor 3.1. Updates the delivery method (shipping method or pick up point) of the checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
export type CheckoutDeliveryMethodUpdate = {
  __typename?: 'CheckoutDeliveryMethodUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  errors: Array<CheckoutError>;
};

/** Updates email address in the existing checkout object. */
export type CheckoutEmailUpdate = {
  __typename?: 'CheckoutEmailUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export type CheckoutError = {
  __typename?: 'CheckoutError';
  /** A type of address that causes the error. */
  addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: CheckoutErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** List of line Ids which cause the error. */
  lines?: Maybe<Array<Scalars['ID']>>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of varint IDs which causes the error. */
  variants?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum CheckoutErrorCode {
  BillingAddressNotSet = 'BILLING_ADDRESS_NOT_SET',
  ChannelInactive = 'CHANNEL_INACTIVE',
  CheckoutNotFullyPaid = 'CHECKOUT_NOT_FULLY_PAID',
  DeliveryMethodNotApplicable = 'DELIVERY_METHOD_NOT_APPLICABLE',
  EmailNotSet = 'EMAIL_NOT_SET',
  GiftCardNotApplicable = 'GIFT_CARD_NOT_APPLICABLE',
  GraphqlError = 'GRAPHQL_ERROR',
  InsufficientStock = 'INSUFFICIENT_STOCK',
  Invalid = 'INVALID',
  InvalidShippingMethod = 'INVALID_SHIPPING_METHOD',
  MissingChannelSlug = 'MISSING_CHANNEL_SLUG',
  NotFound = 'NOT_FOUND',
  NoLines = 'NO_LINES',
  PaymentError = 'PAYMENT_ERROR',
  ProductNotPublished = 'PRODUCT_NOT_PUBLISHED',
  ProductUnavailableForPurchase = 'PRODUCT_UNAVAILABLE_FOR_PURCHASE',
  QuantityGreaterThanLimit = 'QUANTITY_GREATER_THAN_LIMIT',
  Required = 'REQUIRED',
  ShippingAddressNotSet = 'SHIPPING_ADDRESS_NOT_SET',
  ShippingMethodNotApplicable = 'SHIPPING_METHOD_NOT_APPLICABLE',
  ShippingMethodNotSet = 'SHIPPING_METHOD_NOT_SET',
  ShippingNotRequired = 'SHIPPING_NOT_REQUIRED',
  TaxError = 'TAX_ERROR',
  UnavailableVariantInChannel = 'UNAVAILABLE_VARIANT_IN_CHANNEL',
  Unique = 'UNIQUE',
  VoucherNotApplicable = 'VOUCHER_NOT_APPLICABLE',
  ZeroQuantity = 'ZERO_QUANTITY'
}

export type CheckoutFilterInput = {
  channels?: InputMaybe<Array<Scalars['ID']>>;
  created?: InputMaybe<DateRangeInput>;
  customer?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
};

/** Update language code in the existing checkout. */
export type CheckoutLanguageCodeUpdate = {
  __typename?: 'CheckoutLanguageCodeUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Represents an item in the checkout. */
export type CheckoutLine = Node & {
  __typename?: 'CheckoutLine';
  id: Scalars['ID'];
  quantity: Scalars['Int'];
  /** Indicates whether the item need to be delivered. */
  requiresShipping: Scalars['Boolean'];
  /** The sum of the checkout line price, taxes and discounts. */
  totalPrice: TaxedMoney;
  variant: ProductVariant;
};

export type CheckoutLineCountableConnection = {
  __typename?: 'CheckoutLineCountableConnection';
  edges: Array<CheckoutLineCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type CheckoutLineCountableEdge = {
  __typename?: 'CheckoutLineCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: CheckoutLine;
};

/** Deletes a CheckoutLine. */
export type CheckoutLineDelete = {
  __typename?: 'CheckoutLineDelete';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export type CheckoutLineInput = {
  /** Added in Saleor 3.1. Custom price of the item. Can be set only by apps with `HANDLE_CHECKOUTS` permission. When the line with the same variant will be provided multiple times, the last price will be used. Note: this feature is in a preview state and can be subject to changes at later point. */
  price?: InputMaybe<Scalars['PositiveDecimal']>;
  /** The number of items purchased. */
  quantity: Scalars['Int'];
  /** ID of the product variant. */
  variantId: Scalars['ID'];
};

export type CheckoutLineUpdateInput = {
  /** Added in Saleor 3.1. Custom price of the item. Can be set only by apps with `HANDLE_CHECKOUTS` permission. When the line with the same variant will be provided multiple times, the last price will be used. Note: this feature is in a preview state and can be subject to changes at later point. */
  price?: InputMaybe<Scalars['PositiveDecimal']>;
  /** The number of items purchased. Optional for apps, required for any other users. */
  quantity?: InputMaybe<Scalars['Int']>;
  /** ID of the product variant. */
  variantId: Scalars['ID'];
};

/** Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased. */
export type CheckoutLinesAdd = {
  __typename?: 'CheckoutLinesAdd';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Deletes checkout lines. */
export type CheckoutLinesDelete = {
  __typename?: 'CheckoutLinesDelete';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  errors: Array<CheckoutError>;
};

/** Updates checkout line in the existing checkout. */
export type CheckoutLinesUpdate = {
  __typename?: 'CheckoutLinesUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Create a new payment for given checkout. */
export type CheckoutPaymentCreate = {
  __typename?: 'CheckoutPaymentCreate';
  /** Related checkout object. */
  checkout?: Maybe<Checkout>;
  errors: Array<PaymentError>;
  /** A newly created payment. */
  payment?: Maybe<Payment>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Remove a gift card or a voucher from a checkout. */
export type CheckoutRemovePromoCode = {
  __typename?: 'CheckoutRemovePromoCode';
  /** The checkout with the removed gift card or voucher. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Update shipping address in the existing checkout. */
export type CheckoutShippingAddressUpdate = {
  __typename?: 'CheckoutShippingAddressUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

/** Updates the shipping method of the checkout. */
export type CheckoutShippingMethodUpdate = {
  __typename?: 'CheckoutShippingMethodUpdate';
  /** An updated checkout. */
  checkout?: Maybe<Checkout>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  checkoutErrors: Array<CheckoutError>;
  errors: Array<CheckoutError>;
};

export enum CheckoutSortField {
  /** Sort checkouts by creation date. */
  CreationDate = 'CREATION_DATE',
  /** Sort checkouts by customer. */
  Customer = 'CUSTOMER',
  /** Sort checkouts by payment. */
  Payment = 'PAYMENT'
}

export type CheckoutSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort checkouts by the selected field. */
  field: CheckoutSortField;
};

export type CheckoutUpdated = {
  __typename?: 'CheckoutUpdated';
  /** Added in Saleor 3.2. Look up a Checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  checkout?: Maybe<Checkout>;
};

export type ChoiceValue = {
  __typename?: 'ChoiceValue';
  raw?: Maybe<Scalars['String']>;
  verbose?: Maybe<Scalars['String']>;
};

/** Represents a collection of products. */
export type Collection = Node & ObjectWithMetadata & {
  __typename?: 'Collection';
  backgroundImage?: Maybe<Image>;
  /** Channel given to retrieve this collection. Also used by federation gateway to resolve this object in a federated query. */
  channel?: Maybe<Scalars['String']>;
  /** List of channels in which the collection is available. Requires one of the following permissions: MANAGE_PRODUCTS. */
  channelListings?: Maybe<Array<CollectionChannelListing>>;
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Description of the collection (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** List of products in this collection. */
  products?: Maybe<ProductCountableConnection>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  slug: Scalars['String'];
  /** Returns translated collection fields for the given language code. */
  translation?: Maybe<CollectionTranslation>;
};


/** Represents a collection of products. */
export type CollectionBackgroundImageArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents a collection of products. */
export type CollectionMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a collection of products. */
export type CollectionMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a collection of products. */
export type CollectionPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a collection of products. */
export type CollectionPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a collection of products. */
export type CollectionProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ProductFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<ProductOrder>;
};


/** Represents a collection of products. */
export type CollectionTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Adds products to a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionAddProducts = {
  __typename?: 'CollectionAddProducts';
  /** Collection to which products will be added. */
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

/** Deletes collections. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionBulkDelete = {
  __typename?: 'CollectionBulkDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<CollectionError>;
};

/** Represents collection channel listing. */
export type CollectionChannelListing = Node & {
  __typename?: 'CollectionChannelListing';
  channel: Channel;
  id: Scalars['ID'];
  isPublished: Scalars['Boolean'];
  /** @deprecated This field will be removed in Saleor 4.0. Use the `publishedAt` field to fetch the publication date. */
  publicationDate?: Maybe<Scalars['Date']>;
  /** Added in Saleor 3.3. The collection publication date. */
  publishedAt?: Maybe<Scalars['DateTime']>;
};

export type CollectionChannelListingError = {
  __typename?: 'CollectionChannelListingError';
  /** List of attributes IDs which causes the error. */
  attributes?: Maybe<Array<Scalars['ID']>>;
  /** List of channels IDs which causes the error. */
  channels?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values?: Maybe<Array<Scalars['ID']>>;
};

/** Manage collection's availability in channels. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionChannelListingUpdate = {
  __typename?: 'CollectionChannelListingUpdate';
  /** An updated collection instance. */
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionChannelListingErrors: Array<CollectionChannelListingError>;
  errors: Array<CollectionChannelListingError>;
};

export type CollectionChannelListingUpdateInput = {
  /** List of channels to which the collection should be assigned. */
  addChannels?: InputMaybe<Array<PublishableChannelListingInput>>;
  /** List of channels from which the collection should be unassigned. */
  removeChannels?: InputMaybe<Array<Scalars['ID']>>;
};

export type CollectionCountableConnection = {
  __typename?: 'CollectionCountableConnection';
  edges: Array<CollectionCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type CollectionCountableEdge = {
  __typename?: 'CollectionCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Collection;
};

/** Creates a new collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionCreate = {
  __typename?: 'CollectionCreate';
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

export type CollectionCreateInput = {
  /** Background image file. */
  backgroundImage?: InputMaybe<Scalars['Upload']>;
  /** Alt text for an image. */
  backgroundImageAlt?: InputMaybe<Scalars['String']>;
  /** Description of the collection (JSON). */
  description?: InputMaybe<Scalars['JSONString']>;
  /** Informs whether a collection is published. */
  isPublished?: InputMaybe<Scalars['Boolean']>;
  /** Name of the collection. */
  name?: InputMaybe<Scalars['String']>;
  /** List of products to be added to the collection. */
  products?: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Publication date. ISO 8601 standard.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  publicationDate?: InputMaybe<Scalars['Date']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Slug of the collection. */
  slug?: InputMaybe<Scalars['String']>;
};

export type CollectionCreated = {
  __typename?: 'CollectionCreated';
  /** Added in Saleor 3.2. Look up a collection. Note: this feature is in a preview state and can be subject to changes at later point. */
  collection?: Maybe<Collection>;
};


export type CollectionCreatedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionDelete = {
  __typename?: 'CollectionDelete';
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

export type CollectionDeleted = {
  __typename?: 'CollectionDeleted';
  /** Added in Saleor 3.2. Look up a collection. Note: this feature is in a preview state and can be subject to changes at later point. */
  collection?: Maybe<Collection>;
};


export type CollectionDeletedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

export type CollectionError = {
  __typename?: 'CollectionError';
  /** The error code. */
  code: CollectionErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of products IDs which causes the error. */
  products?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum CollectionErrorCode {
  CannotManageProductWithoutVariant = 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type CollectionFilterInput = {
  /**
   * Specifies the channel by which the data should be filtered.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  published?: InputMaybe<CollectionPublished>;
  search?: InputMaybe<Scalars['String']>;
};

export type CollectionInput = {
  /** Background image file. */
  backgroundImage?: InputMaybe<Scalars['Upload']>;
  /** Alt text for an image. */
  backgroundImageAlt?: InputMaybe<Scalars['String']>;
  /** Description of the collection (JSON). */
  description?: InputMaybe<Scalars['JSONString']>;
  /** Informs whether a collection is published. */
  isPublished?: InputMaybe<Scalars['Boolean']>;
  /** Name of the collection. */
  name?: InputMaybe<Scalars['String']>;
  /**
   * Publication date. ISO 8601 standard.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  publicationDate?: InputMaybe<Scalars['Date']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Slug of the collection. */
  slug?: InputMaybe<Scalars['String']>;
};

export enum CollectionPublished {
  Hidden = 'HIDDEN',
  Published = 'PUBLISHED'
}

/** Remove products from a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionRemoveProducts = {
  __typename?: 'CollectionRemoveProducts';
  /** Collection from which products will be removed. */
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

/** Reorder the products of a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionReorderProducts = {
  __typename?: 'CollectionReorderProducts';
  /** Collection from which products are reordered. */
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

export enum CollectionSortField {
  /** Sort collections by availability. */
  Availability = 'AVAILABILITY',
  /** Sort collections by name. */
  Name = 'NAME',
  /** Sort collections by product count. */
  ProductCount = 'PRODUCT_COUNT',
  /**
   * Sort collections by publication date.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  PublicationDate = 'PUBLICATION_DATE',
  /**
   * Sort collections by publication date.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  PublishedAt = 'PUBLISHED_AT'
}

export type CollectionSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort collections by the selected field. */
  field: CollectionSortField;
};

export type CollectionTranslatableContent = Node & {
  __typename?: 'CollectionTranslatableContent';
  /**
   * Represents a collection of products.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  collection?: Maybe<Collection>;
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Description of the collection (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  /** Returns translated collection fields for the given language code. */
  translation?: Maybe<CollectionTranslation>;
};


export type CollectionTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a collection. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type CollectionTranslate = {
  __typename?: 'CollectionTranslate';
  collection?: Maybe<Collection>;
  errors: Array<TranslationError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type CollectionTranslation = Node & {
  __typename?: 'CollectionTranslation';
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the product (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name?: Maybe<Scalars['String']>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
};

/** Updates a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type CollectionUpdate = {
  __typename?: 'CollectionUpdate';
  collection?: Maybe<Collection>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  collectionErrors: Array<CollectionError>;
  errors: Array<CollectionError>;
};

export type CollectionUpdated = {
  __typename?: 'CollectionUpdated';
  /** Added in Saleor 3.2. Look up a collection. Note: this feature is in a preview state and can be subject to changes at later point. */
  collection?: Maybe<Collection>;
};


export type CollectionUpdatedCollectionArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Stores information about a single configuration field. */
export type ConfigurationItem = {
  __typename?: 'ConfigurationItem';
  /** Help text for the field. */
  helpText?: Maybe<Scalars['String']>;
  /** Label for the field. */
  label?: Maybe<Scalars['String']>;
  /** Name of the field. */
  name: Scalars['String'];
  /** Type of the field. */
  type?: Maybe<ConfigurationTypeFieldEnum>;
  /** Current value of the field. */
  value?: Maybe<Scalars['String']>;
};

export type ConfigurationItemInput = {
  /** Name of the field to update. */
  name: Scalars['String'];
  /** Value of the given field to update. */
  value?: InputMaybe<Scalars['String']>;
};

/** An enumeration. */
export enum ConfigurationTypeFieldEnum {
  Boolean = 'BOOLEAN',
  Multiline = 'MULTILINE',
  Output = 'OUTPUT',
  Password = 'PASSWORD',
  Secret = 'SECRET',
  Secretmultiline = 'SECRETMULTILINE',
  String = 'STRING'
}

/** Confirm user account with token sent by email during registration. */
export type ConfirmAccount = {
  __typename?: 'ConfirmAccount';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An activated user account. */
  user?: Maybe<User>;
};

/** Confirm the email change of the logged-in user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type ConfirmEmailChange = {
  __typename?: 'ConfirmEmailChange';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** A user instance with a new email. */
  user?: Maybe<User>;
};

/** An enumeration. */
export enum CountryCode {
  Ad = 'AD',
  Ae = 'AE',
  Af = 'AF',
  Ag = 'AG',
  Ai = 'AI',
  Al = 'AL',
  Am = 'AM',
  Ao = 'AO',
  Aq = 'AQ',
  Ar = 'AR',
  As = 'AS',
  At = 'AT',
  Au = 'AU',
  Aw = 'AW',
  Ax = 'AX',
  Az = 'AZ',
  Ba = 'BA',
  Bb = 'BB',
  Bd = 'BD',
  Be = 'BE',
  Bf = 'BF',
  Bg = 'BG',
  Bh = 'BH',
  Bi = 'BI',
  Bj = 'BJ',
  Bl = 'BL',
  Bm = 'BM',
  Bn = 'BN',
  Bo = 'BO',
  Bq = 'BQ',
  Br = 'BR',
  Bs = 'BS',
  Bt = 'BT',
  Bv = 'BV',
  Bw = 'BW',
  By = 'BY',
  Bz = 'BZ',
  Ca = 'CA',
  Cc = 'CC',
  Cd = 'CD',
  Cf = 'CF',
  Cg = 'CG',
  Ch = 'CH',
  Ci = 'CI',
  Ck = 'CK',
  Cl = 'CL',
  Cm = 'CM',
  Cn = 'CN',
  Co = 'CO',
  Cr = 'CR',
  Cu = 'CU',
  Cv = 'CV',
  Cw = 'CW',
  Cx = 'CX',
  Cy = 'CY',
  Cz = 'CZ',
  De = 'DE',
  Dj = 'DJ',
  Dk = 'DK',
  Dm = 'DM',
  Do = 'DO',
  Dz = 'DZ',
  Ec = 'EC',
  Ee = 'EE',
  Eg = 'EG',
  Eh = 'EH',
  Er = 'ER',
  Es = 'ES',
  Et = 'ET',
  Eu = 'EU',
  Fi = 'FI',
  Fj = 'FJ',
  Fk = 'FK',
  Fm = 'FM',
  Fo = 'FO',
  Fr = 'FR',
  Ga = 'GA',
  Gb = 'GB',
  Gd = 'GD',
  Ge = 'GE',
  Gf = 'GF',
  Gg = 'GG',
  Gh = 'GH',
  Gi = 'GI',
  Gl = 'GL',
  Gm = 'GM',
  Gn = 'GN',
  Gp = 'GP',
  Gq = 'GQ',
  Gr = 'GR',
  Gs = 'GS',
  Gt = 'GT',
  Gu = 'GU',
  Gw = 'GW',
  Gy = 'GY',
  Hk = 'HK',
  Hm = 'HM',
  Hn = 'HN',
  Hr = 'HR',
  Ht = 'HT',
  Hu = 'HU',
  Id = 'ID',
  Ie = 'IE',
  Il = 'IL',
  Im = 'IM',
  In = 'IN',
  Io = 'IO',
  Iq = 'IQ',
  Ir = 'IR',
  Is = 'IS',
  It = 'IT',
  Je = 'JE',
  Jm = 'JM',
  Jo = 'JO',
  Jp = 'JP',
  Ke = 'KE',
  Kg = 'KG',
  Kh = 'KH',
  Ki = 'KI',
  Km = 'KM',
  Kn = 'KN',
  Kp = 'KP',
  Kr = 'KR',
  Kw = 'KW',
  Ky = 'KY',
  Kz = 'KZ',
  La = 'LA',
  Lb = 'LB',
  Lc = 'LC',
  Li = 'LI',
  Lk = 'LK',
  Lr = 'LR',
  Ls = 'LS',
  Lt = 'LT',
  Lu = 'LU',
  Lv = 'LV',
  Ly = 'LY',
  Ma = 'MA',
  Mc = 'MC',
  Md = 'MD',
  Me = 'ME',
  Mf = 'MF',
  Mg = 'MG',
  Mh = 'MH',
  Mk = 'MK',
  Ml = 'ML',
  Mm = 'MM',
  Mn = 'MN',
  Mo = 'MO',
  Mp = 'MP',
  Mq = 'MQ',
  Mr = 'MR',
  Ms = 'MS',
  Mt = 'MT',
  Mu = 'MU',
  Mv = 'MV',
  Mw = 'MW',
  Mx = 'MX',
  My = 'MY',
  Mz = 'MZ',
  Na = 'NA',
  Nc = 'NC',
  Ne = 'NE',
  Nf = 'NF',
  Ng = 'NG',
  Ni = 'NI',
  Nl = 'NL',
  No = 'NO',
  Np = 'NP',
  Nr = 'NR',
  Nu = 'NU',
  Nz = 'NZ',
  Om = 'OM',
  Pa = 'PA',
  Pe = 'PE',
  Pf = 'PF',
  Pg = 'PG',
  Ph = 'PH',
  Pk = 'PK',
  Pl = 'PL',
  Pm = 'PM',
  Pn = 'PN',
  Pr = 'PR',
  Ps = 'PS',
  Pt = 'PT',
  Pw = 'PW',
  Py = 'PY',
  Qa = 'QA',
  Re = 'RE',
  Ro = 'RO',
  Rs = 'RS',
  Ru = 'RU',
  Rw = 'RW',
  Sa = 'SA',
  Sb = 'SB',
  Sc = 'SC',
  Sd = 'SD',
  Se = 'SE',
  Sg = 'SG',
  Sh = 'SH',
  Si = 'SI',
  Sj = 'SJ',
  Sk = 'SK',
  Sl = 'SL',
  Sm = 'SM',
  Sn = 'SN',
  So = 'SO',
  Sr = 'SR',
  Ss = 'SS',
  St = 'ST',
  Sv = 'SV',
  Sx = 'SX',
  Sy = 'SY',
  Sz = 'SZ',
  Tc = 'TC',
  Td = 'TD',
  Tf = 'TF',
  Tg = 'TG',
  Th = 'TH',
  Tj = 'TJ',
  Tk = 'TK',
  Tl = 'TL',
  Tm = 'TM',
  Tn = 'TN',
  To = 'TO',
  Tr = 'TR',
  Tt = 'TT',
  Tv = 'TV',
  Tw = 'TW',
  Tz = 'TZ',
  Ua = 'UA',
  Ug = 'UG',
  Um = 'UM',
  Us = 'US',
  Uy = 'UY',
  Uz = 'UZ',
  Va = 'VA',
  Vc = 'VC',
  Ve = 'VE',
  Vg = 'VG',
  Vi = 'VI',
  Vn = 'VN',
  Vu = 'VU',
  Wf = 'WF',
  Ws = 'WS',
  Ye = 'YE',
  Yt = 'YT',
  Za = 'ZA',
  Zm = 'ZM',
  Zw = 'ZW'
}

export type CountryDisplay = {
  __typename?: 'CountryDisplay';
  /** Country code. */
  code: Scalars['String'];
  /** Country name. */
  country: Scalars['String'];
  /** Country tax. */
  vat?: Maybe<Vat>;
};

export type CountryFilterInput = {
  /** Boolean for filtering countries by having shipping zone assigned.If 'true', return countries with shipping zone assigned.If 'false', return countries without any shipping zone assigned.If the argument is not provided (null), return all countries. */
  attachedToShippingZones?: InputMaybe<Scalars['Boolean']>;
};

/** Create JWT token. */
export type CreateToken = {
  __typename?: 'CreateToken';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate access token. */
  csrfToken?: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** JWT refresh token, required to re-generate access token. */
  refreshToken?: Maybe<Scalars['String']>;
  /** JWT token, required to authenticate. */
  token?: Maybe<Scalars['String']>;
  /** A user instance. */
  user?: Maybe<User>;
};

export type CreditCard = {
  __typename?: 'CreditCard';
  /** Card brand. */
  brand: Scalars['String'];
  /** Two-digit number representing the cards expiration month. */
  expMonth?: Maybe<Scalars['Int']>;
  /** Four-digit number representing the cards expiration year. */
  expYear?: Maybe<Scalars['Int']>;
  /** First 4 digits of the card number. */
  firstDigits?: Maybe<Scalars['String']>;
  /** Last 4 digits of the card number. */
  lastDigits: Scalars['String'];
};

/** Deletes customers. Requires one of the following permissions: MANAGE_USERS. */
export type CustomerBulkDelete = {
  __typename?: 'CustomerBulkDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AccountError>;
};

/** Creates a new customer. Requires one of the following permissions: MANAGE_USERS. */
export type CustomerCreate = {
  __typename?: 'CustomerCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user?: Maybe<User>;
};

export type CustomerCreated = {
  __typename?: 'CustomerCreated';
  /** Added in Saleor 3.2. Look up a user. Note: this feature is in a preview state and can be subject to changes at later point. */
  user?: Maybe<User>;
};

/** Deletes a customer. Requires one of the following permissions: MANAGE_USERS. */
export type CustomerDelete = {
  __typename?: 'CustomerDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user?: Maybe<User>;
};

/** History log of the customer. */
export type CustomerEvent = Node & {
  __typename?: 'CustomerEvent';
  /** App that performed the action. */
  app?: Maybe<App>;
  /** Number of objects concerned by the event. */
  count?: Maybe<Scalars['Int']>;
  /** Date when event happened at in ISO 8601 format. */
  date?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** Content of the event. */
  message?: Maybe<Scalars['String']>;
  /** The concerned order. */
  order?: Maybe<Order>;
  /** The concerned order line. */
  orderLine?: Maybe<OrderLine>;
  /** Customer event type. */
  type?: Maybe<CustomerEventsEnum>;
  /** User who performed the action. */
  user?: Maybe<User>;
};

/** An enumeration. */
export enum CustomerEventsEnum {
  AccountCreated = 'ACCOUNT_CREATED',
  CustomerDeleted = 'CUSTOMER_DELETED',
  DigitalLinkDownloaded = 'DIGITAL_LINK_DOWNLOADED',
  EmailAssigned = 'EMAIL_ASSIGNED',
  EmailChanged = 'EMAIL_CHANGED',
  EmailChangedRequest = 'EMAIL_CHANGED_REQUEST',
  NameAssigned = 'NAME_ASSIGNED',
  NoteAdded = 'NOTE_ADDED',
  NoteAddedToOrder = 'NOTE_ADDED_TO_ORDER',
  PasswordChanged = 'PASSWORD_CHANGED',
  PasswordReset = 'PASSWORD_RESET',
  PasswordResetLinkSent = 'PASSWORD_RESET_LINK_SENT',
  PlacedOrder = 'PLACED_ORDER'
}

export type CustomerFilterInput = {
  dateJoined?: InputMaybe<DateRangeInput>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  numberOfOrders?: InputMaybe<IntRangeInput>;
  placedOrders?: InputMaybe<DateRangeInput>;
  search?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type CustomerInput = {
  /** Billing address of the customer. */
  defaultBillingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  defaultShippingAddress?: InputMaybe<AddressInput>;
  /** The unique email address of the user. */
  email?: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** User language code. */
  languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** A note about the user. */
  note?: InputMaybe<Scalars['String']>;
};

/** Updates an existing customer. Requires one of the following permissions: MANAGE_USERS. */
export type CustomerUpdate = {
  __typename?: 'CustomerUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  user?: Maybe<User>;
};

export type CustomerUpdated = {
  __typename?: 'CustomerUpdated';
  /** Added in Saleor 3.2. Look up a user. Note: this feature is in a preview state and can be subject to changes at later point. */
  user?: Maybe<User>;
};

export type DateRangeInput = {
  /** Start date. */
  gte?: InputMaybe<Scalars['Date']>;
  /** End date. */
  lte?: InputMaybe<Scalars['Date']>;
};

export type DateTimeRangeInput = {
  /** Start date. */
  gte?: InputMaybe<Scalars['DateTime']>;
  /** End date. */
  lte?: InputMaybe<Scalars['DateTime']>;
};

/** Deactivate all JWT tokens of the currently authenticated user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type DeactivateAllUserTokens = {
  __typename?: 'DeactivateAllUserTokens';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
};

/** Delete metadata of an object. To use it, you need to have access to the modified object. */
export type DeleteMetadata = {
  __typename?: 'DeleteMetadata';
  errors: Array<MetadataError>;
  item?: Maybe<ObjectWithMetadata>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

/** Delete object's private metadata. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
export type DeletePrivateMetadata = {
  __typename?: 'DeletePrivateMetadata';
  errors: Array<MetadataError>;
  item?: Maybe<ObjectWithMetadata>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

/** Added in Saleor 3.1. Represents a delivery method chosen for the checkout. `Warehouse` type is used when checkout is marked as "click and collect" and `ShippingMethod` otherwise. Note: this feature is in a preview state and can be subject to changes at later point. */
export type DeliveryMethod = ShippingMethod | Warehouse;

export type DigitalContent = Node & ObjectWithMetadata & {
  __typename?: 'DigitalContent';
  automaticFulfillment: Scalars['Boolean'];
  contentFile: Scalars['String'];
  id: Scalars['ID'];
  maxDownloads?: Maybe<Scalars['Int']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Product variant assigned to digital content. */
  productVariant: ProductVariant;
  urlValidDays?: Maybe<Scalars['Int']>;
  /** List of URLs for the digital variant. */
  urls?: Maybe<Array<DigitalContentUrl>>;
  useDefaultSettings: Scalars['Boolean'];
};


export type DigitalContentMetafieldArgs = {
  key: Scalars['String'];
};


export type DigitalContentMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


export type DigitalContentPrivateMetafieldArgs = {
  key: Scalars['String'];
};


export type DigitalContentPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

export type DigitalContentCountableConnection = {
  __typename?: 'DigitalContentCountableConnection';
  edges: Array<DigitalContentCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type DigitalContentCountableEdge = {
  __typename?: 'DigitalContentCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: DigitalContent;
};

/** Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: MANAGE_PRODUCTS. */
export type DigitalContentCreate = {
  __typename?: 'DigitalContentCreate';
  content?: Maybe<DigitalContent>;
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  variant?: Maybe<ProductVariant>;
};

/** Remove digital content assigned to given variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type DigitalContentDelete = {
  __typename?: 'DigitalContentDelete';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  variant?: Maybe<ProductVariant>;
};

export type DigitalContentInput = {
  /** Overwrite default automatic_fulfillment setting for variant. */
  automaticFulfillment?: InputMaybe<Scalars['Boolean']>;
  /** Determines how many times a download link can be accessed by a customer. */
  maxDownloads?: InputMaybe<Scalars['Int']>;
  /** Determines for how many days a download link is active since it was generated. */
  urlValidDays?: InputMaybe<Scalars['Int']>;
  /** Use default digital content settings for this product. */
  useDefaultSettings: Scalars['Boolean'];
};

/** Update digital content. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type DigitalContentUpdate = {
  __typename?: 'DigitalContentUpdate';
  content?: Maybe<DigitalContent>;
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  variant?: Maybe<ProductVariant>;
};

export type DigitalContentUploadInput = {
  /** Overwrite default automatic_fulfillment setting for variant. */
  automaticFulfillment?: InputMaybe<Scalars['Boolean']>;
  /** Represents an file in a multipart request. */
  contentFile: Scalars['Upload'];
  /** Determines how many times a download link can be accessed by a customer. */
  maxDownloads?: InputMaybe<Scalars['Int']>;
  /** Determines for how many days a download link is active since it was generated. */
  urlValidDays?: InputMaybe<Scalars['Int']>;
  /** Use default digital content settings for this product. */
  useDefaultSettings: Scalars['Boolean'];
};

export type DigitalContentUrl = Node & {
  __typename?: 'DigitalContentUrl';
  content: DigitalContent;
  created: Scalars['DateTime'];
  downloadNum: Scalars['Int'];
  id: Scalars['ID'];
  /** UUID of digital content. */
  token: Scalars['UUID'];
  /** URL for digital content. */
  url?: Maybe<Scalars['String']>;
};

/** Generate new URL to digital content. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type DigitalContentUrlCreate = {
  __typename?: 'DigitalContentUrlCreate';
  digitalContentUrl?: Maybe<DigitalContentUrl>;
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type DigitalContentUrlCreateInput = {
  /** Digital content ID which URL will belong to. */
  content: Scalars['ID'];
};

export type DiscountError = {
  __typename?: 'DiscountError';
  /** List of channels IDs which causes the error. */
  channels?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: DiscountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of products IDs which causes the error. */
  products?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum DiscountErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  CannotManageProductWithoutVariant = 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export enum DiscountStatusEnum {
  Active = 'ACTIVE',
  Expired = 'EXPIRED',
  Scheduled = 'SCHEDULED'
}

export enum DiscountValueTypeEnum {
  Fixed = 'FIXED',
  Percentage = 'PERCENTAGE'
}

/** An enumeration. */
export enum DistanceUnitsEnum {
  Cm = 'CM',
  Ft = 'FT',
  Inch = 'INCH',
  Km = 'KM',
  M = 'M',
  Yd = 'YD'
}

/** Represents shop's domain. */
export type Domain = {
  __typename?: 'Domain';
  /** The host name of the domain. */
  host: Scalars['String'];
  /** Inform if SSL is enabled. */
  sslEnabled: Scalars['Boolean'];
  /** Shop's absolute URL. */
  url: Scalars['String'];
};

/** Deletes draft orders. Requires one of the following permissions: MANAGE_ORDERS. */
export type DraftOrderBulkDelete = {
  __typename?: 'DraftOrderBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<OrderError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Completes creating an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type DraftOrderComplete = {
  __typename?: 'DraftOrderComplete';
  errors: Array<OrderError>;
  /** Completed order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Creates a new draft order. Requires one of the following permissions: MANAGE_ORDERS. */
export type DraftOrderCreate = {
  __typename?: 'DraftOrderCreate';
  errors: Array<OrderError>;
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type DraftOrderCreateInput = {
  /** Billing address of the customer. */
  billingAddress?: InputMaybe<AddressInput>;
  /** ID of the channel associated with the order. */
  channelId?: InputMaybe<Scalars['ID']>;
  /** A note from a customer. Visible by customers in the order summary. */
  customerNote?: InputMaybe<Scalars['String']>;
  /** Discount amount for the order. */
  discount?: InputMaybe<Scalars['PositiveDecimal']>;
  /** Variant line input consisting of variant ID and quantity of products. */
  lines?: InputMaybe<Array<OrderLineCreateInput>>;
  /** URL of a view where users should be redirected to see the order details. URL in RFC 1808 format. */
  redirectUrl?: InputMaybe<Scalars['String']>;
  /** Shipping address of the customer. */
  shippingAddress?: InputMaybe<AddressInput>;
  /** ID of a selected shipping method. */
  shippingMethod?: InputMaybe<Scalars['ID']>;
  /** Customer associated with the draft order. */
  user?: InputMaybe<Scalars['ID']>;
  /** Email address of the customer. */
  userEmail?: InputMaybe<Scalars['String']>;
  /** ID of the voucher associated with the order. */
  voucher?: InputMaybe<Scalars['ID']>;
};

export type DraftOrderCreated = {
  __typename?: 'DraftOrderCreated';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

/** Deletes a draft order. Requires one of the following permissions: MANAGE_ORDERS. */
export type DraftOrderDelete = {
  __typename?: 'DraftOrderDelete';
  errors: Array<OrderError>;
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type DraftOrderDeleted = {
  __typename?: 'DraftOrderDeleted';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

export type DraftOrderInput = {
  /** Billing address of the customer. */
  billingAddress?: InputMaybe<AddressInput>;
  /** ID of the channel associated with the order. */
  channelId?: InputMaybe<Scalars['ID']>;
  /** A note from a customer. Visible by customers in the order summary. */
  customerNote?: InputMaybe<Scalars['String']>;
  /** Discount amount for the order. */
  discount?: InputMaybe<Scalars['PositiveDecimal']>;
  /** URL of a view where users should be redirected to see the order details. URL in RFC 1808 format. */
  redirectUrl?: InputMaybe<Scalars['String']>;
  /** Shipping address of the customer. */
  shippingAddress?: InputMaybe<AddressInput>;
  /** ID of a selected shipping method. */
  shippingMethod?: InputMaybe<Scalars['ID']>;
  /** Customer associated with the draft order. */
  user?: InputMaybe<Scalars['ID']>;
  /** Email address of the customer. */
  userEmail?: InputMaybe<Scalars['String']>;
  /** ID of the voucher associated with the order. */
  voucher?: InputMaybe<Scalars['ID']>;
};

/** Deletes order lines. Requires one of the following permissions: MANAGE_ORDERS. */
export type DraftOrderLinesBulkDelete = {
  __typename?: 'DraftOrderLinesBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<OrderError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Updates a draft order. Requires one of the following permissions: MANAGE_ORDERS. */
export type DraftOrderUpdate = {
  __typename?: 'DraftOrderUpdate';
  errors: Array<OrderError>;
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type DraftOrderUpdated = {
  __typename?: 'DraftOrderUpdated';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

export type Event = CategoryCreated | CategoryDeleted | CategoryUpdated | ChannelCreated | ChannelDeleted | ChannelStatusChanged | ChannelUpdated | CheckoutCreated | CheckoutUpdated | CollectionCreated | CollectionDeleted | CollectionUpdated | CustomerCreated | CustomerUpdated | DraftOrderCreated | DraftOrderDeleted | DraftOrderUpdated | FulfillmentCanceled | FulfillmentCreated | GiftCardCreated | GiftCardDeleted | GiftCardStatusChanged | GiftCardUpdated | InvoiceDeleted | InvoiceRequested | InvoiceSent | OrderCancelled | OrderConfirmed | OrderCreated | OrderFulfilled | OrderFullyPaid | OrderUpdated | PageCreated | PageDeleted | PageUpdated | ProductCreated | ProductDeleted | ProductUpdated | ProductVariantBackInStock | ProductVariantCreated | ProductVariantDeleted | ProductVariantOutOfStock | ProductVariantUpdated | SaleCreated | SaleDeleted | SaleUpdated | ShippingPriceCreated | ShippingPriceDeleted | ShippingPriceUpdated | ShippingZoneCreated | ShippingZoneDeleted | ShippingZoneUpdated | TranslationCreated | TranslationUpdated;

/** Event delivery. */
export type EventDelivery = Node & {
  __typename?: 'EventDelivery';
  /** Event delivery attempts. */
  attempts?: Maybe<EventDeliveryAttemptCountableConnection>;
  createdAt: Scalars['DateTime'];
  /** Webhook event type. */
  eventType: WebhookEventTypeEnum;
  id: Scalars['ID'];
  /** Event payload. */
  payload?: Maybe<Scalars['String']>;
  /** Event delivery status. */
  status: EventDeliveryStatusEnum;
};


/** Event delivery. */
export type EventDeliveryAttemptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<EventDeliveryAttemptSortingInput>;
};

/** Event delivery attempts. */
export type EventDeliveryAttempt = Node & {
  __typename?: 'EventDeliveryAttempt';
  /** Event delivery creation date and time. */
  createdAt: Scalars['DateTime'];
  /** Delivery attempt duration. */
  duration?: Maybe<Scalars['Float']>;
  id: Scalars['ID'];
  /** Request headers for delivery attempt. */
  requestHeaders?: Maybe<Scalars['String']>;
  /** Delivery attempt response content. */
  response?: Maybe<Scalars['String']>;
  /** Response headers for delivery attempt. */
  responseHeaders?: Maybe<Scalars['String']>;
  /** Delivery attempt response status code. */
  responseStatusCode?: Maybe<Scalars['Int']>;
  /** Event delivery status. */
  status: EventDeliveryStatusEnum;
  /** Task id for delivery attempt. */
  taskId?: Maybe<Scalars['String']>;
};

export type EventDeliveryAttemptCountableConnection = {
  __typename?: 'EventDeliveryAttemptCountableConnection';
  edges: Array<EventDeliveryAttemptCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type EventDeliveryAttemptCountableEdge = {
  __typename?: 'EventDeliveryAttemptCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: EventDeliveryAttempt;
};

export enum EventDeliveryAttemptSortField {
  /** Sort event delivery attempts by created at. */
  CreatedAt = 'CREATED_AT'
}

export type EventDeliveryAttemptSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort attempts by the selected field. */
  field: EventDeliveryAttemptSortField;
};

export type EventDeliveryCountableConnection = {
  __typename?: 'EventDeliveryCountableConnection';
  edges: Array<EventDeliveryCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type EventDeliveryCountableEdge = {
  __typename?: 'EventDeliveryCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: EventDelivery;
};

export type EventDeliveryFilterInput = {
  eventType?: InputMaybe<WebhookEventTypeEnum>;
  status?: InputMaybe<EventDeliveryStatusEnum>;
};

/** Retries event delivery. Requires one of the following permissions: MANAGE_APPS. */
export type EventDeliveryRetry = {
  __typename?: 'EventDeliveryRetry';
  /** Event delivery. */
  delivery?: Maybe<EventDelivery>;
  errors: Array<WebhookError>;
};

export enum EventDeliverySortField {
  /** Sort event deliveries by created at. */
  CreatedAt = 'CREATED_AT'
}

export type EventDeliverySortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort deliveries by the selected field. */
  field: EventDeliverySortField;
};

export enum EventDeliveryStatusEnum {
  Failed = 'FAILED',
  Pending = 'PENDING',
  Success = 'SUCCESS'
}

export type ExportError = {
  __typename?: 'ExportError';
  /** The error code. */
  code: ExportErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum ExportErrorCode {
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED'
}

/** History log of export file. */
export type ExportEvent = Node & {
  __typename?: 'ExportEvent';
  /** App which performed the action. Requires one of the following permissions: AuthorizationFilters.OWNER, AppPermission.MANAGE_APPS. */
  app?: Maybe<App>;
  /** Date when event happened at in ISO 8601 format. */
  date: Scalars['DateTime'];
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Content of the event. */
  message: Scalars['String'];
  /** Export event type. */
  type: ExportEventsEnum;
  /** User who performed the action. Requires one of the following permissions: AuthorizationFilters.OWNER, AccountPermissions.MANAGE_STAFF. */
  user?: Maybe<User>;
};

/** An enumeration. */
export enum ExportEventsEnum {
  ExportedFileSent = 'EXPORTED_FILE_SENT',
  ExportDeleted = 'EXPORT_DELETED',
  ExportFailed = 'EXPORT_FAILED',
  ExportFailedInfoSent = 'EXPORT_FAILED_INFO_SENT',
  ExportPending = 'EXPORT_PENDING',
  ExportSuccess = 'EXPORT_SUCCESS'
}

/** Represents a job data of exported file. */
export type ExportFile = Job & Node & {
  __typename?: 'ExportFile';
  app?: Maybe<App>;
  /** Created date time of job in ISO 8601 format. */
  createdAt: Scalars['DateTime'];
  /** List of events associated with the export. */
  events?: Maybe<Array<ExportEvent>>;
  id: Scalars['ID'];
  /** Job message. */
  message?: Maybe<Scalars['String']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  updatedAt: Scalars['DateTime'];
  /** The URL of field to download. */
  url?: Maybe<Scalars['String']>;
  user?: Maybe<User>;
};

export type ExportFileCountableConnection = {
  __typename?: 'ExportFileCountableConnection';
  edges: Array<ExportFileCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type ExportFileCountableEdge = {
  __typename?: 'ExportFileCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ExportFile;
};

export type ExportFileFilterInput = {
  app?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<DateTimeRangeInput>;
  status?: InputMaybe<JobStatusEnum>;
  updatedAt?: InputMaybe<DateTimeRangeInput>;
  user?: InputMaybe<Scalars['String']>;
};

export enum ExportFileSortField {
  CreatedAt = 'CREATED_AT',
  LastModifiedAt = 'LAST_MODIFIED_AT',
  Status = 'STATUS',
  UpdatedAt = 'UPDATED_AT'
}

export type ExportFileSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort export file by the selected field. */
  field: ExportFileSortField;
};

/** Added in Saleor 3.1. Export gift cards to csv file. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type ExportGiftCards = {
  __typename?: 'ExportGiftCards';
  errors: Array<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  exportFile?: Maybe<ExportFile>;
};

export type ExportGiftCardsInput = {
  /** Type of exported file. */
  fileType: FileTypesEnum;
  /** Filtering options for gift cards. */
  filter?: InputMaybe<GiftCardFilterInput>;
  /** List of gift cards IDs to export. */
  ids?: InputMaybe<Array<Scalars['ID']>>;
  /** Determine which gift cards should be exported. */
  scope: ExportScope;
};

export type ExportInfoInput = {
  /** List of attribute ids witch should be exported. */
  attributes?: InputMaybe<Array<Scalars['ID']>>;
  /** List of channels ids which should be exported. */
  channels?: InputMaybe<Array<Scalars['ID']>>;
  /** List of product fields witch should be exported. */
  fields?: InputMaybe<Array<ProductFieldEnum>>;
  /** List of warehouse ids witch should be exported. */
  warehouses?: InputMaybe<Array<Scalars['ID']>>;
};

/** Export products to csv file. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ExportProducts = {
  __typename?: 'ExportProducts';
  errors: Array<ExportError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  exportErrors: Array<ExportError>;
  /** The newly created export file job which is responsible for export data. */
  exportFile?: Maybe<ExportFile>;
};

export type ExportProductsInput = {
  /** Input with info about fields which should be exported. */
  exportInfo?: InputMaybe<ExportInfoInput>;
  /** Type of exported file. */
  fileType: FileTypesEnum;
  /** Filtering options for products. */
  filter?: InputMaybe<ProductFilterInput>;
  /** List of products IDs to export. */
  ids?: InputMaybe<Array<Scalars['ID']>>;
  /** Determine which products should be exported. */
  scope: ExportScope;
};

export enum ExportScope {
  /** Export all products. */
  All = 'ALL',
  /** Export the filtered products. */
  Filter = 'FILTER',
  /** Export products with given ids. */
  Ids = 'IDS'
}

export type ExternalAuthentication = {
  __typename?: 'ExternalAuthentication';
  /** ID of external authentication plugin. */
  id: Scalars['String'];
  /** Name of external authentication plugin. */
  name?: Maybe<Scalars['String']>;
};

/** Prepare external authentication url for user by custom plugin. */
export type ExternalAuthenticationUrl = {
  __typename?: 'ExternalAuthenticationUrl';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** The data returned by authentication plugin. */
  authenticationData?: Maybe<Scalars['JSONString']>;
  errors: Array<AccountError>;
};

/** Logout user by custom plugin. */
export type ExternalLogout = {
  __typename?: 'ExternalLogout';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** The data returned by authentication plugin. */
  logoutData?: Maybe<Scalars['JSONString']>;
};

export type ExternalNotificationError = {
  __typename?: 'ExternalNotificationError';
  /** The error code. */
  code: ExternalNotificationErrorCodes;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum ExternalNotificationErrorCodes {
  ChannelInactive = 'CHANNEL_INACTIVE',
  InvalidModelType = 'INVALID_MODEL_TYPE',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED'
}

/** Added in Saleor 3.1. Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload. */
export type ExternalNotificationTrigger = {
  __typename?: 'ExternalNotificationTrigger';
  errors: Array<ExternalNotificationError>;
};

export type ExternalNotificationTriggerInput = {
  /** External event type. This field is passed to a plugin as an event type. */
  externalEventType: Scalars['String'];
  /** Additional payload that will be merged with the one based on the bussines object ID. */
  extraPayload?: InputMaybe<Scalars['JSONString']>;
  /** The list of customers or orders node IDs that will be serialized and included in the notification payload. */
  ids: Array<Scalars['ID']>;
};

/** Obtain external access tokens for user by custom plugin. */
export type ExternalObtainAccessTokens = {
  __typename?: 'ExternalObtainAccessTokens';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate external access token. */
  csrfToken?: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** The refresh token, required to re-generate external access token. */
  refreshToken?: Maybe<Scalars['String']>;
  /** The token, required to authenticate. */
  token?: Maybe<Scalars['String']>;
  /** A user instance. */
  user?: Maybe<User>;
};

/** Refresh user's access by custom plugin. */
export type ExternalRefresh = {
  __typename?: 'ExternalRefresh';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate external access token. */
  csrfToken?: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** The refresh token, required to re-generate external access token. */
  refreshToken?: Maybe<Scalars['String']>;
  /** The token, required to authenticate. */
  token?: Maybe<Scalars['String']>;
  /** A user instance. */
  user?: Maybe<User>;
};

/** Verify external authentication data by plugin. */
export type ExternalVerify = {
  __typename?: 'ExternalVerify';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** Determine if authentication data is valid or not. */
  isValid: Scalars['Boolean'];
  /** User assigned to data. */
  user?: Maybe<User>;
  /** External data. */
  verifyData?: Maybe<Scalars['JSONString']>;
};

export type File = {
  __typename?: 'File';
  /** Content type of the file. */
  contentType?: Maybe<Scalars['String']>;
  /** The URL of the file. */
  url: Scalars['String'];
};

/** An enumeration. */
export enum FileTypesEnum {
  Csv = 'CSV',
  Xlsx = 'XLSX'
}

/** Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER. */
export type FileUpload = {
  __typename?: 'FileUpload';
  errors: Array<UploadError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  uploadErrors: Array<UploadError>;
  uploadedFile?: Maybe<File>;
};

/** Represents order fulfillment. */
export type Fulfillment = Node & ObjectWithMetadata & {
  __typename?: 'Fulfillment';
  created: Scalars['DateTime'];
  fulfillmentOrder: Scalars['Int'];
  id: Scalars['ID'];
  /** List of lines for the fulfillment. */
  lines?: Maybe<Array<FulfillmentLine>>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  status: FulfillmentStatus;
  /** User-friendly fulfillment status. */
  statusDisplay?: Maybe<Scalars['String']>;
  trackingNumber: Scalars['String'];
  /** Warehouse from fulfillment was fulfilled. */
  warehouse?: Maybe<Warehouse>;
};


/** Represents order fulfillment. */
export type FulfillmentMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents order fulfillment. */
export type FulfillmentMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents order fulfillment. */
export type FulfillmentPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents order fulfillment. */
export type FulfillmentPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Added in Saleor 3.1. Approve existing fulfillment. Requires one of the following permissions: MANAGE_ORDERS. */
export type FulfillmentApprove = {
  __typename?: 'FulfillmentApprove';
  errors: Array<OrderError>;
  /** An approved fulfillment. */
  fulfillment?: Maybe<Fulfillment>;
  /** Order which fulfillment was approved. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Cancels existing fulfillment and optionally restocks items. Requires one of the following permissions: MANAGE_ORDERS. */
export type FulfillmentCancel = {
  __typename?: 'FulfillmentCancel';
  errors: Array<OrderError>;
  /** A canceled fulfillment. */
  fulfillment?: Maybe<Fulfillment>;
  /** Order which fulfillment was cancelled. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type FulfillmentCancelInput = {
  /** ID of a warehouse where items will be restocked. Optional when fulfillment is in WAITING_FOR_APPROVAL state. */
  warehouseId?: InputMaybe<Scalars['ID']>;
};

export type FulfillmentCanceled = {
  __typename?: 'FulfillmentCanceled';
  /** Added in Saleor 3.2. Look up a Fulfillment. Note: this feature is in a preview state and can be subject to changes at later point. */
  fulfillment?: Maybe<Fulfillment>;
};

export type FulfillmentCreated = {
  __typename?: 'FulfillmentCreated';
  /** Added in Saleor 3.2. Look up a Fulfillment. Note: this feature is in a preview state and can be subject to changes at later point. */
  fulfillment?: Maybe<Fulfillment>;
};

/** Represents line of the fulfillment. */
export type FulfillmentLine = Node & {
  __typename?: 'FulfillmentLine';
  id: Scalars['ID'];
  orderLine?: Maybe<OrderLine>;
  quantity: Scalars['Int'];
};

/** Refund products. Requires one of the following permissions: MANAGE_ORDERS. */
export type FulfillmentRefundProducts = {
  __typename?: 'FulfillmentRefundProducts';
  errors: Array<OrderError>;
  /** A refunded fulfillment. */
  fulfillment?: Maybe<Fulfillment>;
  /** Order which fulfillment was refunded. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Return products. Requires one of the following permissions: MANAGE_ORDERS. */
export type FulfillmentReturnProducts = {
  __typename?: 'FulfillmentReturnProducts';
  errors: Array<OrderError>;
  /** Order which fulfillment was returned. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** A replace fulfillment. */
  replaceFulfillment?: Maybe<Fulfillment>;
  /** A draft order which was created for products with replace flag. */
  replaceOrder?: Maybe<Order>;
  /** A return fulfillment. */
  returnFulfillment?: Maybe<Fulfillment>;
};

/** An enumeration. */
export enum FulfillmentStatus {
  Canceled = 'CANCELED',
  Fulfilled = 'FULFILLED',
  Refunded = 'REFUNDED',
  RefundedAndReturned = 'REFUNDED_AND_RETURNED',
  Replaced = 'REPLACED',
  Returned = 'RETURNED',
  WaitingForApproval = 'WAITING_FOR_APPROVAL'
}

/** Updates a fulfillment for an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type FulfillmentUpdateTracking = {
  __typename?: 'FulfillmentUpdateTracking';
  errors: Array<OrderError>;
  /** A fulfillment with updated tracking. */
  fulfillment?: Maybe<Fulfillment>;
  /** Order for which fulfillment was updated. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type FulfillmentUpdateTrackingInput = {
  /** If true, send an email notification to the customer. */
  notifyCustomer?: InputMaybe<Scalars['Boolean']>;
  /** Fulfillment tracking number. */
  trackingNumber?: InputMaybe<Scalars['String']>;
};

/** Payment gateway client configuration key and value pair. */
export type GatewayConfigLine = {
  __typename?: 'GatewayConfigLine';
  /** Gateway config key. */
  field: Scalars['String'];
  /** Gateway config value for key. */
  value?: Maybe<Scalars['String']>;
};

/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCard = Node & ObjectWithMetadata & {
  __typename?: 'GiftCard';
  /** Added in Saleor 3.1. App which created the gift card. Requires one of the following permissions: AppPermission.MANAGE_APPS, AuthorizationFilters.OWNER. Note: this feature is in a preview state and can be subject to changes at later point. */
  app?: Maybe<App>;
  /** Added in Saleor 3.1. Slug of the channel where the gift card was bought. Note: this feature is in a preview state and can be subject to changes at later point. */
  boughtInChannel?: Maybe<Scalars['String']>;
  /** Gift card code. Can be fetched by a staff member with GiftcardPermissions.MANAGE_GIFT_CARD when gift card wasn't yet used and by the gift card owner. */
  code: Scalars['String'];
  created: Scalars['DateTime'];
  /** Added in Saleor 3.1. The user who bought or issued a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  createdBy?: Maybe<User>;
  /** Added in Saleor 3.1. Email address of the user who bought or issued gift card. Requires one of the following permissions: AccountPermissions.MANAGE_USERS, AuthorizationFilters.OWNER. Note: this feature is in a preview state and can be subject to changes at later point. */
  createdByEmail?: Maybe<Scalars['String']>;
  currentBalance?: Maybe<Money>;
  /** Code in format which allows displaying in a user interface. */
  displayCode: Scalars['String'];
  /**
   * End date of gift card.
   * @deprecated This field will be removed in Saleor 4.0. Use `expiryDate` field instead.
   */
  endDate?: Maybe<Scalars['DateTime']>;
  /** Added in Saleor 3.1. List of events associated with the gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  events: Array<GiftCardEvent>;
  expiryDate?: Maybe<Scalars['Date']>;
  id: Scalars['ID'];
  initialBalance?: Maybe<Money>;
  isActive: Scalars['Boolean'];
  /** Last 4 characters of gift card code. */
  last4CodeChars: Scalars['String'];
  lastUsedOn?: Maybe<Scalars['DateTime']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Added in Saleor 3.1. Related gift card product. Note: this feature is in a preview state and can be subject to changes at later point. */
  product?: Maybe<Product>;
  /**
   * Start date of gift card.
   * @deprecated This field will be removed in Saleor 4.0.
   */
  startDate?: Maybe<Scalars['DateTime']>;
  /** Added in Saleor 3.1. The gift card tag. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  tags: Array<GiftCardTag>;
  /** Added in Saleor 3.1. The customer who used a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  usedBy?: Maybe<User>;
  /** Added in Saleor 3.1. Email address of the customer who used a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  usedByEmail?: Maybe<Scalars['String']>;
  /**
   * The customer who bought a gift card.
   * @deprecated This field will be removed in Saleor 4.0. Use `createdBy` field instead.
   */
  user?: Maybe<User>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardEventsArgs = {
  filter?: InputMaybe<GiftCardEventFilterInput>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardMetafieldArgs = {
  key: Scalars['String'];
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes. */
export type GiftCardPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Activate a gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardActivate = {
  __typename?: 'GiftCardActivate';
  errors: Array<GiftCardError>;
  /** Activated gift card. */
  giftCard?: Maybe<GiftCard>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

/** Added in Saleor 3.1. Adds note to the gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardAddNote = {
  __typename?: 'GiftCardAddNote';
  errors: Array<GiftCardError>;
  /** Gift card note created. */
  event?: Maybe<GiftCardEvent>;
  /** Gift card with the note added. */
  giftCard?: Maybe<GiftCard>;
};

export type GiftCardAddNoteInput = {
  /** Note message. */
  message: Scalars['String'];
};

/** Added in Saleor 3.1. Activate gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardBulkActivate = {
  __typename?: 'GiftCardBulkActivate';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
};

/** Added in Saleor 3.1. Create gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardBulkCreate = {
  __typename?: 'GiftCardBulkCreate';
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
  /** List of created gift cards. */
  giftCards: Array<GiftCard>;
};

export type GiftCardBulkCreateInput = {
  /** Balance of the gift card. */
  balance: PriceInput;
  /** The number of cards to issue. */
  count: Scalars['Int'];
  /** The gift card expiry date. */
  expiryDate?: InputMaybe<Scalars['Date']>;
  /** Determine if gift card is active. */
  isActive: Scalars['Boolean'];
  /** The gift card tags. */
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** Added in Saleor 3.1. Deactivate gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardBulkDeactivate = {
  __typename?: 'GiftCardBulkDeactivate';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
};

/** Added in Saleor 3.1. Delete gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardBulkDelete = {
  __typename?: 'GiftCardBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<GiftCardError>;
};

export type GiftCardCountableConnection = {
  __typename?: 'GiftCardCountableConnection';
  edges: Array<GiftCardCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type GiftCardCountableEdge = {
  __typename?: 'GiftCardCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: GiftCard;
};

/** Creates a new gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardCreate = {
  __typename?: 'GiftCardCreate';
  errors: Array<GiftCardError>;
  giftCard?: Maybe<GiftCard>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

export type GiftCardCreateInput = {
  /** Added in Saleor 3.1. The gift card tags to add. Note: this feature is in a preview state and can be subject to changes at later point. */
  addTags?: InputMaybe<Array<Scalars['String']>>;
  /** Balance of the gift card. */
  balance: PriceInput;
  /** Added in Saleor 3.1. Slug of a channel from which the email should be sent. Note: this feature is in a preview state and can be subject to changes at later point. */
  channel?: InputMaybe<Scalars['String']>;
  /**
   * Code to use the gift card.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. The code is now auto generated.
   */
  code?: InputMaybe<Scalars['String']>;
  /**
   * End date of the gift card in ISO 8601 format.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `expiryDate` from `expirySettings` instead.
   */
  endDate?: InputMaybe<Scalars['Date']>;
  /** Added in Saleor 3.1. The gift card expiry date. Note: this feature is in a preview state and can be subject to changes at later point. */
  expiryDate?: InputMaybe<Scalars['Date']>;
  /** Added in Saleor 3.1. Determine if gift card is active. Note: this feature is in a preview state and can be subject to changes at later point. */
  isActive: Scalars['Boolean'];
  /** Added in Saleor 3.1. The gift card note from the staff member. Note: this feature is in a preview state and can be subject to changes at later point. */
  note?: InputMaybe<Scalars['String']>;
  /**
   * Start date of the gift card in ISO 8601 format.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  startDate?: InputMaybe<Scalars['Date']>;
  /** Email of the customer to whom gift card will be sent. */
  userEmail?: InputMaybe<Scalars['String']>;
};

export type GiftCardCreated = {
  __typename?: 'GiftCardCreated';
  /** Added in Saleor 3.2. Look up a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  giftCard?: Maybe<GiftCard>;
};

/** Deactivate a gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardDeactivate = {
  __typename?: 'GiftCardDeactivate';
  errors: Array<GiftCardError>;
  /** Deactivated gift card. */
  giftCard?: Maybe<GiftCard>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

/** Added in Saleor 3.1. Delete gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardDelete = {
  __typename?: 'GiftCardDelete';
  errors: Array<GiftCardError>;
  giftCard?: Maybe<GiftCard>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

export type GiftCardDeleted = {
  __typename?: 'GiftCardDeleted';
  /** Added in Saleor 3.2. Look up a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  giftCard?: Maybe<GiftCard>;
};

export type GiftCardError = {
  __typename?: 'GiftCardError';
  /** The error code. */
  code: GiftCardErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of tag values that cause the error. */
  tags?: Maybe<Array<Scalars['String']>>;
};

/** An enumeration. */
export enum GiftCardErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  ExpiredGiftCard = 'EXPIRED_GIFT_CARD',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

/** Added in Saleor 3.1. History log of the gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
export type GiftCardEvent = Node & {
  __typename?: 'GiftCardEvent';
  /** App that performed the action. Requires one of the following permissions: AppPermission.MANAGE_APPS, AuthorizationFilters.OWNER. */
  app?: Maybe<App>;
  /** The gift card balance. */
  balance?: Maybe<GiftCardEventBalance>;
  /** Date when event happened at in ISO 8601 format. */
  date?: Maybe<Scalars['DateTime']>;
  /** Email of the customer. */
  email?: Maybe<Scalars['String']>;
  /** The gift card expiry date. */
  expiryDate?: Maybe<Scalars['Date']>;
  id: Scalars['ID'];
  /** Content of the event. */
  message?: Maybe<Scalars['String']>;
  /** Previous gift card expiry date. */
  oldExpiryDate?: Maybe<Scalars['Date']>;
  /** The list of old gift card tags. */
  oldTags?: Maybe<Array<Scalars['String']>>;
  /** The order ID where gift card was used or bought. */
  orderId?: Maybe<Scalars['ID']>;
  /** User-friendly number of an order where gift card was used or bought. */
  orderNumber?: Maybe<Scalars['String']>;
  /** The list of gift card tags. */
  tags?: Maybe<Array<Scalars['String']>>;
  /** Gift card event type. */
  type?: Maybe<GiftCardEventsEnum>;
  /** User who performed the action. Requires one of the following permissions: AccountPermissions.MANAGE_USERS, AccountPermissions.MANAGE_STAFF, AuthorizationFilters.OWNER. */
  user?: Maybe<User>;
};

export type GiftCardEventBalance = {
  __typename?: 'GiftCardEventBalance';
  /** Current balance of the gift card. */
  currentBalance: Money;
  /** Initial balance of the gift card. */
  initialBalance?: Maybe<Money>;
  /** Previous current balance of the gift card. */
  oldCurrentBalance?: Maybe<Money>;
  /** Previous initial balance of the gift card. */
  oldInitialBalance?: Maybe<Money>;
};

export type GiftCardEventFilterInput = {
  orders?: InputMaybe<Array<Scalars['ID']>>;
  type?: InputMaybe<GiftCardEventsEnum>;
};

/** An enumeration. */
export enum GiftCardEventsEnum {
  Activated = 'ACTIVATED',
  BalanceReset = 'BALANCE_RESET',
  Bought = 'BOUGHT',
  Deactivated = 'DEACTIVATED',
  ExpiryDateUpdated = 'EXPIRY_DATE_UPDATED',
  Issued = 'ISSUED',
  NoteAdded = 'NOTE_ADDED',
  Resent = 'RESENT',
  SentToCustomer = 'SENT_TO_CUSTOMER',
  TagsUpdated = 'TAGS_UPDATED',
  Updated = 'UPDATED',
  UsedInOrder = 'USED_IN_ORDER'
}

export type GiftCardFilterInput = {
  code?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  currentBalance?: InputMaybe<PriceRangeInput>;
  initialBalance?: InputMaybe<PriceRangeInput>;
  isActive?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  products?: InputMaybe<Array<Scalars['ID']>>;
  tags?: InputMaybe<Array<Scalars['String']>>;
  used?: InputMaybe<Scalars['Boolean']>;
  usedBy?: InputMaybe<Array<Scalars['ID']>>;
};

/** Added in Saleor 3.1. Resend a gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardResend = {
  __typename?: 'GiftCardResend';
  errors: Array<GiftCardError>;
  /** Gift card which has been sent. */
  giftCard?: Maybe<GiftCard>;
};

export type GiftCardResendInput = {
  /** Slug of a channel from which the email should be sent. */
  channel: Scalars['String'];
  /** Email to which gift card should be send. */
  email?: InputMaybe<Scalars['String']>;
  /** ID of a gift card to resend. */
  id: Scalars['ID'];
};

/** Gift card related settings from site settings. */
export type GiftCardSettings = {
  __typename?: 'GiftCardSettings';
  /** The gift card expiry period settings. */
  expiryPeriod?: Maybe<TimePeriod>;
  /** The gift card expiry type settings. */
  expiryType: GiftCardSettingsExpiryTypeEnum;
};

export type GiftCardSettingsError = {
  __typename?: 'GiftCardSettingsError';
  /** The error code. */
  code: GiftCardSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum GiftCardSettingsErrorCode {
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  Required = 'REQUIRED'
}

/** An enumeration. */
export enum GiftCardSettingsExpiryTypeEnum {
  ExpiryPeriod = 'EXPIRY_PERIOD',
  NeverExpire = 'NEVER_EXPIRE'
}

/** Update gift card settings. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardSettingsUpdate = {
  __typename?: 'GiftCardSettingsUpdate';
  errors: Array<GiftCardSettingsError>;
  /** Gift card settings. */
  giftCardSettings?: Maybe<GiftCardSettings>;
};

export type GiftCardSettingsUpdateInput = {
  /** Defines gift card expiry period. */
  expiryPeriod?: InputMaybe<TimePeriodInputType>;
  /** Defines gift card default expiry settings. */
  expiryType?: InputMaybe<GiftCardSettingsExpiryTypeEnum>;
};

export enum GiftCardSortField {
  /** Sort orders by current balance. */
  CurrentBalance = 'CURRENT_BALANCE',
  /** Sort orders by product. */
  Product = 'PRODUCT',
  /** Sort orders by used by. */
  UsedBy = 'USED_BY'
}

export type GiftCardSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort gift cards by the selected field. */
  field: GiftCardSortField;
};

export type GiftCardStatusChanged = {
  __typename?: 'GiftCardStatusChanged';
  /** Added in Saleor 3.2. Look up a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  giftCard?: Maybe<GiftCard>;
};

/** Added in Saleor 3.1. The gift card tag. Note: this feature is in a preview state and can be subject to changes at later point. */
export type GiftCardTag = Node & {
  __typename?: 'GiftCardTag';
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type GiftCardTagCountableConnection = {
  __typename?: 'GiftCardTagCountableConnection';
  edges: Array<GiftCardTagCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type GiftCardTagCountableEdge = {
  __typename?: 'GiftCardTagCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: GiftCardTag;
};

export type GiftCardTagFilterInput = {
  search?: InputMaybe<Scalars['String']>;
};

/** Update a gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
export type GiftCardUpdate = {
  __typename?: 'GiftCardUpdate';
  errors: Array<GiftCardError>;
  giftCard?: Maybe<GiftCard>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  giftCardErrors: Array<GiftCardError>;
};

export type GiftCardUpdateInput = {
  /** Added in Saleor 3.1. The gift card tags to add. Note: this feature is in a preview state and can be subject to changes at later point. */
  addTags?: InputMaybe<Array<Scalars['String']>>;
  /** Added in Saleor 3.1. The gift card balance amount. Note: this feature is in a preview state and can be subject to changes at later point. */
  balanceAmount?: InputMaybe<Scalars['PositiveDecimal']>;
  /**
   * End date of the gift card in ISO 8601 format.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `expiryDate` from `expirySettings` instead.
   */
  endDate?: InputMaybe<Scalars['Date']>;
  /** Added in Saleor 3.1. The gift card expiry date. Note: this feature is in a preview state and can be subject to changes at later point. */
  expiryDate?: InputMaybe<Scalars['Date']>;
  /** Added in Saleor 3.1. The gift card tags to remove. Note: this feature is in a preview state and can be subject to changes at later point. */
  removeTags?: InputMaybe<Array<Scalars['String']>>;
  /**
   * Start date of the gift card in ISO 8601 format.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  startDate?: InputMaybe<Scalars['Date']>;
};

export type GiftCardUpdated = {
  __typename?: 'GiftCardUpdated';
  /** Added in Saleor 3.2. Look up a gift card. Note: this feature is in a preview state and can be subject to changes at later point. */
  giftCard?: Maybe<GiftCard>;
};

/** Represents permission group data. */
export type Group = Node & {
  __typename?: 'Group';
  id: Scalars['ID'];
  name: Scalars['String'];
  /** List of group permissions */
  permissions?: Maybe<Array<Permission>>;
  /** True, if the currently authenticated user has rights to manage a group. */
  userCanManage: Scalars['Boolean'];
  /** List of group users Requires one of the following permissions: MANAGE_STAFF. */
  users?: Maybe<Array<User>>;
};

export type GroupCountableConnection = {
  __typename?: 'GroupCountableConnection';
  edges: Array<GroupCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type GroupCountableEdge = {
  __typename?: 'GroupCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Group;
};

/** Represents an image. */
export type Image = {
  __typename?: 'Image';
  /** Alt text for an image. */
  alt?: Maybe<Scalars['String']>;
  /** The URL of the image. */
  url: Scalars['String'];
};

export type IntRangeInput = {
  /** Value greater than or equal to. */
  gte?: InputMaybe<Scalars['Int']>;
  /** Value less than or equal to. */
  lte?: InputMaybe<Scalars['Int']>;
};

/** Represents an Invoice. */
export type Invoice = Job & Node & ObjectWithMetadata & {
  __typename?: 'Invoice';
  createdAt: Scalars['DateTime'];
  externalUrl?: Maybe<Scalars['String']>;
  /** The ID of the object. */
  id: Scalars['ID'];
  message?: Maybe<Scalars['String']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  number?: Maybe<Scalars['String']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Job status. */
  status: JobStatusEnum;
  updatedAt: Scalars['DateTime'];
  /** URL to download an invoice. */
  url?: Maybe<Scalars['String']>;
};


/** Represents an Invoice. */
export type InvoiceMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an Invoice. */
export type InvoiceMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an Invoice. */
export type InvoicePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an Invoice. */
export type InvoicePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Creates a ready to send invoice. Requires one of the following permissions: MANAGE_ORDERS. */
export type InvoiceCreate = {
  __typename?: 'InvoiceCreate';
  errors: Array<InvoiceError>;
  invoice?: Maybe<Invoice>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type InvoiceCreateInput = {
  /** Invoice number. */
  number: Scalars['String'];
  /** URL of an invoice to download. */
  url: Scalars['String'];
};

/** Deletes an invoice. Requires one of the following permissions: MANAGE_ORDERS. */
export type InvoiceDelete = {
  __typename?: 'InvoiceDelete';
  errors: Array<InvoiceError>;
  invoice?: Maybe<Invoice>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type InvoiceDeleted = {
  __typename?: 'InvoiceDeleted';
  /** Added in Saleor 3.2. Look up an Invoice. Note: this feature is in a preview state and can be subject to changes at later point. */
  invoice?: Maybe<Invoice>;
};

export type InvoiceError = {
  __typename?: 'InvoiceError';
  /** The error code. */
  code: InvoiceErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum InvoiceErrorCode {
  EmailNotSet = 'EMAIL_NOT_SET',
  InvalidStatus = 'INVALID_STATUS',
  NotFound = 'NOT_FOUND',
  NotReady = 'NOT_READY',
  NoInvoicePlugin = 'NO_INVOICE_PLUGIN',
  NumberNotSet = 'NUMBER_NOT_SET',
  Required = 'REQUIRED',
  UrlNotSet = 'URL_NOT_SET'
}

/** Request an invoice for the order using plugin. Requires one of the following permissions: MANAGE_ORDERS. */
export type InvoiceRequest = {
  __typename?: 'InvoiceRequest';
  errors: Array<InvoiceError>;
  invoice?: Maybe<Invoice>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
  /** Order related to an invoice. */
  order?: Maybe<Order>;
};

/** Requests deletion of an invoice. Requires one of the following permissions: MANAGE_ORDERS. */
export type InvoiceRequestDelete = {
  __typename?: 'InvoiceRequestDelete';
  errors: Array<InvoiceError>;
  invoice?: Maybe<Invoice>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type InvoiceRequested = {
  __typename?: 'InvoiceRequested';
  /** Added in Saleor 3.2. Look up an Invoice. Note: this feature is in a preview state and can be subject to changes at later point. */
  invoice?: Maybe<Invoice>;
};

/** Send an invoice notification to the customer. Requires one of the following permissions: MANAGE_ORDERS. */
export type InvoiceSendNotification = {
  __typename?: 'InvoiceSendNotification';
  errors: Array<InvoiceError>;
  invoice?: Maybe<Invoice>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type InvoiceSent = {
  __typename?: 'InvoiceSent';
  /** Added in Saleor 3.2. Look up an Invoice. Note: this feature is in a preview state and can be subject to changes at later point. */
  invoice?: Maybe<Invoice>;
};

/** Updates an invoice. Requires one of the following permissions: MANAGE_ORDERS. */
export type InvoiceUpdate = {
  __typename?: 'InvoiceUpdate';
  errors: Array<InvoiceError>;
  invoice?: Maybe<Invoice>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  invoiceErrors: Array<InvoiceError>;
};

export type Job = {
  /** Created date time of job in ISO 8601 format. */
  createdAt: Scalars['DateTime'];
  /** Job message. */
  message?: Maybe<Scalars['String']>;
  /** Job status. */
  status: JobStatusEnum;
  /** Date time of job last update in ISO 8601 format. */
  updatedAt: Scalars['DateTime'];
};

/** An enumeration. */
export enum JobStatusEnum {
  Deleted = 'DELETED',
  Failed = 'FAILED',
  Pending = 'PENDING',
  Success = 'SUCCESS'
}

/** An enumeration. */
export enum LanguageCodeEnum {
  Af = 'AF',
  AfNa = 'AF_NA',
  AfZa = 'AF_ZA',
  Agq = 'AGQ',
  AgqCm = 'AGQ_CM',
  Ak = 'AK',
  AkGh = 'AK_GH',
  Am = 'AM',
  AmEt = 'AM_ET',
  Ar = 'AR',
  ArAe = 'AR_AE',
  ArBh = 'AR_BH',
  ArDj = 'AR_DJ',
  ArDz = 'AR_DZ',
  ArEg = 'AR_EG',
  ArEh = 'AR_EH',
  ArEr = 'AR_ER',
  ArIl = 'AR_IL',
  ArIq = 'AR_IQ',
  ArJo = 'AR_JO',
  ArKm = 'AR_KM',
  ArKw = 'AR_KW',
  ArLb = 'AR_LB',
  ArLy = 'AR_LY',
  ArMa = 'AR_MA',
  ArMr = 'AR_MR',
  ArOm = 'AR_OM',
  ArPs = 'AR_PS',
  ArQa = 'AR_QA',
  ArSa = 'AR_SA',
  ArSd = 'AR_SD',
  ArSo = 'AR_SO',
  ArSs = 'AR_SS',
  ArSy = 'AR_SY',
  ArTd = 'AR_TD',
  ArTn = 'AR_TN',
  ArYe = 'AR_YE',
  As = 'AS',
  Asa = 'ASA',
  AsaTz = 'ASA_TZ',
  Ast = 'AST',
  AstEs = 'AST_ES',
  AsIn = 'AS_IN',
  Az = 'AZ',
  AzCyrl = 'AZ_CYRL',
  AzCyrlAz = 'AZ_CYRL_AZ',
  AzLatn = 'AZ_LATN',
  AzLatnAz = 'AZ_LATN_AZ',
  Bas = 'BAS',
  BasCm = 'BAS_CM',
  Be = 'BE',
  Bem = 'BEM',
  BemZm = 'BEM_ZM',
  Bez = 'BEZ',
  BezTz = 'BEZ_TZ',
  BeBy = 'BE_BY',
  Bg = 'BG',
  BgBg = 'BG_BG',
  Bm = 'BM',
  BmMl = 'BM_ML',
  Bn = 'BN',
  BnBd = 'BN_BD',
  BnIn = 'BN_IN',
  Bo = 'BO',
  BoCn = 'BO_CN',
  BoIn = 'BO_IN',
  Br = 'BR',
  Brx = 'BRX',
  BrxIn = 'BRX_IN',
  BrFr = 'BR_FR',
  Bs = 'BS',
  BsCyrl = 'BS_CYRL',
  BsCyrlBa = 'BS_CYRL_BA',
  BsLatn = 'BS_LATN',
  BsLatnBa = 'BS_LATN_BA',
  Ca = 'CA',
  CaAd = 'CA_AD',
  CaEs = 'CA_ES',
  CaEsValencia = 'CA_ES_VALENCIA',
  CaFr = 'CA_FR',
  CaIt = 'CA_IT',
  Ccp = 'CCP',
  CcpBd = 'CCP_BD',
  CcpIn = 'CCP_IN',
  Ce = 'CE',
  Ceb = 'CEB',
  CebPh = 'CEB_PH',
  CeRu = 'CE_RU',
  Cgg = 'CGG',
  CggUg = 'CGG_UG',
  Chr = 'CHR',
  ChrUs = 'CHR_US',
  Ckb = 'CKB',
  CkbIq = 'CKB_IQ',
  CkbIr = 'CKB_IR',
  Cs = 'CS',
  CsCz = 'CS_CZ',
  Cu = 'CU',
  CuRu = 'CU_RU',
  Cy = 'CY',
  CyGb = 'CY_GB',
  Da = 'DA',
  Dav = 'DAV',
  DavKe = 'DAV_KE',
  DaDk = 'DA_DK',
  DaGl = 'DA_GL',
  De = 'DE',
  DeAt = 'DE_AT',
  DeBe = 'DE_BE',
  DeCh = 'DE_CH',
  DeDe = 'DE_DE',
  DeIt = 'DE_IT',
  DeLi = 'DE_LI',
  DeLu = 'DE_LU',
  Dje = 'DJE',
  DjeNe = 'DJE_NE',
  Dsb = 'DSB',
  DsbDe = 'DSB_DE',
  Dua = 'DUA',
  DuaCm = 'DUA_CM',
  Dyo = 'DYO',
  DyoSn = 'DYO_SN',
  Dz = 'DZ',
  DzBt = 'DZ_BT',
  Ebu = 'EBU',
  EbuKe = 'EBU_KE',
  Ee = 'EE',
  EeGh = 'EE_GH',
  EeTg = 'EE_TG',
  El = 'EL',
  ElCy = 'EL_CY',
  ElGr = 'EL_GR',
  En = 'EN',
  EnAe = 'EN_AE',
  EnAg = 'EN_AG',
  EnAi = 'EN_AI',
  EnAs = 'EN_AS',
  EnAt = 'EN_AT',
  EnAu = 'EN_AU',
  EnBb = 'EN_BB',
  EnBe = 'EN_BE',
  EnBi = 'EN_BI',
  EnBm = 'EN_BM',
  EnBs = 'EN_BS',
  EnBw = 'EN_BW',
  EnBz = 'EN_BZ',
  EnCa = 'EN_CA',
  EnCc = 'EN_CC',
  EnCh = 'EN_CH',
  EnCk = 'EN_CK',
  EnCm = 'EN_CM',
  EnCx = 'EN_CX',
  EnCy = 'EN_CY',
  EnDe = 'EN_DE',
  EnDg = 'EN_DG',
  EnDk = 'EN_DK',
  EnDm = 'EN_DM',
  EnEr = 'EN_ER',
  EnFi = 'EN_FI',
  EnFj = 'EN_FJ',
  EnFk = 'EN_FK',
  EnFm = 'EN_FM',
  EnGb = 'EN_GB',
  EnGd = 'EN_GD',
  EnGg = 'EN_GG',
  EnGh = 'EN_GH',
  EnGi = 'EN_GI',
  EnGm = 'EN_GM',
  EnGu = 'EN_GU',
  EnGy = 'EN_GY',
  EnHk = 'EN_HK',
  EnIe = 'EN_IE',
  EnIl = 'EN_IL',
  EnIm = 'EN_IM',
  EnIn = 'EN_IN',
  EnIo = 'EN_IO',
  EnJe = 'EN_JE',
  EnJm = 'EN_JM',
  EnKe = 'EN_KE',
  EnKi = 'EN_KI',
  EnKn = 'EN_KN',
  EnKy = 'EN_KY',
  EnLc = 'EN_LC',
  EnLr = 'EN_LR',
  EnLs = 'EN_LS',
  EnMg = 'EN_MG',
  EnMh = 'EN_MH',
  EnMo = 'EN_MO',
  EnMp = 'EN_MP',
  EnMs = 'EN_MS',
  EnMt = 'EN_MT',
  EnMu = 'EN_MU',
  EnMw = 'EN_MW',
  EnMy = 'EN_MY',
  EnNa = 'EN_NA',
  EnNf = 'EN_NF',
  EnNg = 'EN_NG',
  EnNl = 'EN_NL',
  EnNr = 'EN_NR',
  EnNu = 'EN_NU',
  EnNz = 'EN_NZ',
  EnPg = 'EN_PG',
  EnPh = 'EN_PH',
  EnPk = 'EN_PK',
  EnPn = 'EN_PN',
  EnPr = 'EN_PR',
  EnPw = 'EN_PW',
  EnRw = 'EN_RW',
  EnSb = 'EN_SB',
  EnSc = 'EN_SC',
  EnSd = 'EN_SD',
  EnSe = 'EN_SE',
  EnSg = 'EN_SG',
  EnSh = 'EN_SH',
  EnSi = 'EN_SI',
  EnSl = 'EN_SL',
  EnSs = 'EN_SS',
  EnSx = 'EN_SX',
  EnSz = 'EN_SZ',
  EnTc = 'EN_TC',
  EnTk = 'EN_TK',
  EnTo = 'EN_TO',
  EnTt = 'EN_TT',
  EnTv = 'EN_TV',
  EnTz = 'EN_TZ',
  EnUg = 'EN_UG',
  EnUm = 'EN_UM',
  EnUs = 'EN_US',
  EnVc = 'EN_VC',
  EnVg = 'EN_VG',
  EnVi = 'EN_VI',
  EnVu = 'EN_VU',
  EnWs = 'EN_WS',
  EnZa = 'EN_ZA',
  EnZm = 'EN_ZM',
  EnZw = 'EN_ZW',
  Eo = 'EO',
  Es = 'ES',
  EsAr = 'ES_AR',
  EsBo = 'ES_BO',
  EsBr = 'ES_BR',
  EsBz = 'ES_BZ',
  EsCl = 'ES_CL',
  EsCo = 'ES_CO',
  EsCr = 'ES_CR',
  EsCu = 'ES_CU',
  EsDo = 'ES_DO',
  EsEa = 'ES_EA',
  EsEc = 'ES_EC',
  EsEs = 'ES_ES',
  EsGq = 'ES_GQ',
  EsGt = 'ES_GT',
  EsHn = 'ES_HN',
  EsIc = 'ES_IC',
  EsMx = 'ES_MX',
  EsNi = 'ES_NI',
  EsPa = 'ES_PA',
  EsPe = 'ES_PE',
  EsPh = 'ES_PH',
  EsPr = 'ES_PR',
  EsPy = 'ES_PY',
  EsSv = 'ES_SV',
  EsUs = 'ES_US',
  EsUy = 'ES_UY',
  EsVe = 'ES_VE',
  Et = 'ET',
  EtEe = 'ET_EE',
  Eu = 'EU',
  EuEs = 'EU_ES',
  Ewo = 'EWO',
  EwoCm = 'EWO_CM',
  Fa = 'FA',
  FaAf = 'FA_AF',
  FaIr = 'FA_IR',
  Ff = 'FF',
  FfAdlm = 'FF_ADLM',
  FfAdlmBf = 'FF_ADLM_BF',
  FfAdlmCm = 'FF_ADLM_CM',
  FfAdlmGh = 'FF_ADLM_GH',
  FfAdlmGm = 'FF_ADLM_GM',
  FfAdlmGn = 'FF_ADLM_GN',
  FfAdlmGw = 'FF_ADLM_GW',
  FfAdlmLr = 'FF_ADLM_LR',
  FfAdlmMr = 'FF_ADLM_MR',
  FfAdlmNe = 'FF_ADLM_NE',
  FfAdlmNg = 'FF_ADLM_NG',
  FfAdlmSl = 'FF_ADLM_SL',
  FfAdlmSn = 'FF_ADLM_SN',
  FfLatn = 'FF_LATN',
  FfLatnBf = 'FF_LATN_BF',
  FfLatnCm = 'FF_LATN_CM',
  FfLatnGh = 'FF_LATN_GH',
  FfLatnGm = 'FF_LATN_GM',
  FfLatnGn = 'FF_LATN_GN',
  FfLatnGw = 'FF_LATN_GW',
  FfLatnLr = 'FF_LATN_LR',
  FfLatnMr = 'FF_LATN_MR',
  FfLatnNe = 'FF_LATN_NE',
  FfLatnNg = 'FF_LATN_NG',
  FfLatnSl = 'FF_LATN_SL',
  FfLatnSn = 'FF_LATN_SN',
  Fi = 'FI',
  Fil = 'FIL',
  FilPh = 'FIL_PH',
  FiFi = 'FI_FI',
  Fo = 'FO',
  FoDk = 'FO_DK',
  FoFo = 'FO_FO',
  Fr = 'FR',
  FrBe = 'FR_BE',
  FrBf = 'FR_BF',
  FrBi = 'FR_BI',
  FrBj = 'FR_BJ',
  FrBl = 'FR_BL',
  FrCa = 'FR_CA',
  FrCd = 'FR_CD',
  FrCf = 'FR_CF',
  FrCg = 'FR_CG',
  FrCh = 'FR_CH',
  FrCi = 'FR_CI',
  FrCm = 'FR_CM',
  FrDj = 'FR_DJ',
  FrDz = 'FR_DZ',
  FrFr = 'FR_FR',
  FrGa = 'FR_GA',
  FrGf = 'FR_GF',
  FrGn = 'FR_GN',
  FrGp = 'FR_GP',
  FrGq = 'FR_GQ',
  FrHt = 'FR_HT',
  FrKm = 'FR_KM',
  FrLu = 'FR_LU',
  FrMa = 'FR_MA',
  FrMc = 'FR_MC',
  FrMf = 'FR_MF',
  FrMg = 'FR_MG',
  FrMl = 'FR_ML',
  FrMq = 'FR_MQ',
  FrMr = 'FR_MR',
  FrMu = 'FR_MU',
  FrNc = 'FR_NC',
  FrNe = 'FR_NE',
  FrPf = 'FR_PF',
  FrPm = 'FR_PM',
  FrRe = 'FR_RE',
  FrRw = 'FR_RW',
  FrSc = 'FR_SC',
  FrSn = 'FR_SN',
  FrSy = 'FR_SY',
  FrTd = 'FR_TD',
  FrTg = 'FR_TG',
  FrTn = 'FR_TN',
  FrVu = 'FR_VU',
  FrWf = 'FR_WF',
  FrYt = 'FR_YT',
  Fur = 'FUR',
  FurIt = 'FUR_IT',
  Fy = 'FY',
  FyNl = 'FY_NL',
  Ga = 'GA',
  GaGb = 'GA_GB',
  GaIe = 'GA_IE',
  Gd = 'GD',
  GdGb = 'GD_GB',
  Gl = 'GL',
  GlEs = 'GL_ES',
  Gsw = 'GSW',
  GswCh = 'GSW_CH',
  GswFr = 'GSW_FR',
  GswLi = 'GSW_LI',
  Gu = 'GU',
  Guz = 'GUZ',
  GuzKe = 'GUZ_KE',
  GuIn = 'GU_IN',
  Gv = 'GV',
  GvIm = 'GV_IM',
  Ha = 'HA',
  Haw = 'HAW',
  HawUs = 'HAW_US',
  HaGh = 'HA_GH',
  HaNe = 'HA_NE',
  HaNg = 'HA_NG',
  He = 'HE',
  HeIl = 'HE_IL',
  Hi = 'HI',
  HiIn = 'HI_IN',
  Hr = 'HR',
  HrBa = 'HR_BA',
  HrHr = 'HR_HR',
  Hsb = 'HSB',
  HsbDe = 'HSB_DE',
  Hu = 'HU',
  HuHu = 'HU_HU',
  Hy = 'HY',
  HyAm = 'HY_AM',
  Ia = 'IA',
  Id = 'ID',
  IdId = 'ID_ID',
  Ig = 'IG',
  IgNg = 'IG_NG',
  Ii = 'II',
  IiCn = 'II_CN',
  Is = 'IS',
  IsIs = 'IS_IS',
  It = 'IT',
  ItCh = 'IT_CH',
  ItIt = 'IT_IT',
  ItSm = 'IT_SM',
  ItVa = 'IT_VA',
  Ja = 'JA',
  JaJp = 'JA_JP',
  Jgo = 'JGO',
  JgoCm = 'JGO_CM',
  Jmc = 'JMC',
  JmcTz = 'JMC_TZ',
  Jv = 'JV',
  JvId = 'JV_ID',
  Ka = 'KA',
  Kab = 'KAB',
  KabDz = 'KAB_DZ',
  Kam = 'KAM',
  KamKe = 'KAM_KE',
  KaGe = 'KA_GE',
  Kde = 'KDE',
  KdeTz = 'KDE_TZ',
  Kea = 'KEA',
  KeaCv = 'KEA_CV',
  Khq = 'KHQ',
  KhqMl = 'KHQ_ML',
  Ki = 'KI',
  KiKe = 'KI_KE',
  Kk = 'KK',
  Kkj = 'KKJ',
  KkjCm = 'KKJ_CM',
  KkKz = 'KK_KZ',
  Kl = 'KL',
  Kln = 'KLN',
  KlnKe = 'KLN_KE',
  KlGl = 'KL_GL',
  Km = 'KM',
  KmKh = 'KM_KH',
  Kn = 'KN',
  KnIn = 'KN_IN',
  Ko = 'KO',
  Kok = 'KOK',
  KokIn = 'KOK_IN',
  KoKp = 'KO_KP',
  KoKr = 'KO_KR',
  Ks = 'KS',
  Ksb = 'KSB',
  KsbTz = 'KSB_TZ',
  Ksf = 'KSF',
  KsfCm = 'KSF_CM',
  Ksh = 'KSH',
  KshDe = 'KSH_DE',
  KsArab = 'KS_ARAB',
  KsArabIn = 'KS_ARAB_IN',
  Ku = 'KU',
  KuTr = 'KU_TR',
  Kw = 'KW',
  KwGb = 'KW_GB',
  Ky = 'KY',
  KyKg = 'KY_KG',
  Lag = 'LAG',
  LagTz = 'LAG_TZ',
  Lb = 'LB',
  LbLu = 'LB_LU',
  Lg = 'LG',
  LgUg = 'LG_UG',
  Lkt = 'LKT',
  LktUs = 'LKT_US',
  Ln = 'LN',
  LnAo = 'LN_AO',
  LnCd = 'LN_CD',
  LnCf = 'LN_CF',
  LnCg = 'LN_CG',
  Lo = 'LO',
  LoLa = 'LO_LA',
  Lrc = 'LRC',
  LrcIq = 'LRC_IQ',
  LrcIr = 'LRC_IR',
  Lt = 'LT',
  LtLt = 'LT_LT',
  Lu = 'LU',
  Luo = 'LUO',
  LuoKe = 'LUO_KE',
  Luy = 'LUY',
  LuyKe = 'LUY_KE',
  LuCd = 'LU_CD',
  Lv = 'LV',
  LvLv = 'LV_LV',
  Mai = 'MAI',
  MaiIn = 'MAI_IN',
  Mas = 'MAS',
  MasKe = 'MAS_KE',
  MasTz = 'MAS_TZ',
  Mer = 'MER',
  MerKe = 'MER_KE',
  Mfe = 'MFE',
  MfeMu = 'MFE_MU',
  Mg = 'MG',
  Mgh = 'MGH',
  MghMz = 'MGH_MZ',
  Mgo = 'MGO',
  MgoCm = 'MGO_CM',
  MgMg = 'MG_MG',
  Mi = 'MI',
  MiNz = 'MI_NZ',
  Mk = 'MK',
  MkMk = 'MK_MK',
  Ml = 'ML',
  MlIn = 'ML_IN',
  Mn = 'MN',
  Mni = 'MNI',
  MniBeng = 'MNI_BENG',
  MniBengIn = 'MNI_BENG_IN',
  MnMn = 'MN_MN',
  Mr = 'MR',
  MrIn = 'MR_IN',
  Ms = 'MS',
  MsBn = 'MS_BN',
  MsId = 'MS_ID',
  MsMy = 'MS_MY',
  MsSg = 'MS_SG',
  Mt = 'MT',
  MtMt = 'MT_MT',
  Mua = 'MUA',
  MuaCm = 'MUA_CM',
  My = 'MY',
  MyMm = 'MY_MM',
  Mzn = 'MZN',
  MznIr = 'MZN_IR',
  Naq = 'NAQ',
  NaqNa = 'NAQ_NA',
  Nb = 'NB',
  NbNo = 'NB_NO',
  NbSj = 'NB_SJ',
  Nd = 'ND',
  Nds = 'NDS',
  NdsDe = 'NDS_DE',
  NdsNl = 'NDS_NL',
  NdZw = 'ND_ZW',
  Ne = 'NE',
  NeIn = 'NE_IN',
  NeNp = 'NE_NP',
  Nl = 'NL',
  NlAw = 'NL_AW',
  NlBe = 'NL_BE',
  NlBq = 'NL_BQ',
  NlCw = 'NL_CW',
  NlNl = 'NL_NL',
  NlSr = 'NL_SR',
  NlSx = 'NL_SX',
  Nmg = 'NMG',
  NmgCm = 'NMG_CM',
  Nn = 'NN',
  Nnh = 'NNH',
  NnhCm = 'NNH_CM',
  NnNo = 'NN_NO',
  Nus = 'NUS',
  NusSs = 'NUS_SS',
  Nyn = 'NYN',
  NynUg = 'NYN_UG',
  Om = 'OM',
  OmEt = 'OM_ET',
  OmKe = 'OM_KE',
  Or = 'OR',
  OrIn = 'OR_IN',
  Os = 'OS',
  OsGe = 'OS_GE',
  OsRu = 'OS_RU',
  Pa = 'PA',
  PaArab = 'PA_ARAB',
  PaArabPk = 'PA_ARAB_PK',
  PaGuru = 'PA_GURU',
  PaGuruIn = 'PA_GURU_IN',
  Pcm = 'PCM',
  PcmNg = 'PCM_NG',
  Pl = 'PL',
  PlPl = 'PL_PL',
  Prg = 'PRG',
  Ps = 'PS',
  PsAf = 'PS_AF',
  PsPk = 'PS_PK',
  Pt = 'PT',
  PtAo = 'PT_AO',
  PtBr = 'PT_BR',
  PtCh = 'PT_CH',
  PtCv = 'PT_CV',
  PtGq = 'PT_GQ',
  PtGw = 'PT_GW',
  PtLu = 'PT_LU',
  PtMo = 'PT_MO',
  PtMz = 'PT_MZ',
  PtPt = 'PT_PT',
  PtSt = 'PT_ST',
  PtTl = 'PT_TL',
  Qu = 'QU',
  QuBo = 'QU_BO',
  QuEc = 'QU_EC',
  QuPe = 'QU_PE',
  Rm = 'RM',
  RmCh = 'RM_CH',
  Rn = 'RN',
  RnBi = 'RN_BI',
  Ro = 'RO',
  Rof = 'ROF',
  RofTz = 'ROF_TZ',
  RoMd = 'RO_MD',
  RoRo = 'RO_RO',
  Ru = 'RU',
  RuBy = 'RU_BY',
  RuKg = 'RU_KG',
  RuKz = 'RU_KZ',
  RuMd = 'RU_MD',
  RuRu = 'RU_RU',
  RuUa = 'RU_UA',
  Rw = 'RW',
  Rwk = 'RWK',
  RwkTz = 'RWK_TZ',
  RwRw = 'RW_RW',
  Sah = 'SAH',
  SahRu = 'SAH_RU',
  Saq = 'SAQ',
  SaqKe = 'SAQ_KE',
  Sat = 'SAT',
  SatOlck = 'SAT_OLCK',
  SatOlckIn = 'SAT_OLCK_IN',
  Sbp = 'SBP',
  SbpTz = 'SBP_TZ',
  Sd = 'SD',
  SdArab = 'SD_ARAB',
  SdArabPk = 'SD_ARAB_PK',
  SdDeva = 'SD_DEVA',
  SdDevaIn = 'SD_DEVA_IN',
  Se = 'SE',
  Seh = 'SEH',
  SehMz = 'SEH_MZ',
  Ses = 'SES',
  SesMl = 'SES_ML',
  SeFi = 'SE_FI',
  SeNo = 'SE_NO',
  SeSe = 'SE_SE',
  Sg = 'SG',
  SgCf = 'SG_CF',
  Shi = 'SHI',
  ShiLatn = 'SHI_LATN',
  ShiLatnMa = 'SHI_LATN_MA',
  ShiTfng = 'SHI_TFNG',
  ShiTfngMa = 'SHI_TFNG_MA',
  Si = 'SI',
  SiLk = 'SI_LK',
  Sk = 'SK',
  SkSk = 'SK_SK',
  Sl = 'SL',
  SlSi = 'SL_SI',
  Smn = 'SMN',
  SmnFi = 'SMN_FI',
  Sn = 'SN',
  SnZw = 'SN_ZW',
  So = 'SO',
  SoDj = 'SO_DJ',
  SoEt = 'SO_ET',
  SoKe = 'SO_KE',
  SoSo = 'SO_SO',
  Sq = 'SQ',
  SqAl = 'SQ_AL',
  SqMk = 'SQ_MK',
  SqXk = 'SQ_XK',
  Sr = 'SR',
  SrCyrl = 'SR_CYRL',
  SrCyrlBa = 'SR_CYRL_BA',
  SrCyrlMe = 'SR_CYRL_ME',
  SrCyrlRs = 'SR_CYRL_RS',
  SrCyrlXk = 'SR_CYRL_XK',
  SrLatn = 'SR_LATN',
  SrLatnBa = 'SR_LATN_BA',
  SrLatnMe = 'SR_LATN_ME',
  SrLatnRs = 'SR_LATN_RS',
  SrLatnXk = 'SR_LATN_XK',
  Su = 'SU',
  SuLatn = 'SU_LATN',
  SuLatnId = 'SU_LATN_ID',
  Sv = 'SV',
  SvAx = 'SV_AX',
  SvFi = 'SV_FI',
  SvSe = 'SV_SE',
  Sw = 'SW',
  SwCd = 'SW_CD',
  SwKe = 'SW_KE',
  SwTz = 'SW_TZ',
  SwUg = 'SW_UG',
  Ta = 'TA',
  TaIn = 'TA_IN',
  TaLk = 'TA_LK',
  TaMy = 'TA_MY',
  TaSg = 'TA_SG',
  Te = 'TE',
  Teo = 'TEO',
  TeoKe = 'TEO_KE',
  TeoUg = 'TEO_UG',
  TeIn = 'TE_IN',
  Tg = 'TG',
  TgTj = 'TG_TJ',
  Th = 'TH',
  ThTh = 'TH_TH',
  Ti = 'TI',
  TiEr = 'TI_ER',
  TiEt = 'TI_ET',
  Tk = 'TK',
  TkTm = 'TK_TM',
  To = 'TO',
  ToTo = 'TO_TO',
  Tr = 'TR',
  TrCy = 'TR_CY',
  TrTr = 'TR_TR',
  Tt = 'TT',
  TtRu = 'TT_RU',
  Twq = 'TWQ',
  TwqNe = 'TWQ_NE',
  Tzm = 'TZM',
  TzmMa = 'TZM_MA',
  Ug = 'UG',
  UgCn = 'UG_CN',
  Uk = 'UK',
  UkUa = 'UK_UA',
  Ur = 'UR',
  UrIn = 'UR_IN',
  UrPk = 'UR_PK',
  Uz = 'UZ',
  UzArab = 'UZ_ARAB',
  UzArabAf = 'UZ_ARAB_AF',
  UzCyrl = 'UZ_CYRL',
  UzCyrlUz = 'UZ_CYRL_UZ',
  UzLatn = 'UZ_LATN',
  UzLatnUz = 'UZ_LATN_UZ',
  Vai = 'VAI',
  VaiLatn = 'VAI_LATN',
  VaiLatnLr = 'VAI_LATN_LR',
  VaiVaii = 'VAI_VAII',
  VaiVaiiLr = 'VAI_VAII_LR',
  Vi = 'VI',
  ViVn = 'VI_VN',
  Vo = 'VO',
  Vun = 'VUN',
  VunTz = 'VUN_TZ',
  Wae = 'WAE',
  WaeCh = 'WAE_CH',
  Wo = 'WO',
  WoSn = 'WO_SN',
  Xh = 'XH',
  XhZa = 'XH_ZA',
  Xog = 'XOG',
  XogUg = 'XOG_UG',
  Yav = 'YAV',
  YavCm = 'YAV_CM',
  Yi = 'YI',
  Yo = 'YO',
  YoBj = 'YO_BJ',
  YoNg = 'YO_NG',
  Yue = 'YUE',
  YueHans = 'YUE_HANS',
  YueHansCn = 'YUE_HANS_CN',
  YueHant = 'YUE_HANT',
  YueHantHk = 'YUE_HANT_HK',
  Zgh = 'ZGH',
  ZghMa = 'ZGH_MA',
  Zh = 'ZH',
  ZhHans = 'ZH_HANS',
  ZhHansCn = 'ZH_HANS_CN',
  ZhHansHk = 'ZH_HANS_HK',
  ZhHansMo = 'ZH_HANS_MO',
  ZhHansSg = 'ZH_HANS_SG',
  ZhHant = 'ZH_HANT',
  ZhHantHk = 'ZH_HANT_HK',
  ZhHantMo = 'ZH_HANT_MO',
  ZhHantTw = 'ZH_HANT_TW',
  Zu = 'ZU',
  ZuZa = 'ZU_ZA'
}

export type LanguageDisplay = {
  __typename?: 'LanguageDisplay';
  /** ISO 639 representation of the language name. */
  code: LanguageCodeEnum;
  /** Full name of the language. */
  language: Scalars['String'];
};

export type LimitInfo = {
  __typename?: 'LimitInfo';
  /** Defines the allowed maximum resource usage, null means unlimited. */
  allowedUsage: Limits;
  /** Defines the current resource usage. */
  currentUsage: Limits;
};

export type Limits = {
  __typename?: 'Limits';
  channels?: Maybe<Scalars['Int']>;
  orders?: Maybe<Scalars['Int']>;
  productVariants?: Maybe<Scalars['Int']>;
  staffUsers?: Maybe<Scalars['Int']>;
  warehouses?: Maybe<Scalars['Int']>;
};

/** The manifest definition. */
export type Manifest = {
  __typename?: 'Manifest';
  about?: Maybe<Scalars['String']>;
  appUrl?: Maybe<Scalars['String']>;
  configurationUrl?: Maybe<Scalars['String']>;
  dataPrivacy?: Maybe<Scalars['String']>;
  dataPrivacyUrl?: Maybe<Scalars['String']>;
  extensions: Array<AppManifestExtension>;
  homepageUrl?: Maybe<Scalars['String']>;
  identifier: Scalars['String'];
  name: Scalars['String'];
  permissions?: Maybe<Array<Permission>>;
  supportUrl?: Maybe<Scalars['String']>;
  tokenTargetUrl?: Maybe<Scalars['String']>;
  version: Scalars['String'];
};

export type Margin = {
  __typename?: 'Margin';
  start?: Maybe<Scalars['Int']>;
  stop?: Maybe<Scalars['Int']>;
};

/** An enumeration. */
export enum MeasurementUnitsEnum {
  AcreFt = 'ACRE_FT',
  AcreIn = 'ACRE_IN',
  Cm = 'CM',
  CubicCentimeter = 'CUBIC_CENTIMETER',
  CubicDecimeter = 'CUBIC_DECIMETER',
  CubicFoot = 'CUBIC_FOOT',
  CubicInch = 'CUBIC_INCH',
  CubicMeter = 'CUBIC_METER',
  CubicMillimeter = 'CUBIC_MILLIMETER',
  CubicYard = 'CUBIC_YARD',
  FlOz = 'FL_OZ',
  Ft = 'FT',
  G = 'G',
  Inch = 'INCH',
  Kg = 'KG',
  Km = 'KM',
  Lb = 'LB',
  Liter = 'LITER',
  M = 'M',
  Oz = 'OZ',
  Pint = 'PINT',
  Qt = 'QT',
  SqCm = 'SQ_CM',
  SqFt = 'SQ_FT',
  SqInch = 'SQ_INCH',
  SqKm = 'SQ_KM',
  SqM = 'SQ_M',
  SqYd = 'SQ_YD',
  Tonne = 'TONNE',
  Yd = 'YD'
}

/** Represents a single menu - an object that is used to help navigate through the store. */
export type Menu = Node & ObjectWithMetadata & {
  __typename?: 'Menu';
  id: Scalars['ID'];
  items?: Maybe<Array<MenuItem>>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  slug: Scalars['String'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single menu - an object that is used to help navigate through the store. */
export type MenuPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Deletes menus. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuBulkDelete = {
  __typename?: 'MenuBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<MenuError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuCountableConnection = {
  __typename?: 'MenuCountableConnection';
  edges: Array<MenuCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type MenuCountableEdge = {
  __typename?: 'MenuCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Menu;
};

/** Creates a new Menu. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuCreate = {
  __typename?: 'MenuCreate';
  errors: Array<MenuError>;
  menu?: Maybe<Menu>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuCreateInput = {
  /** List of menu items. */
  items?: InputMaybe<Array<MenuItemInput>>;
  /** Name of the menu. */
  name: Scalars['String'];
  /** Slug of the menu. Will be generated if not provided. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Deletes a menu. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuDelete = {
  __typename?: 'MenuDelete';
  errors: Array<MenuError>;
  menu?: Maybe<Menu>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuError = {
  __typename?: 'MenuError';
  /** The error code. */
  code: MenuErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum MenuErrorCode {
  CannotAssignNode = 'CANNOT_ASSIGN_NODE',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  InvalidMenuItem = 'INVALID_MENU_ITEM',
  NotFound = 'NOT_FOUND',
  NoMenuItemProvided = 'NO_MENU_ITEM_PROVIDED',
  Required = 'REQUIRED',
  TooManyMenuItems = 'TOO_MANY_MENU_ITEMS',
  Unique = 'UNIQUE'
}

export type MenuFilterInput = {
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Array<Scalars['String']>>;
};

export type MenuInput = {
  /** Name of the menu. */
  name?: InputMaybe<Scalars['String']>;
  /** Slug of the menu. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItem = Node & ObjectWithMetadata & {
  __typename?: 'MenuItem';
  category?: Maybe<Category>;
  children?: Maybe<Array<MenuItem>>;
  /** A collection associated with this menu item. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collection?: Maybe<Collection>;
  id: Scalars['ID'];
  level: Scalars['Int'];
  menu: Menu;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** A page associated with this menu item. Requires one of the following permissions to include unpublished items: PagePermissions.MANAGE_PAGES. */
  page?: Maybe<Page>;
  parent?: Maybe<MenuItem>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Returns translated menu item fields for the given language code. */
  translation?: Maybe<MenuItemTranslation>;
  /** URL to the menu item. */
  url?: Maybe<Scalars['String']>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a single item of the related menu. Can store categories, collection or pages. */
export type MenuItemTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Deletes menu items. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuItemBulkDelete = {
  __typename?: 'MenuItemBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<MenuError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuItemCountableConnection = {
  __typename?: 'MenuItemCountableConnection';
  edges: Array<MenuItemCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type MenuItemCountableEdge = {
  __typename?: 'MenuItemCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: MenuItem;
};

/** Creates a new menu item. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuItemCreate = {
  __typename?: 'MenuItemCreate';
  errors: Array<MenuError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
  menuItem?: Maybe<MenuItem>;
};

export type MenuItemCreateInput = {
  /** Category to which item points. */
  category?: InputMaybe<Scalars['ID']>;
  /** Collection to which item points. */
  collection?: InputMaybe<Scalars['ID']>;
  /** Menu to which item belongs. */
  menu: Scalars['ID'];
  /** Name of the menu item. */
  name: Scalars['String'];
  /** Page to which item points. */
  page?: InputMaybe<Scalars['ID']>;
  /** ID of the parent menu. If empty, menu will be top level menu. */
  parent?: InputMaybe<Scalars['ID']>;
  /** URL of the pointed item. */
  url?: InputMaybe<Scalars['String']>;
};

/** Deletes a menu item. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuItemDelete = {
  __typename?: 'MenuItemDelete';
  errors: Array<MenuError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
  menuItem?: Maybe<MenuItem>;
};

export type MenuItemFilterInput = {
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
};

export type MenuItemInput = {
  /** Category to which item points. */
  category?: InputMaybe<Scalars['ID']>;
  /** Collection to which item points. */
  collection?: InputMaybe<Scalars['ID']>;
  /** Name of the menu item. */
  name?: InputMaybe<Scalars['String']>;
  /** Page to which item points. */
  page?: InputMaybe<Scalars['ID']>;
  /** URL of the pointed item. */
  url?: InputMaybe<Scalars['String']>;
};

/** Moves items of menus. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuItemMove = {
  __typename?: 'MenuItemMove';
  errors: Array<MenuError>;
  /** Assigned menu to move within. */
  menu?: Maybe<Menu>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MenuItemMoveInput = {
  /** The menu item ID to move. */
  itemId: Scalars['ID'];
  /** ID of the parent menu. If empty, menu will be top level menu. */
  parentId?: InputMaybe<Scalars['ID']>;
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder?: InputMaybe<Scalars['Int']>;
};

export type MenuItemSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort menu items by the selected field. */
  field: MenuItemsSortField;
};

export type MenuItemTranslatableContent = Node & {
  __typename?: 'MenuItemTranslatableContent';
  id: Scalars['ID'];
  /**
   * Represents a single item of the related menu. Can store categories, collection or pages.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  menuItem?: Maybe<MenuItem>;
  name: Scalars['String'];
  /** Returns translated menu item fields for the given language code. */
  translation?: Maybe<MenuItemTranslation>;
};


export type MenuItemTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a menu item. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type MenuItemTranslate = {
  __typename?: 'MenuItemTranslate';
  errors: Array<TranslationError>;
  menuItem?: Maybe<MenuItem>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type MenuItemTranslation = Node & {
  __typename?: 'MenuItemTranslation';
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name: Scalars['String'];
};

/** Updates a menu item. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuItemUpdate = {
  __typename?: 'MenuItemUpdate';
  errors: Array<MenuError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
  menuItem?: Maybe<MenuItem>;
};

export enum MenuItemsSortField {
  /** Sort menu items by name. */
  Name = 'NAME'
}

export enum MenuSortField {
  /** Sort menus by items count. */
  ItemsCount = 'ITEMS_COUNT',
  /** Sort menus by name. */
  Name = 'NAME'
}

export type MenuSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort menus by the selected field. */
  field: MenuSortField;
};

/** Updates a menu. Requires one of the following permissions: MANAGE_MENUS. */
export type MenuUpdate = {
  __typename?: 'MenuUpdate';
  errors: Array<MenuError>;
  menu?: Maybe<Menu>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  menuErrors: Array<MenuError>;
};

export type MetadataError = {
  __typename?: 'MetadataError';
  /** The error code. */
  code: MetadataErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum MetadataErrorCode {
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  NotUpdated = 'NOT_UPDATED',
  Required = 'REQUIRED'
}

export type MetadataFilter = {
  /** Key of a metadata item. */
  key: Scalars['String'];
  /** Value of a metadata item. */
  value?: InputMaybe<Scalars['String']>;
};

export type MetadataInput = {
  /** Key of a metadata item. */
  key: Scalars['String'];
  /** Value of a metadata item. */
  value: Scalars['String'];
};

export type MetadataItem = {
  __typename?: 'MetadataItem';
  /** Key of a metadata item. */
  key: Scalars['String'];
  /** Value of a metadata item. */
  value: Scalars['String'];
};

/** Represents amount of money in specific currency. */
export type Money = {
  __typename?: 'Money';
  /** Amount of money. */
  amount: Scalars['Float'];
  /** Currency code. */
  currency: Scalars['String'];
};

export type MoneyInput = {
  /** Amount of money. */
  amount: Scalars['PositiveDecimal'];
  /** Currency code. */
  currency: Scalars['String'];
};

/** Represents a range of amounts of money. */
export type MoneyRange = {
  __typename?: 'MoneyRange';
  /** Lower bound of a price range. */
  start?: Maybe<Money>;
  /** Upper bound of a price range. */
  stop?: Maybe<Money>;
};

export type MoveProductInput = {
  /** The ID of the product to move. */
  productId: Scalars['ID'];
  /** The relative sorting position of the product (from -inf to +inf) starting from the first given product's actual position.1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder?: InputMaybe<Scalars['Int']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Create a new address for the customer. Requires one of the following permissions: AUTHENTICATED_USER. */
  accountAddressCreate?: Maybe<AccountAddressCreate>;
  /** Delete an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER. */
  accountAddressDelete?: Maybe<AccountAddressDelete>;
  /** Updates an address of the logged-in user. Requires one of the following permissions: MANAGE_USERS, IS_OWNER. */
  accountAddressUpdate?: Maybe<AccountAddressUpdate>;
  /** Remove user account. Requires one of the following permissions: AUTHENTICATED_USER. */
  accountDelete?: Maybe<AccountDelete>;
  /** Register a new user. */
  accountRegister?: Maybe<AccountRegister>;
  /** Sends an email with the account removal link for the logged-in user. Requires one of the following permissions: AUTHENTICATED_USER. */
  accountRequestDeletion?: Maybe<AccountRequestDeletion>;
  /** Sets a default address for the authenticated user. Requires one of the following permissions: AUTHENTICATED_USER. */
  accountSetDefaultAddress?: Maybe<AccountSetDefaultAddress>;
  /** Updates the account of the logged-in user. Requires one of the following permissions: AUTHENTICATED_USER. */
  accountUpdate?: Maybe<AccountUpdate>;
  /** Creates user address. Requires one of the following permissions: MANAGE_USERS. */
  addressCreate?: Maybe<AddressCreate>;
  /** Deletes an address. Requires one of the following permissions: MANAGE_USERS. */
  addressDelete?: Maybe<AddressDelete>;
  /** Sets a default address for the given user. Requires one of the following permissions: MANAGE_USERS. */
  addressSetDefault?: Maybe<AddressSetDefault>;
  /** Updates an address. Requires one of the following permissions: MANAGE_USERS. */
  addressUpdate?: Maybe<AddressUpdate>;
  /** Activate the app. Requires one of the following permissions: MANAGE_APPS. */
  appActivate?: Maybe<AppActivate>;
  /** Creates a new app. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
  appCreate?: Maybe<AppCreate>;
  /** Deactivate the app. Requires one of the following permissions: MANAGE_APPS. */
  appDeactivate?: Maybe<AppDeactivate>;
  /** Deletes an app. Requires one of the following permissions: MANAGE_APPS. */
  appDelete?: Maybe<AppDelete>;
  /** Delete failed installation. Requires one of the following permissions: MANAGE_APPS. */
  appDeleteFailedInstallation?: Maybe<AppDeleteFailedInstallation>;
  /** Fetch and validate manifest. Requires one of the following permissions: MANAGE_APPS. */
  appFetchManifest?: Maybe<AppFetchManifest>;
  /** Install new app by using app manifest. Requires the following permissions: AUTHENTICATED_STAFF_USER and MANAGE_APPS. */
  appInstall?: Maybe<AppInstall>;
  /** Retry failed installation of new app. Requires one of the following permissions: MANAGE_APPS. */
  appRetryInstall?: Maybe<AppRetryInstall>;
  /** Creates a new token. Requires one of the following permissions: MANAGE_APPS. */
  appTokenCreate?: Maybe<AppTokenCreate>;
  /** Deletes an authentication token assigned to app. Requires one of the following permissions: MANAGE_APPS. */
  appTokenDelete?: Maybe<AppTokenDelete>;
  /** Verify provided app token. */
  appTokenVerify?: Maybe<AppTokenVerify>;
  /** Updates an existing app. Requires one of the following permissions: MANAGE_APPS. */
  appUpdate?: Maybe<AppUpdate>;
  /** Assigns storefront's navigation menus. Requires one of the following permissions: MANAGE_MENUS, MANAGE_SETTINGS. */
  assignNavigation?: Maybe<AssignNavigation>;
  /** Add shipping zone to given warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
  assignWarehouseShippingZone?: Maybe<WarehouseShippingZoneAssign>;
  /** Deletes attributes. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  attributeBulkDelete?: Maybe<AttributeBulkDelete>;
  /** Creates an attribute. */
  attributeCreate?: Maybe<AttributeCreate>;
  /** Deletes an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  attributeDelete?: Maybe<AttributeDelete>;
  /** Reorder the values of an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  attributeReorderValues?: Maybe<AttributeReorderValues>;
  /** Creates/updates translations for an attribute. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  attributeTranslate?: Maybe<AttributeTranslate>;
  /** Updates attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  attributeUpdate?: Maybe<AttributeUpdate>;
  /** Deletes values of attributes. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  attributeValueBulkDelete?: Maybe<AttributeValueBulkDelete>;
  /** Creates a value for an attribute. Requires one of the following permissions: MANAGE_PRODUCTS. */
  attributeValueCreate?: Maybe<AttributeValueCreate>;
  /** Deletes a value of an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  attributeValueDelete?: Maybe<AttributeValueDelete>;
  /** Creates/updates translations for an attribute value. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  attributeValueTranslate?: Maybe<AttributeValueTranslate>;
  /** Updates value of an attribute. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  attributeValueUpdate?: Maybe<AttributeValueUpdate>;
  /** Deletes categories. Requires one of the following permissions: MANAGE_PRODUCTS. */
  categoryBulkDelete?: Maybe<CategoryBulkDelete>;
  /** Creates a new category. Requires one of the following permissions: MANAGE_PRODUCTS. */
  categoryCreate?: Maybe<CategoryCreate>;
  /** Deletes a category. Requires one of the following permissions: MANAGE_PRODUCTS. */
  categoryDelete?: Maybe<CategoryDelete>;
  /** Creates/updates translations for a category. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  categoryTranslate?: Maybe<CategoryTranslate>;
  /** Updates a category. Requires one of the following permissions: MANAGE_PRODUCTS. */
  categoryUpdate?: Maybe<CategoryUpdate>;
  /** Activate a channel. Requires one of the following permissions: MANAGE_CHANNELS. */
  channelActivate?: Maybe<ChannelActivate>;
  /** Creates new channel. Requires one of the following permissions: MANAGE_CHANNELS. */
  channelCreate?: Maybe<ChannelCreate>;
  /** Deactivate a channel. Requires one of the following permissions: MANAGE_CHANNELS. */
  channelDeactivate?: Maybe<ChannelDeactivate>;
  /** Delete a channel. Orders associated with the deleted channel will be moved to the target channel. Checkouts, product availability, and pricing will be removed. Requires one of the following permissions: MANAGE_CHANNELS. */
  channelDelete?: Maybe<ChannelDelete>;
  /** Update a channel. Requires one of the following permissions: MANAGE_CHANNELS. */
  channelUpdate?: Maybe<ChannelUpdate>;
  /** Adds a gift card or a voucher to a checkout. */
  checkoutAddPromoCode?: Maybe<CheckoutAddPromoCode>;
  /** Update billing address in the existing checkout. */
  checkoutBillingAddressUpdate?: Maybe<CheckoutBillingAddressUpdate>;
  /** Completes the checkout. As a result a new order is created and a payment charge is made. This action requires a successful payment before it can be performed. In case additional confirmation step as 3D secure is required confirmationNeeded flag will be set to True and no order created until payment is confirmed with second call of this mutation. */
  checkoutComplete?: Maybe<CheckoutComplete>;
  /** Create a new checkout. */
  checkoutCreate?: Maybe<CheckoutCreate>;
  /** Sets the customer as the owner of the checkout. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER. */
  checkoutCustomerAttach?: Maybe<CheckoutCustomerAttach>;
  /** Removes the user assigned as the owner of the checkout. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_USER. */
  checkoutCustomerDetach?: Maybe<CheckoutCustomerDetach>;
  /** Added in Saleor 3.1. Updates the delivery method (shipping method or pick up point) of the checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  checkoutDeliveryMethodUpdate?: Maybe<CheckoutDeliveryMethodUpdate>;
  /** Updates email address in the existing checkout object. */
  checkoutEmailUpdate?: Maybe<CheckoutEmailUpdate>;
  /** Update language code in the existing checkout. */
  checkoutLanguageCodeUpdate?: Maybe<CheckoutLanguageCodeUpdate>;
  /**
   * Deletes a CheckoutLine.
   * @deprecated DEPRECATED: Will be removed in Saleor 4.0. Use `checkoutLinesDelete` instead.
   */
  checkoutLineDelete?: Maybe<CheckoutLineDelete>;
  /** Adds a checkout line to the existing checkout.If line was already in checkout, its quantity will be increased. */
  checkoutLinesAdd?: Maybe<CheckoutLinesAdd>;
  /** Deletes checkout lines. */
  checkoutLinesDelete?: Maybe<CheckoutLinesDelete>;
  /** Updates checkout line in the existing checkout. */
  checkoutLinesUpdate?: Maybe<CheckoutLinesUpdate>;
  /** Create a new payment for given checkout. */
  checkoutPaymentCreate?: Maybe<CheckoutPaymentCreate>;
  /** Remove a gift card or a voucher from a checkout. */
  checkoutRemovePromoCode?: Maybe<CheckoutRemovePromoCode>;
  /** Update shipping address in the existing checkout. */
  checkoutShippingAddressUpdate?: Maybe<CheckoutShippingAddressUpdate>;
  /**
   * Updates the shipping method of the checkout.
   * @deprecated This field will be removed in Saleor 4.0. Use `checkoutDeliveryMethodUpdate` instead.
   */
  checkoutShippingMethodUpdate?: Maybe<CheckoutShippingMethodUpdate>;
  /** Adds products to a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionAddProducts?: Maybe<CollectionAddProducts>;
  /** Deletes collections. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionBulkDelete?: Maybe<CollectionBulkDelete>;
  /** Manage collection's availability in channels. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionChannelListingUpdate?: Maybe<CollectionChannelListingUpdate>;
  /** Creates a new collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionCreate?: Maybe<CollectionCreate>;
  /** Deletes a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionDelete?: Maybe<CollectionDelete>;
  /** Remove products from a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionRemoveProducts?: Maybe<CollectionRemoveProducts>;
  /** Reorder the products of a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionReorderProducts?: Maybe<CollectionReorderProducts>;
  /** Creates/updates translations for a collection. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  collectionTranslate?: Maybe<CollectionTranslate>;
  /** Updates a collection. Requires one of the following permissions: MANAGE_PRODUCTS. */
  collectionUpdate?: Maybe<CollectionUpdate>;
  /** Confirm user account with token sent by email during registration. */
  confirmAccount?: Maybe<ConfirmAccount>;
  /** Confirm the email change of the logged-in user. Requires one of the following permissions: AUTHENTICATED_USER. */
  confirmEmailChange?: Maybe<ConfirmEmailChange>;
  /** Creates new warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
  createWarehouse?: Maybe<WarehouseCreate>;
  /** Deletes customers. Requires one of the following permissions: MANAGE_USERS. */
  customerBulkDelete?: Maybe<CustomerBulkDelete>;
  /** Creates a new customer. Requires one of the following permissions: MANAGE_USERS. */
  customerCreate?: Maybe<CustomerCreate>;
  /** Deletes a customer. Requires one of the following permissions: MANAGE_USERS. */
  customerDelete?: Maybe<CustomerDelete>;
  /** Updates an existing customer. Requires one of the following permissions: MANAGE_USERS. */
  customerUpdate?: Maybe<CustomerUpdate>;
  /** Delete metadata of an object. To use it, you need to have access to the modified object. */
  deleteMetadata?: Maybe<DeleteMetadata>;
  /** Delete object's private metadata. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
  deletePrivateMetadata?: Maybe<DeletePrivateMetadata>;
  /** Deletes selected warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
  deleteWarehouse?: Maybe<WarehouseDelete>;
  /** Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContentCreate?: Maybe<DigitalContentCreate>;
  /** Remove digital content assigned to given variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContentDelete?: Maybe<DigitalContentDelete>;
  /** Update digital content. Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContentUpdate?: Maybe<DigitalContentUpdate>;
  /** Generate new URL to digital content. Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContentUrlCreate?: Maybe<DigitalContentUrlCreate>;
  /** Deletes draft orders. Requires one of the following permissions: MANAGE_ORDERS. */
  draftOrderBulkDelete?: Maybe<DraftOrderBulkDelete>;
  /** Completes creating an order. Requires one of the following permissions: MANAGE_ORDERS. */
  draftOrderComplete?: Maybe<DraftOrderComplete>;
  /** Creates a new draft order. Requires one of the following permissions: MANAGE_ORDERS. */
  draftOrderCreate?: Maybe<DraftOrderCreate>;
  /** Deletes a draft order. Requires one of the following permissions: MANAGE_ORDERS. */
  draftOrderDelete?: Maybe<DraftOrderDelete>;
  /**
   * Deletes order lines. Requires one of the following permissions: MANAGE_ORDERS.
   * @deprecated This field will be removed in Saleor 4.0.
   */
  draftOrderLinesBulkDelete?: Maybe<DraftOrderLinesBulkDelete>;
  /** Updates a draft order. Requires one of the following permissions: MANAGE_ORDERS. */
  draftOrderUpdate?: Maybe<DraftOrderUpdate>;
  /** Retries event delivery. Requires one of the following permissions: MANAGE_APPS. */
  eventDeliveryRetry?: Maybe<EventDeliveryRetry>;
  /** Added in Saleor 3.1. Export gift cards to csv file. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  exportGiftCards?: Maybe<ExportGiftCards>;
  /** Export products to csv file. Requires one of the following permissions: MANAGE_PRODUCTS. */
  exportProducts?: Maybe<ExportProducts>;
  /** Prepare external authentication url for user by custom plugin. */
  externalAuthenticationUrl?: Maybe<ExternalAuthenticationUrl>;
  /** Logout user by custom plugin. */
  externalLogout?: Maybe<ExternalLogout>;
  /** Added in Saleor 3.1. Trigger sending a notification with the notify plugin method. Serializes nodes provided as ids parameter and includes this data in the notification payload. */
  externalNotificationTrigger?: Maybe<ExternalNotificationTrigger>;
  /** Obtain external access tokens for user by custom plugin. */
  externalObtainAccessTokens?: Maybe<ExternalObtainAccessTokens>;
  /** Refresh user's access by custom plugin. */
  externalRefresh?: Maybe<ExternalRefresh>;
  /** Verify external authentication data by plugin. */
  externalVerify?: Maybe<ExternalVerify>;
  /** Upload a file. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER. */
  fileUpload?: Maybe<FileUpload>;
  /** Activate a gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardActivate?: Maybe<GiftCardActivate>;
  /** Added in Saleor 3.1. Adds note to the gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardAddNote?: Maybe<GiftCardAddNote>;
  /** Added in Saleor 3.1. Activate gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardBulkActivate?: Maybe<GiftCardBulkActivate>;
  /** Added in Saleor 3.1. Create gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardBulkCreate?: Maybe<GiftCardBulkCreate>;
  /** Added in Saleor 3.1. Deactivate gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardBulkDeactivate?: Maybe<GiftCardBulkDeactivate>;
  /** Added in Saleor 3.1. Delete gift cards. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardBulkDelete?: Maybe<GiftCardBulkDelete>;
  /** Creates a new gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardCreate?: Maybe<GiftCardCreate>;
  /** Deactivate a gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardDeactivate?: Maybe<GiftCardDeactivate>;
  /** Added in Saleor 3.1. Delete gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardDelete?: Maybe<GiftCardDelete>;
  /** Added in Saleor 3.1. Resend a gift card. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardResend?: Maybe<GiftCardResend>;
  /** Update gift card settings. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardSettingsUpdate?: Maybe<GiftCardSettingsUpdate>;
  /** Update a gift card. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardUpdate?: Maybe<GiftCardUpdate>;
  /** Creates a ready to send invoice. Requires one of the following permissions: MANAGE_ORDERS. */
  invoiceCreate?: Maybe<InvoiceCreate>;
  /** Deletes an invoice. Requires one of the following permissions: MANAGE_ORDERS. */
  invoiceDelete?: Maybe<InvoiceDelete>;
  /** Request an invoice for the order using plugin. Requires one of the following permissions: MANAGE_ORDERS. */
  invoiceRequest?: Maybe<InvoiceRequest>;
  /** Requests deletion of an invoice. Requires one of the following permissions: MANAGE_ORDERS. */
  invoiceRequestDelete?: Maybe<InvoiceRequestDelete>;
  /** Send an invoice notification to the customer. Requires one of the following permissions: MANAGE_ORDERS. */
  invoiceSendNotification?: Maybe<InvoiceSendNotification>;
  /** Updates an invoice. Requires one of the following permissions: MANAGE_ORDERS. */
  invoiceUpdate?: Maybe<InvoiceUpdate>;
  /** Deletes menus. Requires one of the following permissions: MANAGE_MENUS. */
  menuBulkDelete?: Maybe<MenuBulkDelete>;
  /** Creates a new Menu. Requires one of the following permissions: MANAGE_MENUS. */
  menuCreate?: Maybe<MenuCreate>;
  /** Deletes a menu. Requires one of the following permissions: MANAGE_MENUS. */
  menuDelete?: Maybe<MenuDelete>;
  /** Deletes menu items. Requires one of the following permissions: MANAGE_MENUS. */
  menuItemBulkDelete?: Maybe<MenuItemBulkDelete>;
  /** Creates a new menu item. Requires one of the following permissions: MANAGE_MENUS. */
  menuItemCreate?: Maybe<MenuItemCreate>;
  /** Deletes a menu item. Requires one of the following permissions: MANAGE_MENUS. */
  menuItemDelete?: Maybe<MenuItemDelete>;
  /** Moves items of menus. Requires one of the following permissions: MANAGE_MENUS. */
  menuItemMove?: Maybe<MenuItemMove>;
  /** Creates/updates translations for a menu item. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  menuItemTranslate?: Maybe<MenuItemTranslate>;
  /** Updates a menu item. Requires one of the following permissions: MANAGE_MENUS. */
  menuItemUpdate?: Maybe<MenuItemUpdate>;
  /** Updates a menu. Requires one of the following permissions: MANAGE_MENUS. */
  menuUpdate?: Maybe<MenuUpdate>;
  /** Adds note to the order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderAddNote?: Maybe<OrderAddNote>;
  /** Cancels orders. Requires one of the following permissions: MANAGE_ORDERS. */
  orderBulkCancel?: Maybe<OrderBulkCancel>;
  /** Cancel an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderCancel?: Maybe<OrderCancel>;
  /** Capture an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderCapture?: Maybe<OrderCapture>;
  /** Confirms an unconfirmed order by changing status to unfulfilled. Requires one of the following permissions: MANAGE_ORDERS. */
  orderConfirm?: Maybe<OrderConfirm>;
  /** Added in Saleor 3.2. Create new order from existing checkout. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: HANDLE_CHECKOUTS. */
  orderCreateFromCheckout?: Maybe<OrderCreateFromCheckout>;
  /** Adds discount to the order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderDiscountAdd?: Maybe<OrderDiscountAdd>;
  /** Remove discount from the order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderDiscountDelete?: Maybe<OrderDiscountDelete>;
  /** Update discount for the order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderDiscountUpdate?: Maybe<OrderDiscountUpdate>;
  /** Creates new fulfillments for an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderFulfill?: Maybe<OrderFulfill>;
  /** Added in Saleor 3.1. Approve existing fulfillment. Requires one of the following permissions: MANAGE_ORDERS. */
  orderFulfillmentApprove?: Maybe<FulfillmentApprove>;
  /** Cancels existing fulfillment and optionally restocks items. Requires one of the following permissions: MANAGE_ORDERS. */
  orderFulfillmentCancel?: Maybe<FulfillmentCancel>;
  /** Refund products. Requires one of the following permissions: MANAGE_ORDERS. */
  orderFulfillmentRefundProducts?: Maybe<FulfillmentRefundProducts>;
  /** Return products. Requires one of the following permissions: MANAGE_ORDERS. */
  orderFulfillmentReturnProducts?: Maybe<FulfillmentReturnProducts>;
  /** Updates a fulfillment for an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderFulfillmentUpdateTracking?: Maybe<FulfillmentUpdateTracking>;
  /** Deletes an order line from an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderLineDelete?: Maybe<OrderLineDelete>;
  /** Remove discount applied to the order line. Requires one of the following permissions: MANAGE_ORDERS. */
  orderLineDiscountRemove?: Maybe<OrderLineDiscountRemove>;
  /** Update discount for the order line. Requires one of the following permissions: MANAGE_ORDERS. */
  orderLineDiscountUpdate?: Maybe<OrderLineDiscountUpdate>;
  /** Updates an order line of an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderLineUpdate?: Maybe<OrderLineUpdate>;
  /** Create order lines for an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderLinesCreate?: Maybe<OrderLinesCreate>;
  /** Mark order as manually paid. Requires one of the following permissions: MANAGE_ORDERS. */
  orderMarkAsPaid?: Maybe<OrderMarkAsPaid>;
  /** Refund an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderRefund?: Maybe<OrderRefund>;
  /** Update shop order settings. Requires one of the following permissions: MANAGE_ORDERS. */
  orderSettingsUpdate?: Maybe<OrderSettingsUpdate>;
  /** Updates an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderUpdate?: Maybe<OrderUpdate>;
  /** Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed. Requires one of the following permissions: MANAGE_ORDERS. */
  orderUpdateShipping?: Maybe<OrderUpdateShipping>;
  /** Void an order. Requires one of the following permissions: MANAGE_ORDERS. */
  orderVoid?: Maybe<OrderVoid>;
  /** Assign attributes to a given page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageAttributeAssign?: Maybe<PageAttributeAssign>;
  /** Unassign attributes from a given page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageAttributeUnassign?: Maybe<PageAttributeUnassign>;
  /** Deletes pages. Requires one of the following permissions: MANAGE_PAGES. */
  pageBulkDelete?: Maybe<PageBulkDelete>;
  /** Publish pages. Requires one of the following permissions: MANAGE_PAGES. */
  pageBulkPublish?: Maybe<PageBulkPublish>;
  /** Creates a new page. Requires one of the following permissions: MANAGE_PAGES. */
  pageCreate?: Maybe<PageCreate>;
  /** Deletes a page. Requires one of the following permissions: MANAGE_PAGES. */
  pageDelete?: Maybe<PageDelete>;
  /** Reorder page attribute values. Requires one of the following permissions: MANAGE_PAGES. */
  pageReorderAttributeValues?: Maybe<PageReorderAttributeValues>;
  /** Creates/updates translations for a page. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  pageTranslate?: Maybe<PageTranslate>;
  /** Delete page types. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageTypeBulkDelete?: Maybe<PageTypeBulkDelete>;
  /** Create a new page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageTypeCreate?: Maybe<PageTypeCreate>;
  /** Delete a page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageTypeDelete?: Maybe<PageTypeDelete>;
  /** Reorder the attributes of a page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageTypeReorderAttributes?: Maybe<PageTypeReorderAttributes>;
  /** Update page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
  pageTypeUpdate?: Maybe<PageTypeUpdate>;
  /** Updates an existing page. Requires one of the following permissions: MANAGE_PAGES. */
  pageUpdate?: Maybe<PageUpdate>;
  /** Change the password of the logged in user. Requires one of the following permissions: AUTHENTICATED_USER. */
  passwordChange?: Maybe<PasswordChange>;
  /** Captures the authorized payment amount. Requires one of the following permissions: MANAGE_ORDERS. */
  paymentCapture?: Maybe<PaymentCapture>;
  /** Check payment balance. */
  paymentCheckBalance?: Maybe<PaymentCheckBalance>;
  /** Initializes payment process when it is required by gateway. */
  paymentInitialize?: Maybe<PaymentInitialize>;
  /** Refunds the captured payment amount. Requires one of the following permissions: MANAGE_ORDERS. */
  paymentRefund?: Maybe<PaymentRefund>;
  /** Voids the authorized payment. Requires one of the following permissions: MANAGE_ORDERS. */
  paymentVoid?: Maybe<PaymentVoid>;
  /** Create new permission group. Requires one of the following permissions: MANAGE_STAFF. */
  permissionGroupCreate?: Maybe<PermissionGroupCreate>;
  /** Delete permission group. Requires one of the following permissions: MANAGE_STAFF. */
  permissionGroupDelete?: Maybe<PermissionGroupDelete>;
  /** Update permission group. Requires one of the following permissions: MANAGE_STAFF. */
  permissionGroupUpdate?: Maybe<PermissionGroupUpdate>;
  /** Update plugin configuration. Requires one of the following permissions: MANAGE_PLUGINS. */
  pluginUpdate?: Maybe<PluginUpdate>;
  /** Assign attributes to a given product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productAttributeAssign?: Maybe<ProductAttributeAssign>;
  /** Added in Saleor 3.1. Update attributes assigned to product variant for given product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productAttributeAssignmentUpdate?: Maybe<ProductAttributeAssignmentUpdate>;
  /** Un-assign attributes from a given product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productAttributeUnassign?: Maybe<ProductAttributeUnassign>;
  /** Deletes products. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productBulkDelete?: Maybe<ProductBulkDelete>;
  /** Manage product's availability in channels. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productChannelListingUpdate?: Maybe<ProductChannelListingUpdate>;
  /** Creates a new product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productCreate?: Maybe<ProductCreate>;
  /** Deletes a product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productDelete?: Maybe<ProductDelete>;
  /** Deletes product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productMediaBulkDelete?: Maybe<ProductMediaBulkDelete>;
  /** Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: MANAGE_PRODUCTS. */
  productMediaCreate?: Maybe<ProductMediaCreate>;
  /** Deletes a product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productMediaDelete?: Maybe<ProductMediaDelete>;
  /** Changes ordering of the product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productMediaReorder?: Maybe<ProductMediaReorder>;
  /** Updates a product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productMediaUpdate?: Maybe<ProductMediaUpdate>;
  /** Reorder product attribute values. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productReorderAttributeValues?: Maybe<ProductReorderAttributeValues>;
  /** Creates/updates translations for a product. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  productTranslate?: Maybe<ProductTranslate>;
  /** Deletes product types. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productTypeBulkDelete?: Maybe<ProductTypeBulkDelete>;
  /** Creates a new product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productTypeCreate?: Maybe<ProductTypeCreate>;
  /** Deletes a product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productTypeDelete?: Maybe<ProductTypeDelete>;
  /** Reorder the attributes of a product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productTypeReorderAttributes?: Maybe<ProductTypeReorderAttributes>;
  /** Updates an existing product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
  productTypeUpdate?: Maybe<ProductTypeUpdate>;
  /** Updates an existing product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productUpdate?: Maybe<ProductUpdate>;
  /** Creates product variants for a given product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantBulkCreate?: Maybe<ProductVariantBulkCreate>;
  /** Deletes product variants. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantBulkDelete?: Maybe<ProductVariantBulkDelete>;
  /** Manage product variant prices in channels. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantChannelListingUpdate?: Maybe<ProductVariantChannelListingUpdate>;
  /** Creates a new variant for a product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantCreate?: Maybe<ProductVariantCreate>;
  /** Deletes a product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantDelete?: Maybe<ProductVariantDelete>;
  /** Added in Saleor 3.1. Deactivates product variant preorder. It changes all preorder allocation into regular allocation. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantPreorderDeactivate?: Maybe<ProductVariantPreorderDeactivate>;
  /** Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantReorder?: Maybe<ProductVariantReorder>;
  /** Reorder product variant attribute values. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantReorderAttributeValues?: Maybe<ProductVariantReorderAttributeValues>;
  /** Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantSetDefault?: Maybe<ProductVariantSetDefault>;
  /** Creates stocks for product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantStocksCreate?: Maybe<ProductVariantStocksCreate>;
  /** Delete stocks from product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantStocksDelete?: Maybe<ProductVariantStocksDelete>;
  /** Update stocks for product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantStocksUpdate?: Maybe<ProductVariantStocksUpdate>;
  /** Creates/updates translations for a product variant. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  productVariantTranslate?: Maybe<ProductVariantTranslate>;
  /** Updates an existing variant for product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  productVariantUpdate?: Maybe<ProductVariantUpdate>;
  /** Request email change of the logged in user. Requires one of the following permissions: AUTHENTICATED_USER. */
  requestEmailChange?: Maybe<RequestEmailChange>;
  /** Sends an email with the account password modification link. */
  requestPasswordReset?: Maybe<RequestPasswordReset>;
  /** Deletes sales. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleBulkDelete?: Maybe<SaleBulkDelete>;
  /** Adds products, categories, collections to a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleCataloguesAdd?: Maybe<SaleAddCatalogues>;
  /** Removes products, categories, collections from a sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleCataloguesRemove?: Maybe<SaleRemoveCatalogues>;
  /** Manage sale's availability in channels. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleChannelListingUpdate?: Maybe<SaleChannelListingUpdate>;
  /** Creates a new sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleCreate?: Maybe<SaleCreate>;
  /** Deletes a sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleDelete?: Maybe<SaleDelete>;
  /** Creates/updates translations for a sale. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  saleTranslate?: Maybe<SaleTranslate>;
  /** Updates a sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  saleUpdate?: Maybe<SaleUpdate>;
  /** Sets the user's password from the token sent by email using the RequestPasswordReset mutation. */
  setPassword?: Maybe<SetPassword>;
  /** Manage shipping method's availability in channels. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingMethodChannelListingUpdate?: Maybe<ShippingMethodChannelListingUpdate>;
  /** Deletes shipping prices. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingPriceBulkDelete?: Maybe<ShippingPriceBulkDelete>;
  /** Creates a new shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingPriceCreate?: Maybe<ShippingPriceCreate>;
  /** Deletes a shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingPriceDelete?: Maybe<ShippingPriceDelete>;
  /** Exclude products from shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingPriceExcludeProducts?: Maybe<ShippingPriceExcludeProducts>;
  /** Remove product from excluded list for shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingPriceRemoveProductFromExclude?: Maybe<ShippingPriceRemoveProductFromExclude>;
  /** Creates/updates translations for a shipping method. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  shippingPriceTranslate?: Maybe<ShippingPriceTranslate>;
  /** Updates a new shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingPriceUpdate?: Maybe<ShippingPriceUpdate>;
  /** Deletes shipping zones. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingZoneBulkDelete?: Maybe<ShippingZoneBulkDelete>;
  /** Creates a new shipping zone. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingZoneCreate?: Maybe<ShippingZoneCreate>;
  /** Deletes a shipping zone. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingZoneDelete?: Maybe<ShippingZoneDelete>;
  /** Updates a new shipping zone. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingZoneUpdate?: Maybe<ShippingZoneUpdate>;
  /** Update the shop's address. If the `null` value is passed, the currently selected address will be deleted. Requires one of the following permissions: MANAGE_SETTINGS. */
  shopAddressUpdate?: Maybe<ShopAddressUpdate>;
  /** Updates site domain of the shop. Requires one of the following permissions: MANAGE_SETTINGS. */
  shopDomainUpdate?: Maybe<ShopDomainUpdate>;
  /** Fetch tax rates. Requires one of the following permissions: MANAGE_SETTINGS. */
  shopFetchTaxRates?: Maybe<ShopFetchTaxRates>;
  /** Creates/updates translations for shop settings. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  shopSettingsTranslate?: Maybe<ShopSettingsTranslate>;
  /** Updates shop settings. Requires one of the following permissions: MANAGE_SETTINGS. */
  shopSettingsUpdate?: Maybe<ShopSettingsUpdate>;
  /** Deletes staff users. Requires one of the following permissions: MANAGE_STAFF. */
  staffBulkDelete?: Maybe<StaffBulkDelete>;
  /** Creates a new staff user. Requires one of the following permissions: MANAGE_STAFF. */
  staffCreate?: Maybe<StaffCreate>;
  /** Deletes a staff user. Requires one of the following permissions: MANAGE_STAFF. */
  staffDelete?: Maybe<StaffDelete>;
  /** Creates a new staff notification recipient. Requires one of the following permissions: MANAGE_SETTINGS. */
  staffNotificationRecipientCreate?: Maybe<StaffNotificationRecipientCreate>;
  /** Delete staff notification recipient. Requires one of the following permissions: MANAGE_SETTINGS. */
  staffNotificationRecipientDelete?: Maybe<StaffNotificationRecipientDelete>;
  /** Updates a staff notification recipient. Requires one of the following permissions: MANAGE_SETTINGS. */
  staffNotificationRecipientUpdate?: Maybe<StaffNotificationRecipientUpdate>;
  /** Updates an existing staff user. Requires one of the following permissions: MANAGE_STAFF. */
  staffUpdate?: Maybe<StaffUpdate>;
  /** Create JWT token. */
  tokenCreate?: Maybe<CreateToken>;
  /** Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie. */
  tokenRefresh?: Maybe<RefreshToken>;
  /** Verify JWT token. */
  tokenVerify?: Maybe<VerifyToken>;
  /** Deactivate all JWT tokens of the currently authenticated user. Requires one of the following permissions: AUTHENTICATED_USER. */
  tokensDeactivateAll?: Maybe<DeactivateAllUserTokens>;
  /** Remove shipping zone from given warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
  unassignWarehouseShippingZone?: Maybe<WarehouseShippingZoneUnassign>;
  /** Updates metadata of an object. To use it, you need to have access to the modified object. */
  updateMetadata?: Maybe<UpdateMetadata>;
  /** Updates private metadata of an object. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
  updatePrivateMetadata?: Maybe<UpdatePrivateMetadata>;
  /** Updates given warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
  updateWarehouse?: Maybe<WarehouseUpdate>;
  /** Deletes a user avatar. Only for staff members. Requires one of the following permissions: AUTHENTICATED_STAFF_USER. */
  userAvatarDelete?: Maybe<UserAvatarDelete>;
  /** Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: AUTHENTICATED_STAFF_USER. */
  userAvatarUpdate?: Maybe<UserAvatarUpdate>;
  /** Activate or deactivate users. Requires one of the following permissions: MANAGE_USERS. */
  userBulkSetActive?: Maybe<UserBulkSetActive>;
  /** Assign an media to a product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  variantMediaAssign?: Maybe<VariantMediaAssign>;
  /** Unassign an media from a product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  variantMediaUnassign?: Maybe<VariantMediaUnassign>;
  /** Deletes vouchers. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherBulkDelete?: Maybe<VoucherBulkDelete>;
  /** Adds products, categories, collections to a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherCataloguesAdd?: Maybe<VoucherAddCatalogues>;
  /** Removes products, categories, collections from a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherCataloguesRemove?: Maybe<VoucherRemoveCatalogues>;
  /** Manage voucher's availability in channels. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherChannelListingUpdate?: Maybe<VoucherChannelListingUpdate>;
  /** Creates a new voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherCreate?: Maybe<VoucherCreate>;
  /** Deletes a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherDelete?: Maybe<VoucherDelete>;
  /** Creates/updates translations for a voucher. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  voucherTranslate?: Maybe<VoucherTranslate>;
  /** Updates a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucherUpdate?: Maybe<VoucherUpdate>;
  /** Creates a new webhook subscription. Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP. */
  webhookCreate?: Maybe<WebhookCreate>;
  /** Deletes a webhook subscription. Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP. */
  webhookDelete?: Maybe<WebhookDelete>;
  /** Updates a webhook subscription. Requires one of the following permissions: MANAGE_APPS. */
  webhookUpdate?: Maybe<WebhookUpdate>;
};


export type MutationAccountAddressCreateArgs = {
  input: AddressInput;
  type?: InputMaybe<AddressTypeEnum>;
};


export type MutationAccountAddressDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAccountAddressUpdateArgs = {
  id: Scalars['ID'];
  input: AddressInput;
};


export type MutationAccountDeleteArgs = {
  token: Scalars['String'];
};


export type MutationAccountRegisterArgs = {
  input: AccountRegisterInput;
};


export type MutationAccountRequestDeletionArgs = {
  channel?: InputMaybe<Scalars['String']>;
  redirectUrl: Scalars['String'];
};


export type MutationAccountSetDefaultAddressArgs = {
  id: Scalars['ID'];
  type: AddressTypeEnum;
};


export type MutationAccountUpdateArgs = {
  input: AccountInput;
};


export type MutationAddressCreateArgs = {
  input: AddressInput;
  userId: Scalars['ID'];
};


export type MutationAddressDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAddressSetDefaultArgs = {
  addressId: Scalars['ID'];
  type: AddressTypeEnum;
  userId: Scalars['ID'];
};


export type MutationAddressUpdateArgs = {
  id: Scalars['ID'];
  input: AddressInput;
};


export type MutationAppActivateArgs = {
  id: Scalars['ID'];
};


export type MutationAppCreateArgs = {
  input: AppInput;
};


export type MutationAppDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationAppDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAppDeleteFailedInstallationArgs = {
  id: Scalars['ID'];
};


export type MutationAppFetchManifestArgs = {
  manifestUrl: Scalars['String'];
};


export type MutationAppInstallArgs = {
  input: AppInstallInput;
};


export type MutationAppRetryInstallArgs = {
  activateAfterInstallation?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
};


export type MutationAppTokenCreateArgs = {
  input: AppTokenInput;
};


export type MutationAppTokenDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAppTokenVerifyArgs = {
  token: Scalars['String'];
};


export type MutationAppUpdateArgs = {
  id: Scalars['ID'];
  input: AppInput;
};


export type MutationAssignNavigationArgs = {
  menu?: InputMaybe<Scalars['ID']>;
  navigationType: NavigationType;
};


export type MutationAssignWarehouseShippingZoneArgs = {
  id: Scalars['ID'];
  shippingZoneIds: Array<Scalars['ID']>;
};


export type MutationAttributeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationAttributeCreateArgs = {
  input: AttributeCreateInput;
};


export type MutationAttributeDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAttributeReorderValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
};


export type MutationAttributeTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationAttributeUpdateArgs = {
  id: Scalars['ID'];
  input: AttributeUpdateInput;
};


export type MutationAttributeValueBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationAttributeValueCreateArgs = {
  attribute: Scalars['ID'];
  input: AttributeValueCreateInput;
};


export type MutationAttributeValueDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationAttributeValueTranslateArgs = {
  id: Scalars['ID'];
  input: AttributeValueTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationAttributeValueUpdateArgs = {
  id: Scalars['ID'];
  input: AttributeValueUpdateInput;
};


export type MutationCategoryBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationCategoryCreateArgs = {
  input: CategoryInput;
  parent?: InputMaybe<Scalars['ID']>;
};


export type MutationCategoryDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCategoryTranslateArgs = {
  id: Scalars['ID'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationCategoryUpdateArgs = {
  id: Scalars['ID'];
  input: CategoryInput;
};


export type MutationChannelActivateArgs = {
  id: Scalars['ID'];
};


export type MutationChannelCreateArgs = {
  input: ChannelCreateInput;
};


export type MutationChannelDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationChannelDeleteArgs = {
  id: Scalars['ID'];
  input?: InputMaybe<ChannelDeleteInput>;
};


export type MutationChannelUpdateArgs = {
  id: Scalars['ID'];
  input: ChannelUpdateInput;
};


export type MutationCheckoutAddPromoCodeArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  promoCode: Scalars['String'];
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutBillingAddressUpdateArgs = {
  billingAddress: AddressInput;
  checkoutId?: InputMaybe<Scalars['ID']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutCompleteArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  paymentData?: InputMaybe<Scalars['JSONString']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  storeSource?: InputMaybe<Scalars['Boolean']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutCreateArgs = {
  input: CheckoutCreateInput;
};


export type MutationCheckoutCustomerAttachArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  customerId?: InputMaybe<Scalars['ID']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutCustomerDetachArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutDeliveryMethodUpdateArgs = {
  deliveryMethodId?: InputMaybe<Scalars['ID']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutEmailUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  email: Scalars['String'];
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLanguageCodeUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  languageCode: LanguageCodeEnum;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLineDeleteArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  lineId?: InputMaybe<Scalars['ID']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLinesAddArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  lines: Array<CheckoutLineInput>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutLinesDeleteArgs = {
  linesIds: Array<Scalars['ID']>;
  token: Scalars['UUID'];
};


export type MutationCheckoutLinesUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  lines: Array<CheckoutLineUpdateInput>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutPaymentCreateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  input: PaymentInput;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutRemovePromoCodeArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  promoCode?: InputMaybe<Scalars['String']>;
  promoCodeId?: InputMaybe<Scalars['ID']>;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutShippingAddressUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  shippingAddress: AddressInput;
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCheckoutShippingMethodUpdateArgs = {
  checkoutId?: InputMaybe<Scalars['ID']>;
  shippingMethodId: Scalars['ID'];
  token?: InputMaybe<Scalars['UUID']>;
};


export type MutationCollectionAddProductsArgs = {
  collectionId: Scalars['ID'];
  products: Array<Scalars['ID']>;
};


export type MutationCollectionBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationCollectionChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: CollectionChannelListingUpdateInput;
};


export type MutationCollectionCreateArgs = {
  input: CollectionCreateInput;
};


export type MutationCollectionDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCollectionRemoveProductsArgs = {
  collectionId: Scalars['ID'];
  products: Array<Scalars['ID']>;
};


export type MutationCollectionReorderProductsArgs = {
  collectionId: Scalars['ID'];
  moves: Array<MoveProductInput>;
};


export type MutationCollectionTranslateArgs = {
  id: Scalars['ID'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationCollectionUpdateArgs = {
  id: Scalars['ID'];
  input: CollectionInput;
};


export type MutationConfirmAccountArgs = {
  email: Scalars['String'];
  token: Scalars['String'];
};


export type MutationConfirmEmailChangeArgs = {
  channel?: InputMaybe<Scalars['String']>;
  token: Scalars['String'];
};


export type MutationCreateWarehouseArgs = {
  input: WarehouseCreateInput;
};


export type MutationCustomerBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationCustomerCreateArgs = {
  input: UserCreateInput;
};


export type MutationCustomerDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationCustomerUpdateArgs = {
  id: Scalars['ID'];
  input: CustomerInput;
};


export type MutationDeleteMetadataArgs = {
  id: Scalars['ID'];
  keys: Array<Scalars['String']>;
};


export type MutationDeletePrivateMetadataArgs = {
  id: Scalars['ID'];
  keys: Array<Scalars['String']>;
};


export type MutationDeleteWarehouseArgs = {
  id: Scalars['ID'];
};


export type MutationDigitalContentCreateArgs = {
  input: DigitalContentUploadInput;
  variantId: Scalars['ID'];
};


export type MutationDigitalContentDeleteArgs = {
  variantId: Scalars['ID'];
};


export type MutationDigitalContentUpdateArgs = {
  input: DigitalContentInput;
  variantId: Scalars['ID'];
};


export type MutationDigitalContentUrlCreateArgs = {
  input: DigitalContentUrlCreateInput;
};


export type MutationDraftOrderBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationDraftOrderCompleteArgs = {
  id: Scalars['ID'];
};


export type MutationDraftOrderCreateArgs = {
  input: DraftOrderCreateInput;
};


export type MutationDraftOrderDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationDraftOrderLinesBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationDraftOrderUpdateArgs = {
  id: Scalars['ID'];
  input: DraftOrderInput;
};


export type MutationEventDeliveryRetryArgs = {
  id: Scalars['ID'];
};


export type MutationExportGiftCardsArgs = {
  input: ExportGiftCardsInput;
};


export type MutationExportProductsArgs = {
  input: ExportProductsInput;
};


export type MutationExternalAuthenticationUrlArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalLogoutArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalNotificationTriggerArgs = {
  channel: Scalars['String'];
  input: ExternalNotificationTriggerInput;
  pluginId?: InputMaybe<Scalars['String']>;
};


export type MutationExternalObtainAccessTokensArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalRefreshArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationExternalVerifyArgs = {
  input: Scalars['JSONString'];
  pluginId: Scalars['String'];
};


export type MutationFileUploadArgs = {
  file: Scalars['Upload'];
};


export type MutationGiftCardActivateArgs = {
  id: Scalars['ID'];
};


export type MutationGiftCardAddNoteArgs = {
  id: Scalars['ID'];
  input: GiftCardAddNoteInput;
};


export type MutationGiftCardBulkActivateArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationGiftCardBulkCreateArgs = {
  input: GiftCardBulkCreateInput;
};


export type MutationGiftCardBulkDeactivateArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationGiftCardBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationGiftCardCreateArgs = {
  input: GiftCardCreateInput;
};


export type MutationGiftCardDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationGiftCardDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationGiftCardResendArgs = {
  input: GiftCardResendInput;
};


export type MutationGiftCardSettingsUpdateArgs = {
  input: GiftCardSettingsUpdateInput;
};


export type MutationGiftCardUpdateArgs = {
  id: Scalars['ID'];
  input: GiftCardUpdateInput;
};


export type MutationInvoiceCreateArgs = {
  input: InvoiceCreateInput;
  orderId: Scalars['ID'];
};


export type MutationInvoiceDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationInvoiceRequestArgs = {
  number?: InputMaybe<Scalars['String']>;
  orderId: Scalars['ID'];
};


export type MutationInvoiceRequestDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationInvoiceSendNotificationArgs = {
  id: Scalars['ID'];
};


export type MutationInvoiceUpdateArgs = {
  id: Scalars['ID'];
  input: UpdateInvoiceInput;
};


export type MutationMenuBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationMenuCreateArgs = {
  input: MenuCreateInput;
};


export type MutationMenuDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationMenuItemBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationMenuItemCreateArgs = {
  input: MenuItemCreateInput;
};


export type MutationMenuItemDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationMenuItemMoveArgs = {
  menu: Scalars['ID'];
  moves: Array<MenuItemMoveInput>;
};


export type MutationMenuItemTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationMenuItemUpdateArgs = {
  id: Scalars['ID'];
  input: MenuItemInput;
};


export type MutationMenuUpdateArgs = {
  id: Scalars['ID'];
  input: MenuInput;
};


export type MutationOrderAddNoteArgs = {
  input: OrderAddNoteInput;
  order: Scalars['ID'];
};


export type MutationOrderBulkCancelArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationOrderCancelArgs = {
  id: Scalars['ID'];
};


export type MutationOrderCaptureArgs = {
  amount: Scalars['PositiveDecimal'];
  id: Scalars['ID'];
};


export type MutationOrderConfirmArgs = {
  id: Scalars['ID'];
};


export type MutationOrderCreateFromCheckoutArgs = {
  id: Scalars['ID'];
  removeCheckout?: InputMaybe<Scalars['Boolean']>;
};


export type MutationOrderDiscountAddArgs = {
  input: OrderDiscountCommonInput;
  orderId: Scalars['ID'];
};


export type MutationOrderDiscountDeleteArgs = {
  discountId: Scalars['ID'];
};


export type MutationOrderDiscountUpdateArgs = {
  discountId: Scalars['ID'];
  input: OrderDiscountCommonInput;
};


export type MutationOrderFulfillArgs = {
  input: OrderFulfillInput;
  order?: InputMaybe<Scalars['ID']>;
};


export type MutationOrderFulfillmentApproveArgs = {
  allowStockToBeExceeded?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  notifyCustomer: Scalars['Boolean'];
};


export type MutationOrderFulfillmentCancelArgs = {
  id: Scalars['ID'];
  input?: InputMaybe<FulfillmentCancelInput>;
};


export type MutationOrderFulfillmentRefundProductsArgs = {
  input: OrderRefundProductsInput;
  order: Scalars['ID'];
};


export type MutationOrderFulfillmentReturnProductsArgs = {
  input: OrderReturnProductsInput;
  order: Scalars['ID'];
};


export type MutationOrderFulfillmentUpdateTrackingArgs = {
  id: Scalars['ID'];
  input: FulfillmentUpdateTrackingInput;
};


export type MutationOrderLineDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationOrderLineDiscountRemoveArgs = {
  orderLineId: Scalars['ID'];
};


export type MutationOrderLineDiscountUpdateArgs = {
  input: OrderDiscountCommonInput;
  orderLineId: Scalars['ID'];
};


export type MutationOrderLineUpdateArgs = {
  id: Scalars['ID'];
  input: OrderLineInput;
};


export type MutationOrderLinesCreateArgs = {
  id: Scalars['ID'];
  input: Array<OrderLineCreateInput>;
};


export type MutationOrderMarkAsPaidArgs = {
  id: Scalars['ID'];
  transactionReference?: InputMaybe<Scalars['String']>;
};


export type MutationOrderRefundArgs = {
  amount: Scalars['PositiveDecimal'];
  id: Scalars['ID'];
};


export type MutationOrderSettingsUpdateArgs = {
  input: OrderSettingsUpdateInput;
};


export type MutationOrderUpdateArgs = {
  id: Scalars['ID'];
  input: OrderUpdateInput;
};


export type MutationOrderUpdateShippingArgs = {
  input: OrderUpdateShippingInput;
  order: Scalars['ID'];
};


export type MutationOrderVoidArgs = {
  id: Scalars['ID'];
};


export type MutationPageAttributeAssignArgs = {
  attributeIds: Array<Scalars['ID']>;
  pageTypeId: Scalars['ID'];
};


export type MutationPageAttributeUnassignArgs = {
  attributeIds: Array<Scalars['ID']>;
  pageTypeId: Scalars['ID'];
};


export type MutationPageBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationPageBulkPublishArgs = {
  ids: Array<Scalars['ID']>;
  isPublished: Scalars['Boolean'];
};


export type MutationPageCreateArgs = {
  input: PageCreateInput;
};


export type MutationPageDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPageReorderAttributeValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
  pageId: Scalars['ID'];
};


export type MutationPageTranslateArgs = {
  id: Scalars['ID'];
  input: PageTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationPageTypeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationPageTypeCreateArgs = {
  input: PageTypeCreateInput;
};


export type MutationPageTypeDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPageTypeReorderAttributesArgs = {
  moves: Array<ReorderInput>;
  pageTypeId: Scalars['ID'];
};


export type MutationPageTypeUpdateArgs = {
  id?: InputMaybe<Scalars['ID']>;
  input: PageTypeUpdateInput;
};


export type MutationPageUpdateArgs = {
  id: Scalars['ID'];
  input: PageInput;
};


export type MutationPasswordChangeArgs = {
  newPassword: Scalars['String'];
  oldPassword: Scalars['String'];
};


export type MutationPaymentCaptureArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']>;
  paymentId: Scalars['ID'];
};


export type MutationPaymentCheckBalanceArgs = {
  input: PaymentCheckBalanceInput;
};


export type MutationPaymentInitializeArgs = {
  channel?: InputMaybe<Scalars['String']>;
  gateway: Scalars['String'];
  paymentData?: InputMaybe<Scalars['JSONString']>;
};


export type MutationPaymentRefundArgs = {
  amount?: InputMaybe<Scalars['PositiveDecimal']>;
  paymentId: Scalars['ID'];
};


export type MutationPaymentVoidArgs = {
  paymentId: Scalars['ID'];
};


export type MutationPermissionGroupCreateArgs = {
  input: PermissionGroupCreateInput;
};


export type MutationPermissionGroupDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationPermissionGroupUpdateArgs = {
  id: Scalars['ID'];
  input: PermissionGroupUpdateInput;
};


export type MutationPluginUpdateArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
  id: Scalars['ID'];
  input: PluginUpdateInput;
};


export type MutationProductAttributeAssignArgs = {
  operations: Array<ProductAttributeAssignInput>;
  productTypeId: Scalars['ID'];
};


export type MutationProductAttributeAssignmentUpdateArgs = {
  operations: Array<ProductAttributeAssignmentUpdateInput>;
  productTypeId: Scalars['ID'];
};


export type MutationProductAttributeUnassignArgs = {
  attributeIds: Array<Scalars['ID']>;
  productTypeId: Scalars['ID'];
};


export type MutationProductBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: ProductChannelListingUpdateInput;
};


export type MutationProductCreateArgs = {
  input: ProductCreateInput;
};


export type MutationProductDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationProductMediaBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductMediaCreateArgs = {
  input: ProductMediaCreateInput;
};


export type MutationProductMediaDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationProductMediaReorderArgs = {
  mediaIds: Array<Scalars['ID']>;
  productId: Scalars['ID'];
};


export type MutationProductMediaUpdateArgs = {
  id: Scalars['ID'];
  input: ProductMediaUpdateInput;
};


export type MutationProductReorderAttributeValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
  productId: Scalars['ID'];
};


export type MutationProductTranslateArgs = {
  id: Scalars['ID'];
  input: TranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationProductTypeBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductTypeCreateArgs = {
  input: ProductTypeInput;
};


export type MutationProductTypeDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationProductTypeReorderAttributesArgs = {
  moves: Array<ReorderInput>;
  productTypeId: Scalars['ID'];
  type: ProductAttributeType;
};


export type MutationProductTypeUpdateArgs = {
  id: Scalars['ID'];
  input: ProductTypeInput;
};


export type MutationProductUpdateArgs = {
  id: Scalars['ID'];
  input: ProductInput;
};


export type MutationProductVariantBulkCreateArgs = {
  product: Scalars['ID'];
  variants: Array<ProductVariantBulkCreateInput>;
};


export type MutationProductVariantBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationProductVariantChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: Array<ProductVariantChannelListingAddInput>;
};


export type MutationProductVariantCreateArgs = {
  input: ProductVariantCreateInput;
};


export type MutationProductVariantDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationProductVariantPreorderDeactivateArgs = {
  id: Scalars['ID'];
};


export type MutationProductVariantReorderArgs = {
  moves: Array<ReorderInput>;
  productId: Scalars['ID'];
};


export type MutationProductVariantReorderAttributeValuesArgs = {
  attributeId: Scalars['ID'];
  moves: Array<ReorderInput>;
  variantId: Scalars['ID'];
};


export type MutationProductVariantSetDefaultArgs = {
  productId: Scalars['ID'];
  variantId: Scalars['ID'];
};


export type MutationProductVariantStocksCreateArgs = {
  stocks: Array<StockInput>;
  variantId: Scalars['ID'];
};


export type MutationProductVariantStocksDeleteArgs = {
  variantId: Scalars['ID'];
  warehouseIds?: InputMaybe<Array<Scalars['ID']>>;
};


export type MutationProductVariantStocksUpdateArgs = {
  stocks: Array<StockInput>;
  variantId: Scalars['ID'];
};


export type MutationProductVariantTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationProductVariantUpdateArgs = {
  id: Scalars['ID'];
  input: ProductVariantInput;
};


export type MutationRequestEmailChangeArgs = {
  channel?: InputMaybe<Scalars['String']>;
  newEmail: Scalars['String'];
  password: Scalars['String'];
  redirectUrl: Scalars['String'];
};


export type MutationRequestPasswordResetArgs = {
  channel?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  redirectUrl: Scalars['String'];
};


export type MutationSaleBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationSaleCataloguesAddArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationSaleCataloguesRemoveArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationSaleChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: SaleChannelListingInput;
};


export type MutationSaleCreateArgs = {
  input: SaleInput;
};


export type MutationSaleDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationSaleTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationSaleUpdateArgs = {
  id: Scalars['ID'];
  input: SaleInput;
};


export type MutationSetPasswordArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
  token: Scalars['String'];
};


export type MutationShippingMethodChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: ShippingMethodChannelListingInput;
};


export type MutationShippingPriceBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationShippingPriceCreateArgs = {
  input: ShippingPriceInput;
};


export type MutationShippingPriceDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationShippingPriceExcludeProductsArgs = {
  id: Scalars['ID'];
  input: ShippingPriceExcludeProductsInput;
};


export type MutationShippingPriceRemoveProductFromExcludeArgs = {
  id: Scalars['ID'];
  products: Array<Scalars['ID']>;
};


export type MutationShippingPriceTranslateArgs = {
  id: Scalars['ID'];
  input: ShippingPriceTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationShippingPriceUpdateArgs = {
  id: Scalars['ID'];
  input: ShippingPriceInput;
};


export type MutationShippingZoneBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationShippingZoneCreateArgs = {
  input: ShippingZoneCreateInput;
};


export type MutationShippingZoneDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationShippingZoneUpdateArgs = {
  id: Scalars['ID'];
  input: ShippingZoneUpdateInput;
};


export type MutationShopAddressUpdateArgs = {
  input?: InputMaybe<AddressInput>;
};


export type MutationShopDomainUpdateArgs = {
  input?: InputMaybe<SiteDomainInput>;
};


export type MutationShopSettingsTranslateArgs = {
  input: ShopSettingsTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationShopSettingsUpdateArgs = {
  input: ShopSettingsInput;
};


export type MutationStaffBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationStaffCreateArgs = {
  input: StaffCreateInput;
};


export type MutationStaffDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationStaffNotificationRecipientCreateArgs = {
  input: StaffNotificationRecipientInput;
};


export type MutationStaffNotificationRecipientDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationStaffNotificationRecipientUpdateArgs = {
  id: Scalars['ID'];
  input: StaffNotificationRecipientInput;
};


export type MutationStaffUpdateArgs = {
  id: Scalars['ID'];
  input: StaffUpdateInput;
};


export type MutationTokenCreateArgs = {
  email: Scalars['String'];
  password: Scalars['String'];
};


export type MutationTokenRefreshArgs = {
  csrfToken?: InputMaybe<Scalars['String']>;
  refreshToken?: InputMaybe<Scalars['String']>;
};


export type MutationTokenVerifyArgs = {
  token: Scalars['String'];
};


export type MutationUnassignWarehouseShippingZoneArgs = {
  id: Scalars['ID'];
  shippingZoneIds: Array<Scalars['ID']>;
};


export type MutationUpdateMetadataArgs = {
  id: Scalars['ID'];
  input: Array<MetadataInput>;
};


export type MutationUpdatePrivateMetadataArgs = {
  id: Scalars['ID'];
  input: Array<MetadataInput>;
};


export type MutationUpdateWarehouseArgs = {
  id: Scalars['ID'];
  input: WarehouseUpdateInput;
};


export type MutationUserAvatarUpdateArgs = {
  image: Scalars['Upload'];
};


export type MutationUserBulkSetActiveArgs = {
  ids: Array<Scalars['ID']>;
  isActive: Scalars['Boolean'];
};


export type MutationVariantMediaAssignArgs = {
  mediaId: Scalars['ID'];
  variantId: Scalars['ID'];
};


export type MutationVariantMediaUnassignArgs = {
  mediaId: Scalars['ID'];
  variantId: Scalars['ID'];
};


export type MutationVoucherBulkDeleteArgs = {
  ids: Array<Scalars['ID']>;
};


export type MutationVoucherCataloguesAddArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationVoucherCataloguesRemoveArgs = {
  id: Scalars['ID'];
  input: CatalogueInput;
};


export type MutationVoucherChannelListingUpdateArgs = {
  id: Scalars['ID'];
  input: VoucherChannelListingInput;
};


export type MutationVoucherCreateArgs = {
  input: VoucherInput;
};


export type MutationVoucherDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationVoucherTranslateArgs = {
  id: Scalars['ID'];
  input: NameTranslationInput;
  languageCode: LanguageCodeEnum;
};


export type MutationVoucherUpdateArgs = {
  id: Scalars['ID'];
  input: VoucherInput;
};


export type MutationWebhookCreateArgs = {
  input: WebhookCreateInput;
};


export type MutationWebhookDeleteArgs = {
  id: Scalars['ID'];
};


export type MutationWebhookUpdateArgs = {
  id: Scalars['ID'];
  input: WebhookUpdateInput;
};

export type NameTranslationInput = {
  name?: InputMaybe<Scalars['String']>;
};

export enum NavigationType {
  /** Main storefront navigation. */
  Main = 'MAIN',
  /** Secondary storefront navigation. */
  Secondary = 'SECONDARY'
}

/** An object with an ID */
export type Node = {
  /** The ID of the object. */
  id: Scalars['ID'];
};

export type ObjectWithMetadata = {
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
};


export type ObjectWithMetadataMetafieldArgs = {
  key: Scalars['String'];
};


export type ObjectWithMetadataMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


export type ObjectWithMetadataPrivateMetafieldArgs = {
  key: Scalars['String'];
};


export type ObjectWithMetadataPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Represents an order in the shop. */
export type Order = Node & ObjectWithMetadata & {
  __typename?: 'Order';
  /** List of actions that can be performed in the current state of an order. */
  actions: Array<OrderAction>;
  /** Added in Saleor 3.1. Collection points that can be used for this order. Note: this feature is in a preview state and can be subject to changes at later point. */
  availableCollectionPoints: Array<Warehouse>;
  /**
   * Shipping methods that can be used with this order.
   * @deprecated Use `shippingMethods`, this field will be removed in 4.0
   */
  availableShippingMethods?: Maybe<Array<ShippingMethod>>;
  /** Billing address. Requires one of the following permissions to view the full data: OrderPermissions.MANAGE_ORDERS, AuthorizationFilters.OWNER. */
  billingAddress?: Maybe<Address>;
  /** Informs whether a draft order can be finalized(turned into a regular order). */
  canFinalize: Scalars['Boolean'];
  channel: Channel;
  collectionPointName?: Maybe<Scalars['String']>;
  created: Scalars['DateTime'];
  customerNote: Scalars['String'];
  /** Added in Saleor 3.1. The delivery method selected for this checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  deliveryMethod?: Maybe<DeliveryMethod>;
  /**
   * Returns applied discount.
   * @deprecated This field will be removed in Saleor 4.0. Use the `discounts` field instead.
   */
  discount?: Maybe<Money>;
  /**
   * Discount name.
   * @deprecated This field will be removed in Saleor 4.0. Use the `discounts` field instead.
   */
  discountName?: Maybe<Scalars['String']>;
  /** List of all discounts assigned to the order. */
  discounts: Array<OrderDiscount>;
  displayGrossPrices: Scalars['Boolean'];
  /** List of errors that occurred during order validation. */
  errors: Array<OrderError>;
  /** List of events associated with the order. Requires one of the following permissions: MANAGE_ORDERS. */
  events: Array<OrderEvent>;
  /** List of shipments for the order. */
  fulfillments: Array<Fulfillment>;
  /** List of user gift cards. */
  giftCards: Array<GiftCard>;
  id: Scalars['ID'];
  /** List of order invoices. Requires one of the following permissions: OrderPermissions.MANAGE_ORDERS, AuthorizationFilters.OWNER. */
  invoices: Array<Invoice>;
  /** Informs if an order is fully paid. */
  isPaid: Scalars['Boolean'];
  /** Returns True, if order requires shipping. */
  isShippingRequired: Scalars['Boolean'];
  /** @deprecated This field will be removed in Saleor 4.0. Use the `languageCodeEnum` field to fetch the language code.  */
  languageCode: Scalars['String'];
  /** Order language code. */
  languageCodeEnum: LanguageCodeEnum;
  /** List of order lines. */
  lines: Array<OrderLine>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** User-friendly number of an order. */
  number: Scalars['String'];
  /** The order origin. */
  origin: OrderOriginEnum;
  /** The ID of the order that was the base for this order. */
  original?: Maybe<Scalars['ID']>;
  /** Internal payment status. */
  paymentStatus: PaymentChargeStatusEnum;
  /** User-friendly payment status. */
  paymentStatusDisplay: Scalars['String'];
  /** List of payments for the order. */
  payments: Array<Payment>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  redirectUrl?: Maybe<Scalars['String']>;
  /** Shipping address. Requires one of the following permissions to view the full data: OrderPermissions.MANAGE_ORDERS, AuthorizationFilters.OWNER. */
  shippingAddress?: Maybe<Address>;
  /**
   * Shipping method for this order.
   * @deprecated This field will be removed in Saleor 4.0. Use `deliveryMethod` instead.
   */
  shippingMethod?: Maybe<ShippingMethod>;
  shippingMethodName?: Maybe<Scalars['String']>;
  /** Shipping methods related to this order. */
  shippingMethods: Array<ShippingMethod>;
  /** Total price of shipping. */
  shippingPrice: TaxedMoney;
  shippingTaxRate: Scalars['Float'];
  status: OrderStatus;
  /** User-friendly order status. */
  statusDisplay: Scalars['String'];
  /** The sum of line prices not including shipping. */
  subtotal: TaxedMoney;
  /** @deprecated This field will be removed in Saleor 4.0. Use `id` instead. */
  token: Scalars['String'];
  /** Total amount of the order. */
  total: TaxedMoney;
  /** Amount authorized for the order. */
  totalAuthorized: Money;
  /** The difference between the paid and the order total amount. */
  totalBalance: Money;
  /** Amount captured by payment. */
  totalCaptured: Money;
  trackingClientId: Scalars['String'];
  /**
   * Translated discount name.
   * @deprecated This field will be removed in Saleor 4.0. Use the `discounts` field instead.
   */
  translatedDiscountName?: Maybe<Scalars['String']>;
  /** Undiscounted total amount of the order. */
  undiscountedTotal: TaxedMoney;
  updatedAt: Scalars['DateTime'];
  /** User who placed the order. This field is set only for orders placed by authenticated users. Requires one of the following permissions: AccountPermissions.MANAGE_USERS, OrderPermissions.MANAGE_ORDERS, AuthorizationFilters.OWNER. */
  user?: Maybe<User>;
  /** Email address of the customer. Requires the following permissions to access the full data: OrderPermissions.MANAGE_ORDERS, AuthorizationFilters.OWNER */
  userEmail?: Maybe<Scalars['String']>;
  voucher?: Maybe<Voucher>;
  weight: Weight;
};


/** Represents an order in the shop. */
export type OrderMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an order in the shop. */
export type OrderMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an order in the shop. */
export type OrderPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an order in the shop. */
export type OrderPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

export enum OrderAction {
  /** Represents the capture action. */
  Capture = 'CAPTURE',
  /** Represents a mark-as-paid action. */
  MarkAsPaid = 'MARK_AS_PAID',
  /** Represents a refund action. */
  Refund = 'REFUND',
  /** Represents a void action. */
  Void = 'VOID'
}

/** Adds note to the order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderAddNote = {
  __typename?: 'OrderAddNote';
  errors: Array<OrderError>;
  /** Order note created. */
  event?: Maybe<OrderEvent>;
  /** Order with the note added. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderAddNoteInput = {
  /** Note message. */
  message: Scalars['String'];
};

/** Cancels orders. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderBulkCancel = {
  __typename?: 'OrderBulkCancel';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<OrderError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Cancel an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderCancel = {
  __typename?: 'OrderCancel';
  errors: Array<OrderError>;
  /** Canceled order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderCancelled = {
  __typename?: 'OrderCancelled';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

/** Capture an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderCapture = {
  __typename?: 'OrderCapture';
  errors: Array<OrderError>;
  /** Captured order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** Confirms an unconfirmed order by changing status to unfulfilled. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderConfirm = {
  __typename?: 'OrderConfirm';
  errors: Array<OrderError>;
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderConfirmed = {
  __typename?: 'OrderConfirmed';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

export type OrderCountableConnection = {
  __typename?: 'OrderCountableConnection';
  edges: Array<OrderCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type OrderCountableEdge = {
  __typename?: 'OrderCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Order;
};

/** Added in Saleor 3.2. Create new order from existing checkout. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: HANDLE_CHECKOUTS. */
export type OrderCreateFromCheckout = {
  __typename?: 'OrderCreateFromCheckout';
  errors: Array<OrderCreateFromCheckoutError>;
  /** Placed order. */
  order?: Maybe<Order>;
};

export type OrderCreateFromCheckoutError = {
  __typename?: 'OrderCreateFromCheckoutError';
  /** The error code. */
  code: OrderCreateFromCheckoutErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** List of line Ids which cause the error. */
  lines?: Maybe<Array<Scalars['ID']>>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of variant IDs which causes the error. */
  variants?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum OrderCreateFromCheckoutErrorCode {
  BillingAddressNotSet = 'BILLING_ADDRESS_NOT_SET',
  ChannelInactive = 'CHANNEL_INACTIVE',
  CheckoutNotFound = 'CHECKOUT_NOT_FOUND',
  EmailNotSet = 'EMAIL_NOT_SET',
  GiftCardNotApplicable = 'GIFT_CARD_NOT_APPLICABLE',
  GraphqlError = 'GRAPHQL_ERROR',
  InsufficientStock = 'INSUFFICIENT_STOCK',
  InvalidShippingMethod = 'INVALID_SHIPPING_METHOD',
  NoLines = 'NO_LINES',
  ShippingAddressNotSet = 'SHIPPING_ADDRESS_NOT_SET',
  ShippingMethodNotSet = 'SHIPPING_METHOD_NOT_SET',
  TaxError = 'TAX_ERROR',
  UnavailableVariantInChannel = 'UNAVAILABLE_VARIANT_IN_CHANNEL',
  VoucherNotApplicable = 'VOUCHER_NOT_APPLICABLE'
}

export type OrderCreated = {
  __typename?: 'OrderCreated';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

export enum OrderDirection {
  /** Specifies an ascending sort order. */
  Asc = 'ASC',
  /** Specifies a descending sort order. */
  Desc = 'DESC'
}

/** Contains all details related to the applied discount to the order. */
export type OrderDiscount = Node & {
  __typename?: 'OrderDiscount';
  /** Returns amount of discount. */
  amount: Money;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  /** Explanation for the applied discount. Requires one of the following permissions: MANAGE_ORDERS. */
  reason?: Maybe<Scalars['String']>;
  translatedName?: Maybe<Scalars['String']>;
  type: OrderDiscountType;
  /** Value of the discount. Can store fixed value or percent value */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent */
  valueType: DiscountValueTypeEnum;
};

/** Adds discount to the order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderDiscountAdd = {
  __typename?: 'OrderDiscountAdd';
  errors: Array<OrderError>;
  /** Order which has been discounted. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderDiscountCommonInput = {
  /** Explanation for the applied discount. */
  reason?: InputMaybe<Scalars['String']>;
  /** Value of the discount. Can store fixed value or percent value */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent */
  valueType: DiscountValueTypeEnum;
};

/** Remove discount from the order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderDiscountDelete = {
  __typename?: 'OrderDiscountDelete';
  errors: Array<OrderError>;
  /** Order which has removed discount. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** An enumeration. */
export enum OrderDiscountType {
  Manual = 'MANUAL',
  Voucher = 'VOUCHER'
}

/** Update discount for the order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderDiscountUpdate = {
  __typename?: 'OrderDiscountUpdate';
  errors: Array<OrderError>;
  /** Order which has been discounted. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderDraftFilterInput = {
  channels?: InputMaybe<Array<Scalars['ID']>>;
  created?: InputMaybe<DateRangeInput>;
  customer?: InputMaybe<Scalars['String']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
};

export type OrderError = {
  __typename?: 'OrderError';
  /** A type of address that causes the error. */
  addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: OrderErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of order line IDs that cause the error. */
  orderLines?: Maybe<Array<Scalars['ID']>>;
  /** List of product variants that are associated with the error */
  variants?: Maybe<Array<Scalars['ID']>>;
  /** Warehouse ID which causes the error. */
  warehouse?: Maybe<Scalars['ID']>;
};

/** An enumeration. */
export enum OrderErrorCode {
  BillingAddressNotSet = 'BILLING_ADDRESS_NOT_SET',
  CannotCancelFulfillment = 'CANNOT_CANCEL_FULFILLMENT',
  CannotCancelOrder = 'CANNOT_CANCEL_ORDER',
  CannotDelete = 'CANNOT_DELETE',
  CannotDiscount = 'CANNOT_DISCOUNT',
  CannotFulfillUnpaidOrder = 'CANNOT_FULFILL_UNPAID_ORDER',
  CannotRefund = 'CANNOT_REFUND',
  CaptureInactivePayment = 'CAPTURE_INACTIVE_PAYMENT',
  ChannelInactive = 'CHANNEL_INACTIVE',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  FulfillOrderLine = 'FULFILL_ORDER_LINE',
  GiftCardLine = 'GIFT_CARD_LINE',
  GraphqlError = 'GRAPHQL_ERROR',
  InsufficientStock = 'INSUFFICIENT_STOCK',
  Invalid = 'INVALID',
  InvalidQuantity = 'INVALID_QUANTITY',
  NotAvailableInChannel = 'NOT_AVAILABLE_IN_CHANNEL',
  NotEditable = 'NOT_EDITABLE',
  NotFound = 'NOT_FOUND',
  OrderNoShippingAddress = 'ORDER_NO_SHIPPING_ADDRESS',
  PaymentError = 'PAYMENT_ERROR',
  PaymentMissing = 'PAYMENT_MISSING',
  ProductNotPublished = 'PRODUCT_NOT_PUBLISHED',
  ProductUnavailableForPurchase = 'PRODUCT_UNAVAILABLE_FOR_PURCHASE',
  Required = 'REQUIRED',
  ShippingMethodNotApplicable = 'SHIPPING_METHOD_NOT_APPLICABLE',
  ShippingMethodRequired = 'SHIPPING_METHOD_REQUIRED',
  TaxError = 'TAX_ERROR',
  Unique = 'UNIQUE',
  VoidInactivePayment = 'VOID_INACTIVE_PAYMENT',
  ZeroQuantity = 'ZERO_QUANTITY'
}

/** History log of the order. */
export type OrderEvent = Node & {
  __typename?: 'OrderEvent';
  /** Amount of money. */
  amount?: Maybe<Scalars['Float']>;
  /** App that performed the action. Requires of of the following permissions: AppPermission.MANAGE_APPS, OrderPermissions.MANAGE_ORDERS, AuthorizationFilters.OWNER. */
  app?: Maybe<App>;
  /** Composed ID of the Fulfillment. */
  composedId?: Maybe<Scalars['String']>;
  /** Date when event happened at in ISO 8601 format. */
  date?: Maybe<Scalars['DateTime']>;
  /** The discount applied to the order. */
  discount?: Maybe<OrderEventDiscountObject>;
  /** Email of the customer. */
  email?: Maybe<Scalars['String']>;
  /** Type of an email sent to the customer. */
  emailType?: Maybe<OrderEventsEmailsEnum>;
  /** The lines fulfilled. */
  fulfilledItems?: Maybe<Array<FulfillmentLine>>;
  id: Scalars['ID'];
  /** Number of an invoice related to the order. */
  invoiceNumber?: Maybe<Scalars['String']>;
  /** The concerned lines. */
  lines?: Maybe<Array<OrderEventOrderLineObject>>;
  /** Content of the event. */
  message?: Maybe<Scalars['String']>;
  /** User-friendly number of an order. */
  orderNumber?: Maybe<Scalars['String']>;
  /** List of oversold lines names. */
  oversoldItems?: Maybe<Array<Scalars['String']>>;
  /** The payment gateway of the payment. */
  paymentGateway?: Maybe<Scalars['String']>;
  /** The payment ID from the payment gateway. */
  paymentId?: Maybe<Scalars['String']>;
  /** Number of items. */
  quantity?: Maybe<Scalars['Int']>;
  /** The order which is related to this order. */
  relatedOrder?: Maybe<Order>;
  /** Define if shipping costs were included to the refund. */
  shippingCostsIncluded?: Maybe<Scalars['Boolean']>;
  /** The transaction reference of captured payment. */
  transactionReference?: Maybe<Scalars['String']>;
  /** Order event type. */
  type?: Maybe<OrderEventsEnum>;
  /** User who performed the action. */
  user?: Maybe<User>;
  /** The warehouse were items were restocked. */
  warehouse?: Maybe<Warehouse>;
};

export type OrderEventCountableConnection = {
  __typename?: 'OrderEventCountableConnection';
  edges: Array<OrderEventCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type OrderEventCountableEdge = {
  __typename?: 'OrderEventCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: OrderEvent;
};

export type OrderEventDiscountObject = {
  __typename?: 'OrderEventDiscountObject';
  /** Returns amount of discount. */
  amount?: Maybe<Money>;
  /** Returns amount of discount. */
  oldAmount?: Maybe<Money>;
  /** Value of the discount. Can store fixed value or percent value. */
  oldValue?: Maybe<Scalars['PositiveDecimal']>;
  /** Type of the discount: fixed or percent. */
  oldValueType?: Maybe<DiscountValueTypeEnum>;
  /** Explanation for the applied discount. */
  reason?: Maybe<Scalars['String']>;
  /** Value of the discount. Can store fixed value or percent value. */
  value: Scalars['PositiveDecimal'];
  /** Type of the discount: fixed or percent. */
  valueType: DiscountValueTypeEnum;
};

export type OrderEventOrderLineObject = {
  __typename?: 'OrderEventOrderLineObject';
  /** The discount applied to the order line. */
  discount?: Maybe<OrderEventDiscountObject>;
  /** The variant name. */
  itemName?: Maybe<Scalars['String']>;
  /** The order line. */
  orderLine?: Maybe<OrderLine>;
  /** The variant quantity. */
  quantity?: Maybe<Scalars['Int']>;
};

/** An enumeration. */
export enum OrderEventsEmailsEnum {
  Confirmed = 'CONFIRMED',
  DigitalLinks = 'DIGITAL_LINKS',
  FulfillmentConfirmation = 'FULFILLMENT_CONFIRMATION',
  OrderCancel = 'ORDER_CANCEL',
  OrderConfirmation = 'ORDER_CONFIRMATION',
  OrderRefund = 'ORDER_REFUND',
  PaymentConfirmation = 'PAYMENT_CONFIRMATION',
  ShippingConfirmation = 'SHIPPING_CONFIRMATION',
  TrackingUpdated = 'TRACKING_UPDATED'
}

/** An enumeration. */
export enum OrderEventsEnum {
  AddedProducts = 'ADDED_PRODUCTS',
  Canceled = 'CANCELED',
  Confirmed = 'CONFIRMED',
  DraftCreated = 'DRAFT_CREATED',
  DraftCreatedFromReplace = 'DRAFT_CREATED_FROM_REPLACE',
  EmailSent = 'EMAIL_SENT',
  ExternalServiceNotification = 'EXTERNAL_SERVICE_NOTIFICATION',
  FulfillmentAwaitsApproval = 'FULFILLMENT_AWAITS_APPROVAL',
  FulfillmentCanceled = 'FULFILLMENT_CANCELED',
  FulfillmentFulfilledItems = 'FULFILLMENT_FULFILLED_ITEMS',
  FulfillmentRefunded = 'FULFILLMENT_REFUNDED',
  FulfillmentReplaced = 'FULFILLMENT_REPLACED',
  FulfillmentRestockedItems = 'FULFILLMENT_RESTOCKED_ITEMS',
  FulfillmentReturned = 'FULFILLMENT_RETURNED',
  InvoiceGenerated = 'INVOICE_GENERATED',
  InvoiceRequested = 'INVOICE_REQUESTED',
  InvoiceSent = 'INVOICE_SENT',
  InvoiceUpdated = 'INVOICE_UPDATED',
  NoteAdded = 'NOTE_ADDED',
  OrderDiscountAdded = 'ORDER_DISCOUNT_ADDED',
  OrderDiscountAutomaticallyUpdated = 'ORDER_DISCOUNT_AUTOMATICALLY_UPDATED',
  OrderDiscountDeleted = 'ORDER_DISCOUNT_DELETED',
  OrderDiscountUpdated = 'ORDER_DISCOUNT_UPDATED',
  OrderFullyPaid = 'ORDER_FULLY_PAID',
  OrderLineDiscountRemoved = 'ORDER_LINE_DISCOUNT_REMOVED',
  OrderLineDiscountUpdated = 'ORDER_LINE_DISCOUNT_UPDATED',
  OrderLineProductDeleted = 'ORDER_LINE_PRODUCT_DELETED',
  OrderLineVariantDeleted = 'ORDER_LINE_VARIANT_DELETED',
  OrderMarkedAsPaid = 'ORDER_MARKED_AS_PAID',
  OrderReplacementCreated = 'ORDER_REPLACEMENT_CREATED',
  Other = 'OTHER',
  OversoldItems = 'OVERSOLD_ITEMS',
  PaymentAuthorized = 'PAYMENT_AUTHORIZED',
  PaymentCaptured = 'PAYMENT_CAPTURED',
  PaymentFailed = 'PAYMENT_FAILED',
  PaymentRefunded = 'PAYMENT_REFUNDED',
  PaymentVoided = 'PAYMENT_VOIDED',
  Placed = 'PLACED',
  PlacedFromDraft = 'PLACED_FROM_DRAFT',
  RemovedProducts = 'REMOVED_PRODUCTS',
  TrackingUpdated = 'TRACKING_UPDATED',
  UpdatedAddress = 'UPDATED_ADDRESS'
}

export type OrderFilterInput = {
  channels?: InputMaybe<Array<Scalars['ID']>>;
  created?: InputMaybe<DateRangeInput>;
  customer?: InputMaybe<Scalars['String']>;
  giftCardBought?: InputMaybe<Scalars['Boolean']>;
  giftCardUsed?: InputMaybe<Scalars['Boolean']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  isClickAndCollect?: InputMaybe<Scalars['Boolean']>;
  isPreorder?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  paymentStatus?: InputMaybe<Array<PaymentChargeStatusEnum>>;
  search?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Array<OrderStatusFilter>>;
  updatedAt?: InputMaybe<DateTimeRangeInput>;
};

/** Creates new fulfillments for an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderFulfill = {
  __typename?: 'OrderFulfill';
  errors: Array<OrderError>;
  /** List of created fulfillments. */
  fulfillments?: Maybe<Array<Fulfillment>>;
  /** Fulfilled order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderFulfillInput = {
  /** If true, then allow proceed fulfillment when stock is exceeded. */
  allowStockToBeExceeded?: InputMaybe<Scalars['Boolean']>;
  /** List of items informing how to fulfill the order. */
  lines: Array<OrderFulfillLineInput>;
  /** If true, send an email notification to the customer. */
  notifyCustomer?: InputMaybe<Scalars['Boolean']>;
};

export type OrderFulfillLineInput = {
  /** The ID of the order line. */
  orderLineId?: InputMaybe<Scalars['ID']>;
  /** List of stock items to create. */
  stocks: Array<OrderFulfillStockInput>;
};

export type OrderFulfillStockInput = {
  /** The number of line items to be fulfilled from given warehouse. */
  quantity: Scalars['Int'];
  /** ID of the warehouse from which the item will be fulfilled. */
  warehouse: Scalars['ID'];
};

export type OrderFulfilled = {
  __typename?: 'OrderFulfilled';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

export type OrderFullyPaid = {
  __typename?: 'OrderFullyPaid';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

/** Represents order line of particular order. */
export type OrderLine = Node & {
  __typename?: 'OrderLine';
  /** List of allocations across warehouses. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  allocations?: Maybe<Array<Allocation>>;
  digitalContentUrl?: Maybe<DigitalContentUrl>;
  id: Scalars['ID'];
  isShippingRequired: Scalars['Boolean'];
  productName: Scalars['String'];
  productSku?: Maybe<Scalars['String']>;
  productVariantId?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
  quantityFulfilled: Scalars['Int'];
  /** Added in Saleor 3.1. A quantity of items remaining to be fulfilled. */
  quantityToFulfill: Scalars['Int'];
  taxRate: Scalars['Float'];
  /** The main thumbnail for the ordered product. */
  thumbnail?: Maybe<Image>;
  /** Price of the order line. */
  totalPrice: TaxedMoney;
  /** Product name in the customer's language */
  translatedProductName: Scalars['String'];
  /** Variant name in the customer's language */
  translatedVariantName: Scalars['String'];
  /** Price of the single item in the order line without applied an order line discount. */
  undiscountedUnitPrice: TaxedMoney;
  /** The discount applied to the single order line. */
  unitDiscount: Money;
  unitDiscountReason?: Maybe<Scalars['String']>;
  /** Type of the discount: fixed or percent */
  unitDiscountType?: Maybe<DiscountValueTypeEnum>;
  /** Value of the discount. Can store fixed value or percent value */
  unitDiscountValue: Scalars['PositiveDecimal'];
  /** Price of the single item in the order line. */
  unitPrice: TaxedMoney;
  /** A purchased product variant. Note: this field may be null if the variant has been removed from stock at all. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  variant?: Maybe<ProductVariant>;
  variantName: Scalars['String'];
};


/** Represents order line of particular order. */
export type OrderLineThumbnailArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

export type OrderLineCreateInput = {
  /** Number of variant items ordered. */
  quantity: Scalars['Int'];
  /** Product variant ID. */
  variantId: Scalars['ID'];
};

/** Deletes an order line from an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderLineDelete = {
  __typename?: 'OrderLineDelete';
  errors: Array<OrderError>;
  /** A related order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** An order line that was deleted. */
  orderLine?: Maybe<OrderLine>;
};

/** Remove discount applied to the order line. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderLineDiscountRemove = {
  __typename?: 'OrderLineDiscountRemove';
  errors: Array<OrderError>;
  /** Order which is related to line which has removed discount. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** Order line which has removed discount. */
  orderLine?: Maybe<OrderLine>;
};

/** Update discount for the order line. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderLineDiscountUpdate = {
  __typename?: 'OrderLineDiscountUpdate';
  errors: Array<OrderError>;
  /** Order which is related to the discounted line. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** Order line which has been discounted. */
  orderLine?: Maybe<OrderLine>;
};

export type OrderLineInput = {
  /** Number of variant items ordered. */
  quantity: Scalars['Int'];
};

/** Updates an order line of an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderLineUpdate = {
  __typename?: 'OrderLineUpdate';
  errors: Array<OrderError>;
  /** Related order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  orderLine?: Maybe<OrderLine>;
};

/** Create order lines for an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderLinesCreate = {
  __typename?: 'OrderLinesCreate';
  errors: Array<OrderError>;
  /** Related order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
  /** List of added order lines. */
  orderLines?: Maybe<Array<OrderLine>>;
};

/** Mark order as manually paid. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderMarkAsPaid = {
  __typename?: 'OrderMarkAsPaid';
  errors: Array<OrderError>;
  /** Order marked as paid. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** An enumeration. */
export enum OrderOriginEnum {
  Checkout = 'CHECKOUT',
  Draft = 'DRAFT',
  Reissue = 'REISSUE'
}

/** Refund an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderRefund = {
  __typename?: 'OrderRefund';
  errors: Array<OrderError>;
  /** A refunded order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderRefundFulfillmentLineInput = {
  /** The ID of the fulfillment line to refund. */
  fulfillmentLineId: Scalars['ID'];
  /** The number of items to be refunded. */
  quantity: Scalars['Int'];
};

export type OrderRefundLineInput = {
  /** The ID of the order line to refund. */
  orderLineId: Scalars['ID'];
  /** The number of items to be refunded. */
  quantity: Scalars['Int'];
};

export type OrderRefundProductsInput = {
  /** The total amount of refund when the value is provided manually. */
  amountToRefund?: InputMaybe<Scalars['PositiveDecimal']>;
  /** List of fulfilled lines to refund. */
  fulfillmentLines?: InputMaybe<Array<OrderRefundFulfillmentLineInput>>;
  /** If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored. */
  includeShippingCosts?: InputMaybe<Scalars['Boolean']>;
  /** List of unfulfilled lines to refund. */
  orderLines?: InputMaybe<Array<OrderRefundLineInput>>;
};

export type OrderReturnFulfillmentLineInput = {
  /** The ID of the fulfillment line to return. */
  fulfillmentLineId: Scalars['ID'];
  /** The number of items to be returned. */
  quantity: Scalars['Int'];
  /** Determines, if the line should be added to replace order. */
  replace?: InputMaybe<Scalars['Boolean']>;
};

export type OrderReturnLineInput = {
  /** The ID of the order line to return. */
  orderLineId: Scalars['ID'];
  /** The number of items to be returned. */
  quantity: Scalars['Int'];
  /** Determines, if the line should be added to replace order. */
  replace?: InputMaybe<Scalars['Boolean']>;
};

export type OrderReturnProductsInput = {
  /** The total amount of refund when the value is provided manually. */
  amountToRefund?: InputMaybe<Scalars['PositiveDecimal']>;
  /** List of fulfilled lines to return. */
  fulfillmentLines?: InputMaybe<Array<OrderReturnFulfillmentLineInput>>;
  /** If true, Saleor will refund shipping costs. If amountToRefund is providedincludeShippingCosts will be ignored. */
  includeShippingCosts?: InputMaybe<Scalars['Boolean']>;
  /** List of unfulfilled lines to return. */
  orderLines?: InputMaybe<Array<OrderReturnLineInput>>;
  /** If true, Saleor will call refund action for all lines. */
  refund?: InputMaybe<Scalars['Boolean']>;
};

/** Order related settings from site settings. */
export type OrderSettings = {
  __typename?: 'OrderSettings';
  automaticallyConfirmAllNewOrders: Scalars['Boolean'];
  automaticallyFulfillNonShippableGiftCard: Scalars['Boolean'];
};

export type OrderSettingsError = {
  __typename?: 'OrderSettingsError';
  /** The error code. */
  code: OrderSettingsErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum OrderSettingsErrorCode {
  Invalid = 'INVALID'
}

/** Update shop order settings. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderSettingsUpdate = {
  __typename?: 'OrderSettingsUpdate';
  errors: Array<OrderSettingsError>;
  /** Order settings. */
  orderSettings?: Maybe<OrderSettings>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderSettingsErrors: Array<OrderSettingsError>;
};

export type OrderSettingsUpdateInput = {
  /** When disabled, all new orders from checkout will be marked as unconfirmed. When enabled orders from checkout will become unfulfilled immediately. */
  automaticallyConfirmAllNewOrders?: InputMaybe<Scalars['Boolean']>;
  /** When enabled, all non-shippable gift card orders will be fulfilled automatically. */
  automaticallyFulfillNonShippableGiftCard?: InputMaybe<Scalars['Boolean']>;
};

export enum OrderSortField {
  /**
   * Sort orders by creation date.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  CreatedAt = 'CREATED_AT',
  /**
   * Sort orders by creation date.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  CreationDate = 'CREATION_DATE',
  /** Sort orders by customer. */
  Customer = 'CUSTOMER',
  /** Sort orders by fulfillment status. */
  FulfillmentStatus = 'FULFILLMENT_STATUS',
  /** Sort orders by last modified at. */
  LastModifiedAt = 'LAST_MODIFIED_AT',
  /** Sort orders by number. */
  Number = 'NUMBER',
  /** Sort orders by payment. */
  Payment = 'PAYMENT'
}

export type OrderSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort orders by the selected field. */
  field: OrderSortField;
};

/** An enumeration. */
export enum OrderStatus {
  Canceled = 'CANCELED',
  Draft = 'DRAFT',
  Fulfilled = 'FULFILLED',
  PartiallyFulfilled = 'PARTIALLY_FULFILLED',
  PartiallyReturned = 'PARTIALLY_RETURNED',
  Returned = 'RETURNED',
  Unconfirmed = 'UNCONFIRMED',
  Unfulfilled = 'UNFULFILLED'
}

export enum OrderStatusFilter {
  Canceled = 'CANCELED',
  Fulfilled = 'FULFILLED',
  PartiallyFulfilled = 'PARTIALLY_FULFILLED',
  ReadyToCapture = 'READY_TO_CAPTURE',
  ReadyToFulfill = 'READY_TO_FULFILL',
  Unconfirmed = 'UNCONFIRMED',
  Unfulfilled = 'UNFULFILLED'
}

/** Updates an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderUpdate = {
  __typename?: 'OrderUpdate';
  errors: Array<OrderError>;
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderUpdateInput = {
  /** Billing address of the customer. */
  billingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  shippingAddress?: InputMaybe<AddressInput>;
  /** Email address of the customer. */
  userEmail?: InputMaybe<Scalars['String']>;
};

/** Updates a shipping method of the order. Requires shipping method ID to update, when null is passed then currently assigned shipping method is removed. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderUpdateShipping = {
  __typename?: 'OrderUpdateShipping';
  errors: Array<OrderError>;
  /** Order with updated shipping method. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

export type OrderUpdateShippingInput = {
  /** ID of the selected shipping method, pass null to remove currently assigned shipping method. */
  shippingMethod?: InputMaybe<Scalars['ID']>;
};

export type OrderUpdated = {
  __typename?: 'OrderUpdated';
  /** Added in Saleor 3.2. Look up an order. Note: this feature is in a preview state and can be subject to changes at later point. */
  order?: Maybe<Order>;
};

/** Void an order. Requires one of the following permissions: MANAGE_ORDERS. */
export type OrderVoid = {
  __typename?: 'OrderVoid';
  errors: Array<OrderError>;
  /** A voided order. */
  order?: Maybe<Order>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  orderErrors: Array<OrderError>;
};

/** A static page that can be manually added by a shop operator through the dashboard. */
export type Page = Node & ObjectWithMetadata & {
  __typename?: 'Page';
  /** List of attributes assigned to this product. */
  attributes: Array<SelectedAttribute>;
  /** Content of the page (JSON). */
  content?: Maybe<Scalars['JSONString']>;
  /**
   * Content of the page (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `content` field instead.
   */
  contentJson: Scalars['JSONString'];
  created: Scalars['DateTime'];
  id: Scalars['ID'];
  isPublished: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  pageType: PageType;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** @deprecated This field will be removed in Saleor 4.0. Use the `publishedAt` field to fetch the publication date. */
  publicationDate?: Maybe<Scalars['Date']>;
  /** Added in Saleor 3.3. The page publication date. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  slug: Scalars['String'];
  title: Scalars['String'];
  /** Returns translated page fields for the given language code. */
  translation?: Maybe<PageTranslation>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageMetafieldArgs = {
  key: Scalars['String'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PagePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PagePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** A static page that can be manually added by a shop operator through the dashboard. */
export type PageTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Assign attributes to a given page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageAttributeAssign = {
  __typename?: 'PageAttributeAssign';
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
  /** The updated page type. */
  pageType?: Maybe<PageType>;
};

/** Unassign attributes from a given page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageAttributeUnassign = {
  __typename?: 'PageAttributeUnassign';
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
  /** The updated page type. */
  pageType?: Maybe<PageType>;
};

/** Deletes pages. Requires one of the following permissions: MANAGE_PAGES. */
export type PageBulkDelete = {
  __typename?: 'PageBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

/** Publish pages. Requires one of the following permissions: MANAGE_PAGES. */
export type PageBulkPublish = {
  __typename?: 'PageBulkPublish';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageCountableConnection = {
  __typename?: 'PageCountableConnection';
  edges: Array<PageCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type PageCountableEdge = {
  __typename?: 'PageCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Page;
};

/** Creates a new page. Requires one of the following permissions: MANAGE_PAGES. */
export type PageCreate = {
  __typename?: 'PageCreate';
  errors: Array<PageError>;
  page?: Maybe<Page>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageCreateInput = {
  /** List of attributes. */
  attributes?: InputMaybe<Array<AttributeValueInput>>;
  /** Page content in JSON format. */
  content?: InputMaybe<Scalars['JSONString']>;
  /** Determines if page is visible in the storefront. */
  isPublished?: InputMaybe<Scalars['Boolean']>;
  /** ID of the page type that page belongs to. */
  pageType: Scalars['ID'];
  /**
   * Publication date. ISO 8601 standard.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `publishedAt` field instead.
   */
  publicationDate?: InputMaybe<Scalars['String']>;
  /** Added in Saleor 3.3. Publication date time. ISO 8601 standard. */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Page internal name. */
  slug?: InputMaybe<Scalars['String']>;
  /** Page title. */
  title?: InputMaybe<Scalars['String']>;
};

export type PageCreated = {
  __typename?: 'PageCreated';
  /** Added in Saleor 3.2. Look up a page. Note: this feature is in a preview state and can be subject to changes at later point. */
  page?: Maybe<Page>;
};

/** Deletes a page. Requires one of the following permissions: MANAGE_PAGES. */
export type PageDelete = {
  __typename?: 'PageDelete';
  errors: Array<PageError>;
  page?: Maybe<Page>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageDeleted = {
  __typename?: 'PageDeleted';
  /** Added in Saleor 3.2. Look up a page. Note: this feature is in a preview state and can be subject to changes at later point. */
  page?: Maybe<Page>;
};

export type PageError = {
  __typename?: 'PageError';
  /** List of attributes IDs which causes the error. */
  attributes?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: PageErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum PageErrorCode {
  AttributeAlreadyAssigned = 'ATTRIBUTE_ALREADY_ASSIGNED',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type PageFilterInput = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  pageTypes?: InputMaybe<Array<Scalars['ID']>>;
  search?: InputMaybe<Scalars['String']>;
};

/** The Relay compliant `PageInfo` type, containing data necessary to paginate this connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type PageInput = {
  /** List of attributes. */
  attributes?: InputMaybe<Array<AttributeValueInput>>;
  /** Page content in JSON format. */
  content?: InputMaybe<Scalars['JSONString']>;
  /** Determines if page is visible in the storefront. */
  isPublished?: InputMaybe<Scalars['Boolean']>;
  /**
   * Publication date. ISO 8601 standard.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `publishedAt` field instead.
   */
  publicationDate?: InputMaybe<Scalars['String']>;
  /** Added in Saleor 3.3. Publication date time. ISO 8601 standard. */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Page internal name. */
  slug?: InputMaybe<Scalars['String']>;
  /** Page title. */
  title?: InputMaybe<Scalars['String']>;
};

/** Reorder page attribute values. Requires one of the following permissions: MANAGE_PAGES. */
export type PageReorderAttributeValues = {
  __typename?: 'PageReorderAttributeValues';
  errors: Array<PageError>;
  /** Page from which attribute values are reordered. */
  page?: Maybe<Page>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export enum PageSortField {
  /** Sort pages by creation date. */
  CreationDate = 'CREATION_DATE',
  /**
   * Sort pages by publication date.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  PublicationDate = 'PUBLICATION_DATE',
  /**
   * Sort pages by publication date.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0.
   */
  PublishedAt = 'PUBLISHED_AT',
  /** Sort pages by slug. */
  Slug = 'SLUG',
  /** Sort pages by title. */
  Title = 'TITLE',
  /** Sort pages by visibility. */
  Visibility = 'VISIBILITY'
}

export type PageSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort pages by the selected field. */
  field: PageSortField;
};

export type PageTranslatableContent = Node & {
  __typename?: 'PageTranslatableContent';
  /** List of page content attribute values that can be translated. */
  attributeValues: Array<AttributeValueTranslatableContent>;
  content?: Maybe<Scalars['JSONString']>;
  /**
   * Content of the page (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `content` field instead.
   */
  contentJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /**
   * A static page that can be manually added by a shop operator through the dashboard.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  page?: Maybe<Page>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  /** Returns translated page fields for the given language code. */
  translation?: Maybe<PageTranslation>;
};


export type PageTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a page. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type PageTranslate = {
  __typename?: 'PageTranslate';
  errors: Array<TranslationError>;
  page?: Maybe<PageTranslatableContent>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type PageTranslation = Node & {
  __typename?: 'PageTranslation';
  content?: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the page (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `content` field instead.
   */
  contentJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
};

export type PageTranslationInput = {
  content?: InputMaybe<Scalars['JSONString']>;
  seoDescription?: InputMaybe<Scalars['String']>;
  seoTitle?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
};

/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageType = Node & ObjectWithMetadata & {
  __typename?: 'PageType';
  /** Page attributes of that page type. */
  attributes?: Maybe<Array<Attribute>>;
  /** Attributes that can be assigned to the page type. Requires one of the following permissions: MANAGE_PAGES. */
  availableAttributes?: Maybe<AttributeCountableConnection>;
  /** Whether page type has pages assigned. Requires one of the following permissions: MANAGE_PAGES. */
  hasPages?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  slug: Scalars['String'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeAvailableAttributesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AttributeFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypeMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of page. It defines what attributes are available to pages of this type. */
export type PageTypePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Delete page types. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageTypeBulkDelete = {
  __typename?: 'PageTypeBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageTypeCountableConnection = {
  __typename?: 'PageTypeCountableConnection';
  edges: Array<PageTypeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type PageTypeCountableEdge = {
  __typename?: 'PageTypeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: PageType;
};

/** Create a new page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageTypeCreate = {
  __typename?: 'PageTypeCreate';
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
  pageType?: Maybe<PageType>;
};

export type PageTypeCreateInput = {
  /** List of attribute IDs to be assigned to the page type. */
  addAttributes?: InputMaybe<Array<Scalars['ID']>>;
  /** Name of the page type. */
  name?: InputMaybe<Scalars['String']>;
  /** Page type slug. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Delete a page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageTypeDelete = {
  __typename?: 'PageTypeDelete';
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
  pageType?: Maybe<PageType>;
};

export type PageTypeFilterInput = {
  search?: InputMaybe<Scalars['String']>;
};

/** Reorder the attributes of a page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageTypeReorderAttributes = {
  __typename?: 'PageTypeReorderAttributes';
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
  /** Page type from which attributes are reordered. */
  pageType?: Maybe<PageType>;
};

export enum PageTypeSortField {
  /** Sort page types by name. */
  Name = 'NAME',
  /** Sort page types by slug. */
  Slug = 'SLUG'
}

export type PageTypeSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort page types by the selected field. */
  field: PageTypeSortField;
};

/** Update page type. Requires one of the following permissions: MANAGE_PAGE_TYPES_AND_ATTRIBUTES. */
export type PageTypeUpdate = {
  __typename?: 'PageTypeUpdate';
  errors: Array<PageError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
  pageType?: Maybe<PageType>;
};

export type PageTypeUpdateInput = {
  /** List of attribute IDs to be assigned to the page type. */
  addAttributes?: InputMaybe<Array<Scalars['ID']>>;
  /** Name of the page type. */
  name?: InputMaybe<Scalars['String']>;
  /** List of attribute IDs to be assigned to the page type. */
  removeAttributes?: InputMaybe<Array<Scalars['ID']>>;
  /** Page type slug. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Updates an existing page. Requires one of the following permissions: MANAGE_PAGES. */
export type PageUpdate = {
  __typename?: 'PageUpdate';
  errors: Array<PageError>;
  page?: Maybe<Page>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pageErrors: Array<PageError>;
};

export type PageUpdated = {
  __typename?: 'PageUpdated';
  /** Added in Saleor 3.2. Look up a page. Note: this feature is in a preview state and can be subject to changes at later point. */
  page?: Maybe<Page>;
};

/** Change the password of the logged in user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type PasswordChange = {
  __typename?: 'PasswordChange';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** A user instance with a new password. */
  user?: Maybe<User>;
};

/** Represents a payment of a given type. */
export type Payment = Node & ObjectWithMetadata & {
  __typename?: 'Payment';
  /** List of actions that can be performed in the current state of a payment. Requires one of the following permissions: MANAGE_ORDERS. */
  actions: Array<OrderAction>;
  /** Maximum amount of money that can be captured. Requires one of the following permissions: MANAGE_ORDERS. */
  availableCaptureAmount?: Maybe<Money>;
  /** Maximum amount of money that can be refunded. Requires one of the following permissions: MANAGE_ORDERS. */
  availableRefundAmount?: Maybe<Money>;
  /** Total amount captured for this payment. */
  capturedAmount?: Maybe<Money>;
  /** Internal payment status. */
  chargeStatus: PaymentChargeStatusEnum;
  checkout?: Maybe<Checkout>;
  created: Scalars['DateTime'];
  /** The details of the card used for this payment. */
  creditCard?: Maybe<CreditCard>;
  /** IP address of the user who created the payment. Requires one of the following permissions: MANAGE_ORDERS. */
  customerIpAddress?: Maybe<Scalars['String']>;
  gateway: Scalars['String'];
  id: Scalars['ID'];
  isActive: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  modified: Scalars['DateTime'];
  order?: Maybe<Order>;
  paymentMethodType: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  token: Scalars['String'];
  /** Total amount of the payment. */
  total?: Maybe<Money>;
  /** List of all transactions within this payment. Requires one of the following permissions: MANAGE_ORDERS. */
  transactions?: Maybe<Array<Transaction>>;
};


/** Represents a payment of a given type. */
export type PaymentMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a payment of a given type. */
export type PaymentMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a payment of a given type. */
export type PaymentPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a payment of a given type. */
export type PaymentPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Captures the authorized payment amount. Requires one of the following permissions: MANAGE_ORDERS. */
export type PaymentCapture = {
  __typename?: 'PaymentCapture';
  errors: Array<PaymentError>;
  /** Updated payment. */
  payment?: Maybe<Payment>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** An enumeration. */
export enum PaymentChargeStatusEnum {
  Cancelled = 'CANCELLED',
  FullyCharged = 'FULLY_CHARGED',
  FullyRefunded = 'FULLY_REFUNDED',
  NotCharged = 'NOT_CHARGED',
  PartiallyCharged = 'PARTIALLY_CHARGED',
  PartiallyRefunded = 'PARTIALLY_REFUNDED',
  Pending = 'PENDING',
  Refused = 'REFUSED'
}

/** Check payment balance. */
export type PaymentCheckBalance = {
  __typename?: 'PaymentCheckBalance';
  /** Response from the gateway. */
  data?: Maybe<Scalars['JSONString']>;
  errors: Array<PaymentError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

export type PaymentCheckBalanceInput = {
  /** Information about card. */
  card: CardInput;
  /** Slug of a channel for which the data should be returned. */
  channel: Scalars['String'];
  /** An ID of a payment gateway to check. */
  gatewayId: Scalars['String'];
  /** Payment method name. */
  method: Scalars['String'];
};

export type PaymentCountableConnection = {
  __typename?: 'PaymentCountableConnection';
  edges: Array<PaymentCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type PaymentCountableEdge = {
  __typename?: 'PaymentCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Payment;
};

export type PaymentError = {
  __typename?: 'PaymentError';
  /** The error code. */
  code: PaymentErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of varint IDs which causes the error. */
  variants?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum PaymentErrorCode {
  BalanceCheckError = 'BALANCE_CHECK_ERROR',
  BillingAddressNotSet = 'BILLING_ADDRESS_NOT_SET',
  ChannelInactive = 'CHANNEL_INACTIVE',
  CheckoutEmailNotSet = 'CHECKOUT_EMAIL_NOT_SET',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  InvalidShippingMethod = 'INVALID_SHIPPING_METHOD',
  NotFound = 'NOT_FOUND',
  NotSupportedGateway = 'NOT_SUPPORTED_GATEWAY',
  NoCheckoutLines = 'NO_CHECKOUT_LINES',
  PartialPaymentNotAllowed = 'PARTIAL_PAYMENT_NOT_ALLOWED',
  PaymentError = 'PAYMENT_ERROR',
  Required = 'REQUIRED',
  ShippingAddressNotSet = 'SHIPPING_ADDRESS_NOT_SET',
  ShippingMethodNotSet = 'SHIPPING_METHOD_NOT_SET',
  UnavailableVariantInChannel = 'UNAVAILABLE_VARIANT_IN_CHANNEL',
  Unique = 'UNIQUE'
}

export type PaymentFilterInput = {
  checkouts?: InputMaybe<Array<Scalars['ID']>>;
};

/** Available payment gateway backend with configuration necessary to setup client. */
export type PaymentGateway = {
  __typename?: 'PaymentGateway';
  /** Payment gateway client configuration. */
  config: Array<GatewayConfigLine>;
  /** Payment gateway supported currencies. */
  currencies: Array<Scalars['String']>;
  /** Payment gateway ID. */
  id: Scalars['ID'];
  /** Payment gateway name. */
  name: Scalars['String'];
};

/** Initializes payment process when it is required by gateway. */
export type PaymentInitialize = {
  __typename?: 'PaymentInitialize';
  errors: Array<PaymentError>;
  initializedPayment?: Maybe<PaymentInitialized>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Server-side data generated by a payment gateway. Optional step when the payment provider requires an additional action to initialize payment session. */
export type PaymentInitialized = {
  __typename?: 'PaymentInitialized';
  /** Initialized data by gateway. */
  data?: Maybe<Scalars['JSONString']>;
  /** ID of a payment gateway. */
  gateway: Scalars['String'];
  /** Payment gateway name. */
  name: Scalars['String'];
};

export type PaymentInput = {
  /** Total amount of the transaction, including all taxes and discounts. If no amount is provided, the checkout total will be used. */
  amount?: InputMaybe<Scalars['PositiveDecimal']>;
  /** A gateway to use with that payment. */
  gateway: Scalars['String'];
  /** Added in Saleor 3.1. User public metadata. */
  metadata?: InputMaybe<Array<MetadataInput>>;
  /** URL of a storefront view where user should be redirected after requiring additional actions. Payment with additional actions will not be finished if this field is not provided. */
  returnUrl?: InputMaybe<Scalars['String']>;
  /** Added in Saleor 3.1. Payment store type. */
  storePaymentMethod?: InputMaybe<StorePaymentMethodEnum>;
  /** Client-side generated payment token, representing customer's billing data in a secure manner. */
  token?: InputMaybe<Scalars['String']>;
};

/** Refunds the captured payment amount. Requires one of the following permissions: MANAGE_ORDERS. */
export type PaymentRefund = {
  __typename?: 'PaymentRefund';
  errors: Array<PaymentError>;
  /** Updated payment. */
  payment?: Maybe<Payment>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Represents a payment source stored for user in payment gateway, such as credit card. */
export type PaymentSource = {
  __typename?: 'PaymentSource';
  /** Stored credit card details if available. */
  creditCardInfo?: Maybe<CreditCard>;
  /** Payment gateway name. */
  gateway: Scalars['String'];
  /** Added in Saleor 3.1. List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /** ID of stored payment method. */
  paymentMethodId?: Maybe<Scalars['String']>;
};

/** Voids the authorized payment. Requires one of the following permissions: MANAGE_ORDERS. */
export type PaymentVoid = {
  __typename?: 'PaymentVoid';
  errors: Array<PaymentError>;
  /** Updated payment. */
  payment?: Maybe<Payment>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  paymentErrors: Array<PaymentError>;
};

/** Represents a permission object in a friendly form. */
export type Permission = {
  __typename?: 'Permission';
  /** Internal code for permission. */
  code: PermissionEnum;
  /** Describe action(s) allowed to do by permission. */
  name: Scalars['String'];
};

/** An enumeration. */
export enum PermissionEnum {
  HandleCheckouts = 'HANDLE_CHECKOUTS',
  HandlePayments = 'HANDLE_PAYMENTS',
  ImpersonateUser = 'IMPERSONATE_USER',
  ManageApps = 'MANAGE_APPS',
  ManageChannels = 'MANAGE_CHANNELS',
  ManageCheckouts = 'MANAGE_CHECKOUTS',
  ManageDiscounts = 'MANAGE_DISCOUNTS',
  ManageGiftCard = 'MANAGE_GIFT_CARD',
  ManageMenus = 'MANAGE_MENUS',
  ManageOrders = 'MANAGE_ORDERS',
  ManagePages = 'MANAGE_PAGES',
  ManagePageTypesAndAttributes = 'MANAGE_PAGE_TYPES_AND_ATTRIBUTES',
  ManagePlugins = 'MANAGE_PLUGINS',
  ManageProducts = 'MANAGE_PRODUCTS',
  ManageProductTypesAndAttributes = 'MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES',
  ManageSettings = 'MANAGE_SETTINGS',
  ManageShipping = 'MANAGE_SHIPPING',
  ManageStaff = 'MANAGE_STAFF',
  ManageTranslations = 'MANAGE_TRANSLATIONS',
  ManageUsers = 'MANAGE_USERS'
}

/** Create new permission group. Requires one of the following permissions: MANAGE_STAFF. */
export type PermissionGroupCreate = {
  __typename?: 'PermissionGroupCreate';
  errors: Array<PermissionGroupError>;
  group?: Maybe<Group>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  permissionGroupErrors: Array<PermissionGroupError>;
};

export type PermissionGroupCreateInput = {
  /** List of permission code names to assign to this group. */
  addPermissions?: InputMaybe<Array<PermissionEnum>>;
  /** List of users to assign to this group. */
  addUsers?: InputMaybe<Array<Scalars['ID']>>;
  /** Group name. */
  name: Scalars['String'];
};

/** Delete permission group. Requires one of the following permissions: MANAGE_STAFF. */
export type PermissionGroupDelete = {
  __typename?: 'PermissionGroupDelete';
  errors: Array<PermissionGroupError>;
  group?: Maybe<Group>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  permissionGroupErrors: Array<PermissionGroupError>;
};

export type PermissionGroupError = {
  __typename?: 'PermissionGroupError';
  /** The error code. */
  code: PermissionGroupErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of permissions which causes the error. */
  permissions?: Maybe<Array<PermissionEnum>>;
  /** List of user IDs which causes the error. */
  users?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum PermissionGroupErrorCode {
  AssignNonStaffMember = 'ASSIGN_NON_STAFF_MEMBER',
  CannotRemoveFromLastGroup = 'CANNOT_REMOVE_FROM_LAST_GROUP',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  LeftNotManageablePermission = 'LEFT_NOT_MANAGEABLE_PERMISSION',
  OutOfScopePermission = 'OUT_OF_SCOPE_PERMISSION',
  OutOfScopeUser = 'OUT_OF_SCOPE_USER',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type PermissionGroupFilterInput = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  search?: InputMaybe<Scalars['String']>;
};

export enum PermissionGroupSortField {
  /** Sort permission group accounts by name. */
  Name = 'NAME'
}

export type PermissionGroupSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort permission group by the selected field. */
  field: PermissionGroupSortField;
};

/** Update permission group. Requires one of the following permissions: MANAGE_STAFF. */
export type PermissionGroupUpdate = {
  __typename?: 'PermissionGroupUpdate';
  errors: Array<PermissionGroupError>;
  group?: Maybe<Group>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  permissionGroupErrors: Array<PermissionGroupError>;
};

export type PermissionGroupUpdateInput = {
  /** List of permission code names to assign to this group. */
  addPermissions?: InputMaybe<Array<PermissionEnum>>;
  /** List of users to assign to this group. */
  addUsers?: InputMaybe<Array<Scalars['ID']>>;
  /** Group name. */
  name?: InputMaybe<Scalars['String']>;
  /** List of permission code names to unassign from this group. */
  removePermissions?: InputMaybe<Array<PermissionEnum>>;
  /** List of users to unassign from this group. */
  removeUsers?: InputMaybe<Array<Scalars['ID']>>;
};

/** Plugin. */
export type Plugin = {
  __typename?: 'Plugin';
  /** Channel-specific plugin configuration. */
  channelConfigurations: Array<PluginConfiguration>;
  /** Description of the plugin. */
  description: Scalars['String'];
  /** Global configuration of the plugin (not channel-specific). */
  globalConfiguration?: Maybe<PluginConfiguration>;
  /** Identifier of the plugin. */
  id: Scalars['ID'];
  /** Name of the plugin. */
  name: Scalars['String'];
};

/** Stores information about a configuration of plugin. */
export type PluginConfiguration = {
  __typename?: 'PluginConfiguration';
  /** Determines if plugin is active or not. */
  active: Scalars['Boolean'];
  /** The channel to which the plugin configuration is assigned to. */
  channel?: Maybe<Channel>;
  /** Configuration of the plugin. */
  configuration?: Maybe<Array<ConfigurationItem>>;
};

export enum PluginConfigurationType {
  Global = 'GLOBAL',
  PerChannel = 'PER_CHANNEL'
}

export type PluginCountableConnection = {
  __typename?: 'PluginCountableConnection';
  edges: Array<PluginCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type PluginCountableEdge = {
  __typename?: 'PluginCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Plugin;
};

export type PluginError = {
  __typename?: 'PluginError';
  /** The error code. */
  code: PluginErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum PluginErrorCode {
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  PluginMisconfigured = 'PLUGIN_MISCONFIGURED',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type PluginFilterInput = {
  search?: InputMaybe<Scalars['String']>;
  statusInChannels?: InputMaybe<PluginStatusInChannelsInput>;
  type?: InputMaybe<PluginConfigurationType>;
};

export enum PluginSortField {
  IsActive = 'IS_ACTIVE',
  Name = 'NAME'
}

export type PluginSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort plugins by the selected field. */
  field: PluginSortField;
};

export type PluginStatusInChannelsInput = {
  active: Scalars['Boolean'];
  channels: Array<Scalars['ID']>;
};

/** Update plugin configuration. Requires one of the following permissions: MANAGE_PLUGINS. */
export type PluginUpdate = {
  __typename?: 'PluginUpdate';
  errors: Array<PluginError>;
  plugin?: Maybe<Plugin>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  pluginsErrors: Array<PluginError>;
};

export type PluginUpdateInput = {
  /** Indicates whether the plugin should be enabled. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Configuration of the plugin. */
  configuration?: InputMaybe<Array<ConfigurationItemInput>>;
};

/** An enumeration. */
export enum PostalCodeRuleInclusionTypeEnum {
  Exclude = 'EXCLUDE',
  Include = 'INCLUDE'
}

/** Represents preorder settings for product variant. */
export type PreorderData = {
  __typename?: 'PreorderData';
  /** Preorder end date. */
  endDate?: Maybe<Scalars['DateTime']>;
  /** Total number of sold product variant during preorder. Requires one of the following permissions: MANAGE_PRODUCTS. */
  globalSoldUnits: Scalars['Int'];
  /** The global preorder threshold for product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  globalThreshold?: Maybe<Scalars['Int']>;
};

export type PreorderSettingsInput = {
  /** The end date for preorder. */
  endDate?: InputMaybe<Scalars['DateTime']>;
  /** The global threshold for preorder variant. */
  globalThreshold?: InputMaybe<Scalars['Int']>;
};

/** Represents preorder variant data for channel. */
export type PreorderThreshold = {
  __typename?: 'PreorderThreshold';
  /** Preorder threshold for product variant in this channel. */
  quantity?: Maybe<Scalars['Int']>;
  /** Number of sold product variant in this channel. */
  soldUnits: Scalars['Int'];
};

export type PriceInput = {
  /** Amount of money. */
  amount: Scalars['PositiveDecimal'];
  /** Currency code. */
  currency: Scalars['String'];
};

export type PriceRangeInput = {
  /** Price greater than or equal to. */
  gte?: InputMaybe<Scalars['Float']>;
  /** Price less than or equal to. */
  lte?: InputMaybe<Scalars['Float']>;
};

/** Represents an individual item for sale in the storefront. */
export type Product = Node & ObjectWithMetadata & {
  __typename?: 'Product';
  /** List of attributes assigned to this product. */
  attributes: Array<SelectedAttribute>;
  /**
   * Date when product is available for purchase.
   * @deprecated This field will be removed in Saleor 4.0. Use the `availableForPurchaseAt` field to fetch the available for purchase date.
   */
  availableForPurchase?: Maybe<Scalars['Date']>;
  /** Date when product is available for purchase. */
  availableForPurchaseAt?: Maybe<Scalars['DateTime']>;
  category?: Maybe<Category>;
  /** Channel given to retrieve this product. Also used by federation gateway to resolve this object in a federated query. */
  channel?: Maybe<Scalars['String']>;
  /** List of availability in channels for the product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  channelListings?: Maybe<Array<ProductChannelListing>>;
  chargeTaxes: Scalars['Boolean'];
  /** List of collections for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collections?: Maybe<Array<Collection>>;
  created: Scalars['DateTime'];
  defaultVariant?: Maybe<ProductVariant>;
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Description of the product (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /**
   * Get a single product image by ID.
   * @deprecated This field will be removed in Saleor 4.0. Use the `mediaById` field instead.
   */
  imageById?: Maybe<ProductImage>;
  /**
   * List of images for the product.
   * @deprecated This field will be removed in Saleor 4.0. Use the `media` field instead.
   */
  images?: Maybe<Array<ProductImage>>;
  /** Whether the product is in stock and visible or not. */
  isAvailable?: Maybe<Scalars['Boolean']>;
  /** Whether the product is available for purchase. */
  isAvailableForPurchase?: Maybe<Scalars['Boolean']>;
  /** List of media for the product. */
  media?: Maybe<Array<ProductMedia>>;
  /** Get a single product media by ID. */
  mediaById?: Maybe<ProductMedia>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** Lists the storefront product's pricing, the current price and discounts, only meant for displaying. */
  pricing?: Maybe<ProductPricingInfo>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  productType: ProductType;
  rating?: Maybe<Scalars['Float']>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  slug: Scalars['String'];
  /** A type of tax. Assigned by enabled tax gateway */
  taxType?: Maybe<TaxType>;
  /** The main thumbnail for a product. */
  thumbnail?: Maybe<Image>;
  /** Returns translated product fields for the given language code. */
  translation?: Maybe<ProductTranslation>;
  updatedAt: Scalars['DateTime'];
  /** List of variants for the product. Requires the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  variants?: Maybe<Array<ProductVariant>>;
  weight?: Maybe<Weight>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductImageByIdArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductIsAvailableArgs = {
  address?: InputMaybe<AddressInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMediaByIdArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductPricingArgs = {
  address?: InputMaybe<AddressInput>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents an individual item for sale in the storefront. */
export type ProductPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductThumbnailArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents an individual item for sale in the storefront. */
export type ProductTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Assign attributes to a given product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductAttributeAssign = {
  __typename?: 'ProductAttributeAssign';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** The updated product type. */
  productType?: Maybe<ProductType>;
};

export type ProductAttributeAssignInput = {
  /** The ID of the attribute to assign. */
  id: Scalars['ID'];
  /** The attribute type to be assigned as. */
  type: ProductAttributeType;
  /** Added in Saleor 3.1. Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']. */
  variantSelection?: InputMaybe<Scalars['Boolean']>;
};

/** Added in Saleor 3.1. Update attributes assigned to product variant for given product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductAttributeAssignmentUpdate = {
  __typename?: 'ProductAttributeAssignmentUpdate';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** The updated product type. */
  productType?: Maybe<ProductType>;
};

export type ProductAttributeAssignmentUpdateInput = {
  /** The ID of the attribute to assign. */
  id: Scalars['ID'];
  /** Added in Saleor 3.1. Whether attribute is allowed in variant selection. Allowed types are: ['dropdown', 'boolean', 'swatch', 'numeric']. */
  variantSelection: Scalars['Boolean'];
};

export enum ProductAttributeType {
  Product = 'PRODUCT',
  Variant = 'VARIANT'
}

/** Un-assign attributes from a given product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductAttributeUnassign = {
  __typename?: 'ProductAttributeUnassign';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** The updated product type. */
  productType?: Maybe<ProductType>;
};

/** Deletes products. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductBulkDelete = {
  __typename?: 'ProductBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Represents product channel listing. */
export type ProductChannelListing = Node & {
  __typename?: 'ProductChannelListing';
  /** @deprecated This field will be removed in Saleor 4.0. Use the `availableForPurchaseAt` field to fetch the available for purchase date. */
  availableForPurchase?: Maybe<Scalars['Date']>;
  /** Added in Saleor 3.3. The product available for purchase date time. */
  availableForPurchaseAt?: Maybe<Scalars['DateTime']>;
  channel: Channel;
  /** The price of the cheapest variant (including discounts). */
  discountedPrice?: Maybe<Money>;
  id: Scalars['ID'];
  /** Whether the product is available for purchase. */
  isAvailableForPurchase?: Maybe<Scalars['Boolean']>;
  isPublished: Scalars['Boolean'];
  /** Range of margin percentage value. Requires one of the following permissions: MANAGE_PRODUCTS. */
  margin?: Maybe<Margin>;
  /** Lists the storefront product's pricing, the current price and discounts, only meant for displaying. */
  pricing?: Maybe<ProductPricingInfo>;
  /** @deprecated This field will be removed in Saleor 4.0. Use the `publishedAt` field to fetch the publication date. */
  publicationDate?: Maybe<Scalars['Date']>;
  /** Added in Saleor 3.3. The product publication date time. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Purchase cost of product. Requires one of the following permissions: MANAGE_PRODUCTS. */
  purchaseCost?: Maybe<MoneyRange>;
  visibleInListings: Scalars['Boolean'];
};


/** Represents product channel listing. */
export type ProductChannelListingPricingArgs = {
  address?: InputMaybe<AddressInput>;
};

export type ProductChannelListingAddInput = {
  /** List of variants to which the channel should be assigned. */
  addVariants?: InputMaybe<Array<Scalars['ID']>>;
  /** Added in Saleor 3.3. A start date time from which a product will be available for purchase. When not set and `isAvailable` is set to True, the current day is assumed. */
  availableForPurchaseAt?: InputMaybe<Scalars['DateTime']>;
  /**
   * A start date from which a product will be available for purchase. When not set and isAvailable is set to True, the current day is assumed.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `availableForPurchaseAt` field instead.
   */
  availableForPurchaseDate?: InputMaybe<Scalars['Date']>;
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Determine if product should be available for purchase. */
  isAvailableForPurchase?: InputMaybe<Scalars['Boolean']>;
  /** Determines if object is visible to customers. */
  isPublished?: InputMaybe<Scalars['Boolean']>;
  /**
   * Publication date. ISO 8601 standard.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `publishedAt` field instead.
   */
  publicationDate?: InputMaybe<Scalars['Date']>;
  /** Added in Saleor 3.3. Publication date time. ISO 8601 standard. */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
  /** List of variants from which the channel should be unassigned. */
  removeVariants?: InputMaybe<Array<Scalars['ID']>>;
  /** Determines if product is visible in product listings (doesn't apply to product collections). */
  visibleInListings?: InputMaybe<Scalars['Boolean']>;
};

export type ProductChannelListingError = {
  __typename?: 'ProductChannelListingError';
  /** List of attributes IDs which causes the error. */
  attributes?: Maybe<Array<Scalars['ID']>>;
  /** List of channels IDs which causes the error. */
  channels?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values?: Maybe<Array<Scalars['ID']>>;
  /** List of variants IDs which causes the error. */
  variants?: Maybe<Array<Scalars['ID']>>;
};

/** Manage product's availability in channels. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductChannelListingUpdate = {
  __typename?: 'ProductChannelListingUpdate';
  errors: Array<ProductChannelListingError>;
  /** An updated product instance. */
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productChannelListingErrors: Array<ProductChannelListingError>;
};

export type ProductChannelListingUpdateInput = {
  /** List of channels from which the product should be unassigned. */
  removeChannels?: InputMaybe<Array<Scalars['ID']>>;
  /** List of channels to which the product should be assigned or updated. */
  updateChannels?: InputMaybe<Array<ProductChannelListingAddInput>>;
};

export type ProductCountableConnection = {
  __typename?: 'ProductCountableConnection';
  edges: Array<ProductCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type ProductCountableEdge = {
  __typename?: 'ProductCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Product;
};

/** Creates a new product. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductCreate = {
  __typename?: 'ProductCreate';
  errors: Array<ProductError>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductCreateInput = {
  /** List of attributes. */
  attributes?: InputMaybe<Array<AttributeValueInput>>;
  /** ID of the product's category. */
  category?: InputMaybe<Scalars['ID']>;
  /** Determine if taxes are being charged for the product. */
  chargeTaxes?: InputMaybe<Scalars['Boolean']>;
  /** List of IDs of collections that the product belongs to. */
  collections?: InputMaybe<Array<Scalars['ID']>>;
  /** Product description (JSON). */
  description?: InputMaybe<Scalars['JSONString']>;
  /** Product name. */
  name?: InputMaybe<Scalars['String']>;
  /** ID of the type that product belongs to. */
  productType: Scalars['ID'];
  /** Defines the product rating value. */
  rating?: InputMaybe<Scalars['Float']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Product slug. */
  slug?: InputMaybe<Scalars['String']>;
  /** Tax rate for enabled tax gateway. */
  taxCode?: InputMaybe<Scalars['String']>;
  /** Weight of the Product. */
  weight?: InputMaybe<Scalars['WeightScalar']>;
};

export type ProductCreated = {
  __typename?: 'ProductCreated';
  /** Added in Saleor 3.2. Look up a category. Note: this feature is in a preview state and can be subject to changes at later point. */
  category?: Maybe<Category>;
  /** Added in Saleor 3.2. Look up a product. Note: this feature is in a preview state and can be subject to changes at later point. */
  product?: Maybe<Product>;
};


export type ProductCreatedProductArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a product. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductDelete = {
  __typename?: 'ProductDelete';
  errors: Array<ProductError>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductDeleted = {
  __typename?: 'ProductDeleted';
  /** Added in Saleor 3.2. Look up a category. Note: this feature is in a preview state and can be subject to changes at later point. */
  category?: Maybe<Category>;
  /** Added in Saleor 3.2. Look up a product. Note: this feature is in a preview state and can be subject to changes at later point. */
  product?: Maybe<Product>;
};


export type ProductDeletedProductArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

export type ProductError = {
  __typename?: 'ProductError';
  /** List of attributes IDs which causes the error. */
  attributes?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ProductErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of attribute values IDs which causes the error. */
  values?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum ProductErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  AttributeAlreadyAssigned = 'ATTRIBUTE_ALREADY_ASSIGNED',
  AttributeCannotBeAssigned = 'ATTRIBUTE_CANNOT_BE_ASSIGNED',
  AttributeVariantsDisabled = 'ATTRIBUTE_VARIANTS_DISABLED',
  CannotManageProductWithoutVariant = 'CANNOT_MANAGE_PRODUCT_WITHOUT_VARIANT',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  MediaAlreadyAssigned = 'MEDIA_ALREADY_ASSIGNED',
  NotFound = 'NOT_FOUND',
  NotProductsImage = 'NOT_PRODUCTS_IMAGE',
  NotProductsVariant = 'NOT_PRODUCTS_VARIANT',
  PreorderVariantCannotBeDeactivated = 'PREORDER_VARIANT_CANNOT_BE_DEACTIVATED',
  ProductNotAssignedToChannel = 'PRODUCT_NOT_ASSIGNED_TO_CHANNEL',
  ProductWithoutCategory = 'PRODUCT_WITHOUT_CATEGORY',
  Required = 'REQUIRED',
  Unique = 'UNIQUE',
  UnsupportedMediaProvider = 'UNSUPPORTED_MEDIA_PROVIDER',
  VariantNoDigitalContent = 'VARIANT_NO_DIGITAL_CONTENT'
}

export enum ProductFieldEnum {
  Category = 'CATEGORY',
  ChargeTaxes = 'CHARGE_TAXES',
  Collections = 'COLLECTIONS',
  Description = 'DESCRIPTION',
  Name = 'NAME',
  ProductMedia = 'PRODUCT_MEDIA',
  ProductType = 'PRODUCT_TYPE',
  ProductWeight = 'PRODUCT_WEIGHT',
  VariantId = 'VARIANT_ID',
  VariantMedia = 'VARIANT_MEDIA',
  VariantSku = 'VARIANT_SKU',
  VariantWeight = 'VARIANT_WEIGHT'
}

export type ProductFilterInput = {
  attributes?: InputMaybe<Array<AttributeInput>>;
  categories?: InputMaybe<Array<Scalars['ID']>>;
  /**
   * Specifies the channel by which the data should be filtered.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  collections?: InputMaybe<Array<Scalars['ID']>>;
  giftCard?: InputMaybe<Scalars['Boolean']>;
  hasCategory?: InputMaybe<Scalars['Boolean']>;
  hasPreorderedVariants?: InputMaybe<Scalars['Boolean']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  isPublished?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  minimalPrice?: InputMaybe<PriceRangeInput>;
  price?: InputMaybe<PriceRangeInput>;
  productTypes?: InputMaybe<Array<Scalars['ID']>>;
  search?: InputMaybe<Scalars['String']>;
  stockAvailability?: InputMaybe<StockAvailability>;
  stocks?: InputMaybe<ProductStockFilterInput>;
  updatedAt?: InputMaybe<DateTimeRangeInput>;
};

/** Represents a product image. */
export type ProductImage = {
  __typename?: 'ProductImage';
  /** The alt text of the image. */
  alt?: Maybe<Scalars['String']>;
  /** The ID of the image. */
  id: Scalars['ID'];
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder?: Maybe<Scalars['Int']>;
  /** The URL of the image. */
  url: Scalars['String'];
};


/** Represents a product image. */
export type ProductImageUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

export type ProductInput = {
  /** List of attributes. */
  attributes?: InputMaybe<Array<AttributeValueInput>>;
  /** ID of the product's category. */
  category?: InputMaybe<Scalars['ID']>;
  /** Determine if taxes are being charged for the product. */
  chargeTaxes?: InputMaybe<Scalars['Boolean']>;
  /** List of IDs of collections that the product belongs to. */
  collections?: InputMaybe<Array<Scalars['ID']>>;
  /** Product description (JSON). */
  description?: InputMaybe<Scalars['JSONString']>;
  /** Product name. */
  name?: InputMaybe<Scalars['String']>;
  /** Defines the product rating value. */
  rating?: InputMaybe<Scalars['Float']>;
  /** Search engine optimization fields. */
  seo?: InputMaybe<SeoInput>;
  /** Product slug. */
  slug?: InputMaybe<Scalars['String']>;
  /** Tax rate for enabled tax gateway. */
  taxCode?: InputMaybe<Scalars['String']>;
  /** Weight of the Product. */
  weight?: InputMaybe<Scalars['WeightScalar']>;
};

/** Represents a product media. */
export type ProductMedia = Node & {
  __typename?: 'ProductMedia';
  alt: Scalars['String'];
  id: Scalars['ID'];
  oembedData: Scalars['JSONString'];
  sortOrder?: Maybe<Scalars['Int']>;
  type: ProductMediaType;
  /** The URL of the media. */
  url: Scalars['String'];
};


/** Represents a product media. */
export type ProductMediaUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Deletes product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductMediaBulkDelete = {
  __typename?: 'ProductMediaBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Create a media object (image or video URL) associated with product. For image, this mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductMediaCreate = {
  __typename?: 'ProductMediaCreate';
  errors: Array<ProductError>;
  media?: Maybe<ProductMedia>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductMediaCreateInput = {
  /** Alt text for a product media. */
  alt?: InputMaybe<Scalars['String']>;
  /** Represents an image file in a multipart request. */
  image?: InputMaybe<Scalars['Upload']>;
  /** Represents an URL to an external media. */
  mediaUrl?: InputMaybe<Scalars['String']>;
  /** ID of an product. */
  product: Scalars['ID'];
};

/** Deletes a product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductMediaDelete = {
  __typename?: 'ProductMediaDelete';
  errors: Array<ProductError>;
  media?: Maybe<ProductMedia>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Changes ordering of the product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductMediaReorder = {
  __typename?: 'ProductMediaReorder';
  errors: Array<ProductError>;
  media?: Maybe<Array<ProductMedia>>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** An enumeration. */
export enum ProductMediaType {
  Image = 'IMAGE',
  Video = 'VIDEO'
}

/** Updates a product media. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductMediaUpdate = {
  __typename?: 'ProductMediaUpdate';
  errors: Array<ProductError>;
  media?: Maybe<ProductMedia>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductMediaUpdateInput = {
  /** Alt text for a product media. */
  alt?: InputMaybe<Scalars['String']>;
};

export type ProductOrder = {
  /**
   * Sort product by the selected attribute's values.
   * Note: this doesn't take translations into account yet.
   */
  attributeId?: InputMaybe<Scalars['ID']>;
  /**
   * Specifies the channel in which to sort the data.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort products by the selected field. */
  field?: InputMaybe<ProductOrderField>;
};

export enum ProductOrderField {
  /** Sort products by collection. Note: This option is available only for the `Collection.products` query. */
  Collection = 'COLLECTION',
  /** Sort products by update date. */
  Date = 'DATE',
  /** Sort products by update date. */
  LastModified = 'LAST_MODIFIED',
  /** Sort products by update date. */
  LastModifiedAt = 'LAST_MODIFIED_AT',
  /** Sort products by a minimal price of a product's variant. */
  MinimalPrice = 'MINIMAL_PRICE',
  /** Sort products by name. */
  Name = 'NAME',
  /** Sort products by price. */
  Price = 'PRICE',
  /** Sort products by publication date. */
  PublicationDate = 'PUBLICATION_DATE',
  /** Sort products by publication status. */
  Published = 'PUBLISHED',
  /** Sort products by publication date. */
  PublishedAt = 'PUBLISHED_AT',
  /** Sort products by rank. Note: This option is available only with the `search` filter. */
  Rank = 'RANK',
  /** Sort products by rating. */
  Rating = 'RATING',
  /** Sort products by type. */
  Type = 'TYPE'
}

/** Represents availability of a product in the storefront. */
export type ProductPricingInfo = {
  __typename?: 'ProductPricingInfo';
  /** The discount amount if in sale (null otherwise). */
  discount?: Maybe<TaxedMoney>;
  /** The discount amount in the local currency. */
  discountLocalCurrency?: Maybe<TaxedMoney>;
  /** Whether it is in sale or not. */
  onSale?: Maybe<Scalars['Boolean']>;
  /** The discounted price range of the product variants. */
  priceRange?: Maybe<TaxedMoneyRange>;
  /** The discounted price range of the product variants in the local currency. */
  priceRangeLocalCurrency?: Maybe<TaxedMoneyRange>;
  /** The undiscounted price range of the product variants. */
  priceRangeUndiscounted?: Maybe<TaxedMoneyRange>;
};

/** Reorder product attribute values. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductReorderAttributeValues = {
  __typename?: 'ProductReorderAttributeValues';
  errors: Array<ProductError>;
  /** Product from which attribute values are reordered. */
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductStockFilterInput = {
  quantity?: InputMaybe<IntRangeInput>;
  warehouseIds?: InputMaybe<Array<Scalars['ID']>>;
};

export type ProductTranslatableContent = Node & {
  __typename?: 'ProductTranslatableContent';
  /** List of product attribute values that can be translated. */
  attributeValues: Array<AttributeValueTranslatableContent>;
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Description of the product (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  /**
   * Represents an individual item for sale in the storefront.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  product?: Maybe<Product>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
  /** Returns translated product fields for the given language code. */
  translation?: Maybe<ProductTranslation>;
};


export type ProductTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a product. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type ProductTranslate = {
  __typename?: 'ProductTranslate';
  errors: Array<TranslationError>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ProductTranslation = Node & {
  __typename?: 'ProductTranslation';
  description?: Maybe<Scalars['JSONString']>;
  /**
   * Translated description of the product (JSON).
   * @deprecated This field will be removed in Saleor 4.0. Use the `description` field instead.
   */
  descriptionJson?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name?: Maybe<Scalars['String']>;
  seoDescription?: Maybe<Scalars['String']>;
  seoTitle?: Maybe<Scalars['String']>;
};

/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductType = Node & ObjectWithMetadata & {
  __typename?: 'ProductType';
  /** Added in Saleor 3.1. Variant attributes of that product type with attached variant selection. */
  assignedVariantAttributes?: Maybe<Array<AssignedVariantAttribute>>;
  /** List of attributes which can be assigned to this product type. Requires one of the following permissions: MANAGE_PRODUCTS. */
  availableAttributes?: Maybe<AttributeCountableConnection>;
  hasVariants: Scalars['Boolean'];
  id: Scalars['ID'];
  isDigital: Scalars['Boolean'];
  isShippingRequired: Scalars['Boolean'];
  /** The product type kind. */
  kind: ProductTypeKindEnum;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Product attributes of that product type. */
  productAttributes?: Maybe<Array<Attribute>>;
  /**
   * List of products of this type.
   * @deprecated This field will be removed in Saleor 4.0. Use the top-level `products` query with the `productTypes` filter.
   */
  products?: Maybe<ProductCountableConnection>;
  slug: Scalars['String'];
  /** A type of tax. Assigned by enabled tax gateway */
  taxType?: Maybe<TaxType>;
  /**
   * Variant attributes of that product type.
   * @deprecated This field will be removed in Saleor 4.0. Use `assignedVariantAttributes` instead.
   */
  variantAttributes?: Maybe<Array<Attribute>>;
  weight?: Maybe<Weight>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeAssignedVariantAttributesArgs = {
  variantSelection?: InputMaybe<VariantAttributeScope>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeAvailableAttributesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AttributeFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a type of product. It defines what attributes are available to products of this type. */
export type ProductTypeVariantAttributesArgs = {
  variantSelection?: InputMaybe<VariantAttributeScope>;
};

/** Deletes product types. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductTypeBulkDelete = {
  __typename?: 'ProductTypeBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export enum ProductTypeConfigurable {
  Configurable = 'CONFIGURABLE',
  Simple = 'SIMPLE'
}

export type ProductTypeCountableConnection = {
  __typename?: 'ProductTypeCountableConnection';
  edges: Array<ProductTypeCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type ProductTypeCountableEdge = {
  __typename?: 'ProductTypeCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ProductType;
};

/** Creates a new product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductTypeCreate = {
  __typename?: 'ProductTypeCreate';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productType?: Maybe<ProductType>;
};

/** Deletes a product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductTypeDelete = {
  __typename?: 'ProductTypeDelete';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productType?: Maybe<ProductType>;
};

export enum ProductTypeEnum {
  Digital = 'DIGITAL',
  Shippable = 'SHIPPABLE'
}

export type ProductTypeFilterInput = {
  configurable?: InputMaybe<ProductTypeConfigurable>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  kind?: InputMaybe<ProductTypeKindEnum>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  productType?: InputMaybe<ProductTypeEnum>;
  search?: InputMaybe<Scalars['String']>;
};

export type ProductTypeInput = {
  /** Determines if product of this type has multiple variants. This option mainly simplifies product management in the dashboard. There is always at least one variant created under the hood. */
  hasVariants?: InputMaybe<Scalars['Boolean']>;
  /** Determines if products are digital. */
  isDigital?: InputMaybe<Scalars['Boolean']>;
  /** Determines if shipping is required for products of this variant. */
  isShippingRequired?: InputMaybe<Scalars['Boolean']>;
  /** The product type kind. */
  kind?: InputMaybe<ProductTypeKindEnum>;
  /** Name of the product type. */
  name?: InputMaybe<Scalars['String']>;
  /** List of attributes shared among all product variants. */
  productAttributes?: InputMaybe<Array<Scalars['ID']>>;
  /** Product type slug. */
  slug?: InputMaybe<Scalars['String']>;
  /** Tax rate for enabled tax gateway. */
  taxCode?: InputMaybe<Scalars['String']>;
  /** List of attributes used to distinguish between different variants of a product. */
  variantAttributes?: InputMaybe<Array<Scalars['ID']>>;
  /** Weight of the ProductType items. */
  weight?: InputMaybe<Scalars['WeightScalar']>;
};

/** An enumeration. */
export enum ProductTypeKindEnum {
  GiftCard = 'GIFT_CARD',
  Normal = 'NORMAL'
}

/** Reorder the attributes of a product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductTypeReorderAttributes = {
  __typename?: 'ProductTypeReorderAttributes';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** Product type from which attributes are reordered. */
  productType?: Maybe<ProductType>;
};

export enum ProductTypeSortField {
  /** Sort products by type. */
  Digital = 'DIGITAL',
  /** Sort products by name. */
  Name = 'NAME',
  /** Sort products by shipping. */
  ShippingRequired = 'SHIPPING_REQUIRED'
}

export type ProductTypeSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort product types by the selected field. */
  field: ProductTypeSortField;
};

/** Updates an existing product type. Requires one of the following permissions: MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES. */
export type ProductTypeUpdate = {
  __typename?: 'ProductTypeUpdate';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productType?: Maybe<ProductType>;
};

/** Updates an existing product. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductUpdate = {
  __typename?: 'ProductUpdate';
  errors: Array<ProductError>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export type ProductUpdated = {
  __typename?: 'ProductUpdated';
  /** Added in Saleor 3.2. Look up a category. Note: this feature is in a preview state and can be subject to changes at later point. */
  category?: Maybe<Category>;
  /** Added in Saleor 3.2. Look up a product. Note: this feature is in a preview state and can be subject to changes at later point. */
  product?: Maybe<Product>;
};


export type ProductUpdatedProductArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Represents a version of a product such as different size or color. */
export type ProductVariant = Node & ObjectWithMetadata & {
  __typename?: 'ProductVariant';
  /** List of attributes assigned to this variant. */
  attributes: Array<SelectedAttribute>;
  /** Channel given to retrieve this product variant. Also used by federation gateway to resolve this object in a federated query. */
  channel?: Maybe<Scalars['String']>;
  /** List of price information in channels for the product. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER. */
  channelListings?: Maybe<Array<ProductVariantChannelListing>>;
  created: Scalars['DateTime'];
  /** Digital content for the product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContent?: Maybe<DigitalContent>;
  id: Scalars['ID'];
  /**
   * List of images for the product variant.
   * @deprecated This field will be removed in Saleor 4.0. Use the `media` field instead.
   */
  images?: Maybe<Array<ProductImage>>;
  /** Gross margin percentage value. */
  margin?: Maybe<Scalars['Int']>;
  /** List of media for the product variant. */
  media?: Maybe<Array<ProductMedia>>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** Added in Saleor 3.1. Preorder data for product variant. Note: this feature is in a preview state and can be subject to changes at later point. */
  preorder?: Maybe<PreorderData>;
  /** Lists the storefront variant's pricing, the current price and discounts, only meant for displaying. */
  pricing?: Maybe<VariantPricingInfo>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  product: Product;
  /** Quantity of a product available for sale in one checkout. Field value will be `null` when no `limitQuantityPerCheckout` in global settings has been set, and `productVariant` stocks are not tracked. */
  quantityAvailable?: Maybe<Scalars['Int']>;
  quantityLimitPerCustomer?: Maybe<Scalars['Int']>;
  /** Total quantity ordered. Requires one of the following permissions: MANAGE_PRODUCTS. */
  quantityOrdered?: Maybe<Scalars['Int']>;
  /** Total revenue generated by a variant in given period of time. Note: this field should be queried using `reportProductSales` query as it uses optimizations suitable for such calculations. Requires one of the following permissions: MANAGE_PRODUCTS. */
  revenue?: Maybe<TaxedMoney>;
  sku?: Maybe<Scalars['String']>;
  /** Stocks for the product variant. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  stocks?: Maybe<Array<Stock>>;
  trackInventory: Scalars['Boolean'];
  /** Returns translated product variant fields for the given language code. */
  translation?: Maybe<ProductVariantTranslation>;
  updatedAt: Scalars['DateTime'];
  weight?: Maybe<Weight>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantAttributesArgs = {
  variantSelection?: InputMaybe<VariantAttributeScope>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPricingArgs = {
  address?: InputMaybe<AddressInput>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantQuantityAvailableArgs = {
  address?: InputMaybe<AddressInput>;
  countryCode?: InputMaybe<CountryCode>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantRevenueArgs = {
  period?: InputMaybe<ReportingPeriod>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantStocksArgs = {
  address?: InputMaybe<AddressInput>;
  countryCode?: InputMaybe<CountryCode>;
};


/** Represents a version of a product such as different size or color. */
export type ProductVariantTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

export type ProductVariantBackInStock = {
  __typename?: 'ProductVariantBackInStock';
  /** Added in Saleor 3.2. Look up a product variant. Note: this feature is in a preview state and can be subject to changes at later point. */
  productVariant?: Maybe<ProductVariant>;
  /** Added in Saleor 3.2. Look up a warehouse. Note: this feature is in a preview state and can be subject to changes at later point. */
  warehouse?: Maybe<Warehouse>;
};


export type ProductVariantBackInStockProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Creates product variants for a given product. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantBulkCreate = {
  __typename?: 'ProductVariantBulkCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  bulkProductErrors: Array<BulkProductError>;
  /** Returns how many objects were created. */
  count: Scalars['Int'];
  errors: Array<BulkProductError>;
  /** List of the created variants. */
  productVariants: Array<ProductVariant>;
};

export type ProductVariantBulkCreateInput = {
  /** List of attributes specific to this variant. */
  attributes: Array<BulkAttributeValueInput>;
  /** List of prices assigned to channels. */
  channelListings?: InputMaybe<Array<ProductVariantChannelListingAddInput>>;
  /** Added in Saleor 3.1. Determines if variant is in preorder. Note: this feature is in a preview state and can be subject to changes at later point. */
  preorder?: InputMaybe<PreorderSettingsInput>;
  /** Added in Saleor 3.1. Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  quantityLimitPerCustomer?: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku?: InputMaybe<Scalars['String']>;
  /** Stocks of a product available for sale. */
  stocks?: InputMaybe<Array<StockInput>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. */
  trackInventory?: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight?: InputMaybe<Scalars['WeightScalar']>;
};

/** Deletes product variants. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantBulkDelete = {
  __typename?: 'ProductVariantBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Represents product varaint channel listing. */
export type ProductVariantChannelListing = Node & {
  __typename?: 'ProductVariantChannelListing';
  channel: Channel;
  /** Cost price of the variant. */
  costPrice?: Maybe<Money>;
  id: Scalars['ID'];
  /** Gross margin percentage value. Requires one of the following permissions: MANAGE_PRODUCTS. */
  margin?: Maybe<Scalars['Int']>;
  /** Added in Saleor 3.1. Preorder variant data. Note: this feature is in a preview state and can be subject to changes at later point. */
  preorderThreshold?: Maybe<PreorderThreshold>;
  price?: Maybe<Money>;
};

export type ProductVariantChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Cost price of the variant in channel. */
  costPrice?: InputMaybe<Scalars['PositiveDecimal']>;
  /** Added in Saleor 3.1. The threshold for preorder variant in channel. Note: this feature is in a preview state and can be subject to changes at later point. */
  preorderThreshold?: InputMaybe<Scalars['Int']>;
  /** Price of the particular variant in channel. */
  price: Scalars['PositiveDecimal'];
};

/** Manage product variant prices in channels. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantChannelListingUpdate = {
  __typename?: 'ProductVariantChannelListingUpdate';
  errors: Array<ProductChannelListingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productChannelListingErrors: Array<ProductChannelListingError>;
  /** An updated product variant instance. */
  variant?: Maybe<ProductVariant>;
};

export type ProductVariantCountableConnection = {
  __typename?: 'ProductVariantCountableConnection';
  edges: Array<ProductVariantCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type ProductVariantCountableEdge = {
  __typename?: 'ProductVariantCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ProductVariant;
};

/** Creates a new variant for a product. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantCreate = {
  __typename?: 'ProductVariantCreate';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant?: Maybe<ProductVariant>;
};

export type ProductVariantCreateInput = {
  /** List of attributes specific to this variant. */
  attributes: Array<AttributeValueInput>;
  /** Added in Saleor 3.1. Determines if variant is in preorder. Note: this feature is in a preview state and can be subject to changes at later point. */
  preorder?: InputMaybe<PreorderSettingsInput>;
  /** Product ID of which type is the variant. */
  product: Scalars['ID'];
  /** Added in Saleor 3.1. Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  quantityLimitPerCustomer?: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku?: InputMaybe<Scalars['String']>;
  /** Stocks of a product available for sale. */
  stocks?: InputMaybe<Array<StockInput>>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. */
  trackInventory?: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight?: InputMaybe<Scalars['WeightScalar']>;
};

export type ProductVariantCreated = {
  __typename?: 'ProductVariantCreated';
  /** Added in Saleor 3.2. Look up a product variant. Note: this feature is in a preview state and can be subject to changes at later point. */
  productVariant?: Maybe<ProductVariant>;
};


export type ProductVariantCreatedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantDelete = {
  __typename?: 'ProductVariantDelete';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant?: Maybe<ProductVariant>;
};

export type ProductVariantDeleted = {
  __typename?: 'ProductVariantDeleted';
  /** Added in Saleor 3.2. Look up a product variant. Note: this feature is in a preview state and can be subject to changes at later point. */
  productVariant?: Maybe<ProductVariant>;
};


export type ProductVariantDeletedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

export type ProductVariantFilterInput = {
  isPreorder?: InputMaybe<Scalars['Boolean']>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
  sku?: InputMaybe<Array<Scalars['String']>>;
  updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type ProductVariantInput = {
  /** List of attributes specific to this variant. */
  attributes?: InputMaybe<Array<AttributeValueInput>>;
  /** Added in Saleor 3.1. Determines if variant is in preorder. Note: this feature is in a preview state and can be subject to changes at later point. */
  preorder?: InputMaybe<PreorderSettingsInput>;
  /** Added in Saleor 3.1. Determines maximum quantity of `ProductVariant`,that can be bought in a single checkout. Note: this feature is in a preview state and can be subject to changes at later point. */
  quantityLimitPerCustomer?: InputMaybe<Scalars['Int']>;
  /** Stock keeping unit. */
  sku?: InputMaybe<Scalars['String']>;
  /** Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item. */
  trackInventory?: InputMaybe<Scalars['Boolean']>;
  /** Weight of the Product Variant. */
  weight?: InputMaybe<Scalars['WeightScalar']>;
};

export type ProductVariantOutOfStock = {
  __typename?: 'ProductVariantOutOfStock';
  /** Added in Saleor 3.2. Look up a product variant. Note: this feature is in a preview state and can be subject to changes at later point. */
  productVariant?: Maybe<ProductVariant>;
  /** Added in Saleor 3.2. Look up a warehouse. Note: this feature is in a preview state and can be subject to changes at later point. */
  warehouse?: Maybe<Warehouse>;
};


export type ProductVariantOutOfStockProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Added in Saleor 3.1. Deactivates product variant preorder. It changes all preorder allocation into regular allocation. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantPreorderDeactivate = {
  __typename?: 'ProductVariantPreorderDeactivate';
  errors: Array<ProductError>;
  /** Product variant with ended preorder. */
  productVariant?: Maybe<ProductVariant>;
};

/** Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantReorder = {
  __typename?: 'ProductVariantReorder';
  errors: Array<ProductError>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

/** Reorder product variant attribute values. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantReorderAttributeValues = {
  __typename?: 'ProductVariantReorderAttributeValues';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  /** Product variant from which attribute values are reordered. */
  productVariant?: Maybe<ProductVariant>;
};

/** Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantSetDefault = {
  __typename?: 'ProductVariantSetDefault';
  errors: Array<ProductError>;
  product?: Maybe<Product>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
};

export enum ProductVariantSortField {
  /** Sort products variants by last modified at. */
  LastModifiedAt = 'LAST_MODIFIED_AT'
}

export type ProductVariantSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort productVariants by the selected field. */
  field: ProductVariantSortField;
};

/** Creates stocks for product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantStocksCreate = {
  __typename?: 'ProductVariantStocksCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  bulkStockErrors: Array<BulkStockError>;
  errors: Array<BulkStockError>;
  /** Updated product variant. */
  productVariant?: Maybe<ProductVariant>;
};

/** Delete stocks from product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantStocksDelete = {
  __typename?: 'ProductVariantStocksDelete';
  errors: Array<StockError>;
  /** Updated product variant. */
  productVariant?: Maybe<ProductVariant>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  stockErrors: Array<StockError>;
};

/** Update stocks for product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantStocksUpdate = {
  __typename?: 'ProductVariantStocksUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  bulkStockErrors: Array<BulkStockError>;
  errors: Array<BulkStockError>;
  /** Updated product variant. */
  productVariant?: Maybe<ProductVariant>;
};

export type ProductVariantTranslatableContent = Node & {
  __typename?: 'ProductVariantTranslatableContent';
  /** List of product variant attribute values that can be translated. */
  attributeValues: Array<AttributeValueTranslatableContent>;
  id: Scalars['ID'];
  name: Scalars['String'];
  /**
   * Represents a version of a product such as different size or color.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  productVariant?: Maybe<ProductVariant>;
  /** Returns translated product variant fields for the given language code. */
  translation?: Maybe<ProductVariantTranslation>;
};


export type ProductVariantTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a product variant. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type ProductVariantTranslate = {
  __typename?: 'ProductVariantTranslate';
  errors: Array<TranslationError>;
  productVariant?: Maybe<ProductVariant>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ProductVariantTranslation = Node & {
  __typename?: 'ProductVariantTranslation';
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name: Scalars['String'];
};

/** Updates an existing variant for product. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type ProductVariantUpdate = {
  __typename?: 'ProductVariantUpdate';
  errors: Array<ProductError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant?: Maybe<ProductVariant>;
};

export type ProductVariantUpdated = {
  __typename?: 'ProductVariantUpdated';
  /** Added in Saleor 3.2. Look up a product variant. Note: this feature is in a preview state and can be subject to changes at later point. */
  productVariant?: Maybe<ProductVariant>;
};


export type ProductVariantUpdatedProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

export type PublishableChannelListingInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Determines if object is visible to customers. */
  isPublished?: InputMaybe<Scalars['Boolean']>;
  /**
   * Publication date. ISO 8601 standard.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `publishedAt` field instead.
   */
  publicationDate?: InputMaybe<Scalars['Date']>;
  /** Added in Saleor 3.3. Publication date time. ISO 8601 standard. */
  publishedAt?: InputMaybe<Scalars['DateTime']>;
};

export type Query = {
  __typename?: 'Query';
  _entities?: Maybe<Array<Maybe<_Entity>>>;
  _service?: Maybe<_Service>;
  /** Look up an address by ID. */
  address?: Maybe<Address>;
  /** Returns address validation rules. */
  addressValidationRules?: Maybe<AddressValidationData>;
  /** Look up an app by ID. If ID is not provided, return the currently authenticated app. Requires one of the following permissions: AuthorizationFilters.OWNER, AppPermission.MANAGE_APPS. */
  app?: Maybe<App>;
  /** Added in Saleor 3.1. Look up an app extension by ID. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP. */
  appExtension?: Maybe<AppExtension>;
  /** Added in Saleor 3.1. List of all extensions. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP. */
  appExtensions?: Maybe<AppExtensionCountableConnection>;
  /** List of the apps. Requires one of the following permissions: MANAGE_APPS. */
  apps?: Maybe<AppCountableConnection>;
  /** List of all apps installations Requires one of the following permissions: MANAGE_APPS. */
  appsInstallations: Array<AppInstallation>;
  /** Look up an attribute by ID. */
  attribute?: Maybe<Attribute>;
  /** List of the shop's attributes. */
  attributes?: Maybe<AttributeCountableConnection>;
  /** List of the shop's categories. */
  categories?: Maybe<CategoryCountableConnection>;
  /** Look up a category by ID or slug. */
  category?: Maybe<Category>;
  /** Look up a channel by ID. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER. */
  channel?: Maybe<Channel>;
  /** List of all channels. Requires one of the following permissions: AUTHENTICATED_APP, AUTHENTICATED_STAFF_USER. */
  channels?: Maybe<Array<Channel>>;
  /** Look up a checkout by token and slug of channel. */
  checkout?: Maybe<Checkout>;
  /** List of checkout lines. Requires one of the following permissions: MANAGE_CHECKOUTS. */
  checkoutLines?: Maybe<CheckoutLineCountableConnection>;
  /** List of checkouts. Requires one of the following permissions: MANAGE_CHECKOUTS. */
  checkouts?: Maybe<CheckoutCountableConnection>;
  /** Look up a collection by ID. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collection?: Maybe<Collection>;
  /** List of the shop's collections. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  collections?: Maybe<CollectionCountableConnection>;
  /** List of the shop's customers. Requires one of the following permissions: MANAGE_ORDERS, MANAGE_USERS. */
  customers?: Maybe<UserCountableConnection>;
  /** Look up digital content by ID. Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContent?: Maybe<DigitalContent>;
  /** List of digital content. Requires one of the following permissions: MANAGE_PRODUCTS. */
  digitalContents?: Maybe<DigitalContentCountableConnection>;
  /** List of draft orders. Requires one of the following permissions: MANAGE_ORDERS. */
  draftOrders?: Maybe<OrderCountableConnection>;
  /** Look up a export file by ID. Requires one of the following permissions: MANAGE_PRODUCTS. */
  exportFile?: Maybe<ExportFile>;
  /** List of export files. Requires one of the following permissions: MANAGE_PRODUCTS. */
  exportFiles?: Maybe<ExportFileCountableConnection>;
  /** Look up a gift card by ID. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCard?: Maybe<GiftCard>;
  /** Added in Saleor 3.1. List of gift card currencies. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardCurrencies: Array<Scalars['String']>;
  /** Gift card related settings from site settings. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardSettings: GiftCardSettings;
  /** Added in Saleor 3.1. List of gift card tags. Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCardTags?: Maybe<GiftCardTagCountableConnection>;
  /** List of gift cards. Requires one of the following permissions: MANAGE_GIFT_CARD. */
  giftCards?: Maybe<GiftCardCountableConnection>;
  /** List of activity events to display on homepage (at the moment it only contains order-events). Requires one of the following permissions: MANAGE_ORDERS. */
  homepageEvents?: Maybe<OrderEventCountableConnection>;
  /** Return the currently authenticated user. */
  me?: Maybe<User>;
  /** Look up a navigation menu by ID or name. */
  menu?: Maybe<Menu>;
  /** Look up a menu item by ID. */
  menuItem?: Maybe<MenuItem>;
  /** List of the storefronts's menu items. */
  menuItems?: Maybe<MenuItemCountableConnection>;
  /** List of the storefront's menus. */
  menus?: Maybe<MenuCountableConnection>;
  /** Look up an order by ID. Requires one of the following permissions: MANAGE_ORDERS. */
  order?: Maybe<Order>;
  /** {DEPRECATED_IN_3X_FIELD} Look up an order by token. */
  orderByToken?: Maybe<Order>;
  /** Order related settings from site settings. Requires one of the following permissions: MANAGE_ORDERS. */
  orderSettings?: Maybe<OrderSettings>;
  /** List of orders. Requires one of the following permissions: MANAGE_ORDERS. */
  orders?: Maybe<OrderCountableConnection>;
  /** Return the total sales amount from a specific period. Requires one of the following permissions: MANAGE_ORDERS. */
  ordersTotal?: Maybe<TaxedMoney>;
  /** Look up a page by ID or slug. */
  page?: Maybe<Page>;
  /** Look up a page type by ID. */
  pageType?: Maybe<PageType>;
  /** List of the page types. */
  pageTypes?: Maybe<PageTypeCountableConnection>;
  /** List of the shop's pages. */
  pages?: Maybe<PageCountableConnection>;
  /** Look up a payment by ID. Requires one of the following permissions: MANAGE_ORDERS. */
  payment?: Maybe<Payment>;
  /** List of payments. Requires one of the following permissions: MANAGE_ORDERS. */
  payments?: Maybe<PaymentCountableConnection>;
  /** Look up permission group by ID. Requires one of the following permissions: MANAGE_STAFF. */
  permissionGroup?: Maybe<Group>;
  /** List of permission groups. Requires one of the following permissions: MANAGE_STAFF. */
  permissionGroups?: Maybe<GroupCountableConnection>;
  /** Look up a plugin by ID. Requires one of the following permissions: MANAGE_PLUGINS. */
  plugin?: Maybe<Plugin>;
  /** List of plugins. Requires one of the following permissions: MANAGE_PLUGINS. */
  plugins?: Maybe<PluginCountableConnection>;
  /** Look up a product by ID. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  product?: Maybe<Product>;
  /** Look up a product type by ID. */
  productType?: Maybe<ProductType>;
  /** List of the shop's product types. */
  productTypes?: Maybe<ProductTypeCountableConnection>;
  /** Look up a product variant by ID or SKU. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  productVariant?: Maybe<ProductVariant>;
  /** List of product variants. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  productVariants?: Maybe<ProductVariantCountableConnection>;
  /** List of the shop's products. Requires one of the following permissions to include the unpublished items: MANAGE_ORDERS, MANAGE_DISCOUNTS, MANAGE_PRODUCTS. */
  products?: Maybe<ProductCountableConnection>;
  /** List of top selling products. Requires one of the following permissions: MANAGE_PRODUCTS. */
  reportProductSales?: Maybe<ProductVariantCountableConnection>;
  /** Look up a sale by ID. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  sale?: Maybe<Sale>;
  /** List of the shop's sales. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  sales?: Maybe<SaleCountableConnection>;
  /** Look up a shipping zone by ID. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingZone?: Maybe<ShippingZone>;
  /** List of the shop's shipping zones. Requires one of the following permissions: MANAGE_SHIPPING. */
  shippingZones?: Maybe<ShippingZoneCountableConnection>;
  /** Return information about the shop. */
  shop: Shop;
  /** List of the shop's staff users. Requires one of the following permissions: MANAGE_STAFF. */
  staffUsers?: Maybe<UserCountableConnection>;
  /** Look up a stock by ID Requires one of the following permissions: MANAGE_PRODUCTS. */
  stock?: Maybe<Stock>;
  /** List of stocks. Requires one of the following permissions: MANAGE_PRODUCTS. */
  stocks?: Maybe<StockCountableConnection>;
  /** List of all tax rates available from tax gateway. */
  taxTypes?: Maybe<Array<TaxType>>;
  /**  Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  translation?: Maybe<TranslatableItem>;
  /** Returns a list of all translatable items of a given kind. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
  translations?: Maybe<TranslatableItemConnection>;
  /** Look up a user by ID or email address. Requires one of the following permissions: MANAGE_STAFF, MANAGE_USERS, MANAGE_ORDERS. */
  user?: Maybe<User>;
  /** Look up a voucher by ID. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  voucher?: Maybe<Voucher>;
  /** List of the shop's vouchers. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  vouchers?: Maybe<VoucherCountableConnection>;
  /** Look up a warehouse by ID. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS, MANAGE_SHIPPING. */
  warehouse?: Maybe<Warehouse>;
  /** List of warehouses. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS, MANAGE_SHIPPING. */
  warehouses?: Maybe<WarehouseCountableConnection>;
  /** Look up a webhook by ID. Requires one of the following permissions: AppPermission.MANAGE_APPS, AuthorizationFilters.OWNER */
  webhook?: Maybe<Webhook>;
  /**
   * List of all available webhook events. Requires one of the following permissions: MANAGE_APPS.
   * @deprecated This field will be removed in Saleor 4.0. Use `WebhookEventTypeAsyncEnum` and `WebhookEventTypeSyncEnum` to get available event types.
   */
  webhookEvents?: Maybe<Array<WebhookEvent>>;
  /** Retrieve a sample payload for a given webhook event based on real data. It can be useful for some integrations where sample payload is required. */
  webhookSamplePayload?: Maybe<Scalars['JSONString']>;
};


export type Query_EntitiesArgs = {
  representations?: InputMaybe<Array<InputMaybe<Scalars['_Any']>>>;
};


export type QueryAddressArgs = {
  id: Scalars['ID'];
};


export type QueryAddressValidationRulesArgs = {
  city?: InputMaybe<Scalars['String']>;
  cityArea?: InputMaybe<Scalars['String']>;
  countryArea?: InputMaybe<Scalars['String']>;
  countryCode: CountryCode;
};


export type QueryAppArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryAppExtensionArgs = {
  id: Scalars['ID'];
};


export type QueryAppExtensionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AppExtensionFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryAppsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AppFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<AppSortingInput>;
};


export type QueryAttributeArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueryAttributesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AttributeFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<AttributeSortingInput>;
};


export type QueryCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<CategoryFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  level?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<CategorySortingInput>;
};


export type QueryCategoryArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueryChannelArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryCheckoutArgs = {
  token?: InputMaybe<Scalars['UUID']>;
};


export type QueryCheckoutLinesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryCheckoutsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<CheckoutFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<CheckoutSortingInput>;
};


export type QueryCollectionArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueryCollectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<CollectionFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<CollectionSortingInput>;
};


export type QueryCustomersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<CustomerFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<UserSortingInput>;
};


export type QueryDigitalContentArgs = {
  id: Scalars['ID'];
};


export type QueryDigitalContentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryDraftOrdersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<OrderDraftFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<OrderSortingInput>;
};


export type QueryExportFileArgs = {
  id: Scalars['ID'];
};


export type QueryExportFilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ExportFileFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<ExportFileSortingInput>;
};


export type QueryGiftCardArgs = {
  id: Scalars['ID'];
};


export type QueryGiftCardTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<GiftCardTagFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryGiftCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<GiftCardFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<GiftCardSortingInput>;
};


export type QueryHomepageEventsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryMenuArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueryMenuItemArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QueryMenuItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<MenuItemFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<MenuItemSortingInput>;
};


export type QueryMenusArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<MenuFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<MenuSortingInput>;
};


export type QueryOrderArgs = {
  id: Scalars['ID'];
};


export type QueryOrderByTokenArgs = {
  token: Scalars['UUID'];
};


export type QueryOrdersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<OrderFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<OrderSortingInput>;
};


export type QueryOrdersTotalArgs = {
  channel?: InputMaybe<Scalars['String']>;
  period?: InputMaybe<ReportingPeriod>;
};


export type QueryPageArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueryPageTypeArgs = {
  id: Scalars['ID'];
};


export type QueryPageTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<PageTypeFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<PageTypeSortingInput>;
};


export type QueryPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<PageFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<PageSortingInput>;
};


export type QueryPaymentArgs = {
  id: Scalars['ID'];
};


export type QueryPaymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<PaymentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryPermissionGroupArgs = {
  id: Scalars['ID'];
};


export type QueryPermissionGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<PermissionGroupFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<PermissionGroupSortingInput>;
};


export type QueryPluginArgs = {
  id: Scalars['ID'];
};


export type QueryPluginsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<PluginFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<PluginSortingInput>;
};


export type QueryProductArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
};


export type QueryProductTypeArgs = {
  id: Scalars['ID'];
};


export type QueryProductTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ProductTypeFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<ProductTypeSortingInput>;
};


export type QueryProductVariantArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  sku?: InputMaybe<Scalars['String']>;
};


export type QueryProductVariantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ProductVariantFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<ProductVariantSortingInput>;
};


export type QueryProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ProductFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<ProductOrder>;
};


export type QueryReportProductSalesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel: Scalars['String'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  period: ReportingPeriod;
};


export type QuerySaleArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QuerySalesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SaleFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<SaleSortingInput>;
};


export type QueryShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QueryShippingZonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ShippingZoneFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryStaffUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<StaffUserInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<UserSortingInput>;
};


export type QueryStockArgs = {
  id: Scalars['ID'];
};


export type QueryStocksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<StockFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryTranslationArgs = {
  id: Scalars['ID'];
  kind: TranslatableKinds;
};


export type QueryTranslationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  kind: TranslatableKinds;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryUserArgs = {
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryVoucherArgs = {
  channel?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};


export type QueryVouchersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  channel?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<VoucherFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<VoucherSortingInput>;
};


export type QueryWarehouseArgs = {
  id: Scalars['ID'];
};


export type QueryWarehousesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<WarehouseFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<WarehouseSortingInput>;
};


export type QueryWebhookArgs = {
  id: Scalars['ID'];
};


export type QueryWebhookSamplePayloadArgs = {
  eventType: WebhookSampleEventTypeEnum;
};

/** Represents a reduced VAT rate for a particular type of goods. */
export type ReducedRate = {
  __typename?: 'ReducedRate';
  /** Reduced VAT rate in percent. */
  rate: Scalars['Float'];
  /** A type of goods. */
  rateType: Scalars['String'];
};

/** Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie. */
export type RefreshToken = {
  __typename?: 'RefreshToken';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** JWT token, required to authenticate. */
  token?: Maybe<Scalars['String']>;
  /** A user instance. */
  user?: Maybe<User>;
};

export type ReorderInput = {
  /** The ID of the item to move. */
  id: Scalars['ID'];
  /** The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged. */
  sortOrder?: InputMaybe<Scalars['Int']>;
};

export enum ReportingPeriod {
  ThisMonth = 'THIS_MONTH',
  Today = 'TODAY'
}

/** Request email change of the logged in user. Requires one of the following permissions: AUTHENTICATED_USER. */
export type RequestEmailChange = {
  __typename?: 'RequestEmailChange';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** A user instance. */
  user?: Maybe<User>;
};

/** Sends an email with the account password modification link. */
export type RequestPasswordReset = {
  __typename?: 'RequestPasswordReset';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
};

/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type Sale = Node & ObjectWithMetadata & {
  __typename?: 'Sale';
  /** List of categories this sale applies to. */
  categories?: Maybe<CategoryCountableConnection>;
  /** List of channels available for the sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  channelListings?: Maybe<Array<SaleChannelListing>>;
  /** List of collections this sale applies to. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  collections?: Maybe<CollectionCountableConnection>;
  created: Scalars['DateTime'];
  /** Currency code for sale. */
  currency?: Maybe<Scalars['String']>;
  /** Sale value. */
  discountValue?: Maybe<Scalars['Float']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** List of products this sale applies to. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  products?: Maybe<ProductCountableConnection>;
  startDate: Scalars['DateTime'];
  /** Returns translated sale fields for the given language code. */
  translation?: Maybe<SaleTranslation>;
  type: SaleType;
  updatedAt: Scalars['DateTime'];
  /** Added in Saleor 3.1. List of product variants this sale applies to. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  variants?: Maybe<ProductVariantCountableConnection>;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleCollectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleMetafieldArgs = {
  key: Scalars['String'];
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SalePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SalePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/** Sales allow creating discounts for categories, collections or products and are visible to all the customers. */
export type SaleVariantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Adds products, categories, collections to a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleAddCatalogues = {
  __typename?: 'SaleAddCatalogues';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Sale of which catalogue IDs will be modified. */
  sale?: Maybe<Sale>;
};

/** Deletes sales. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleBulkDelete = {
  __typename?: 'SaleBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
};

/** Represents sale channel listing. */
export type SaleChannelListing = Node & {
  __typename?: 'SaleChannelListing';
  channel: Channel;
  currency: Scalars['String'];
  discountValue: Scalars['Float'];
  id: Scalars['ID'];
};

export type SaleChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** The value of the discount. */
  discountValue: Scalars['PositiveDecimal'];
};

export type SaleChannelListingInput = {
  /** List of channels to which the sale should be assigned. */
  addChannels?: InputMaybe<Array<SaleChannelListingAddInput>>;
  /** List of channels from which the sale should be unassigned. */
  removeChannels?: InputMaybe<Array<Scalars['ID']>>;
};

/** Manage sale's availability in channels. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleChannelListingUpdate = {
  __typename?: 'SaleChannelListingUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** An updated sale instance. */
  sale?: Maybe<Sale>;
};

export type SaleCountableConnection = {
  __typename?: 'SaleCountableConnection';
  edges: Array<SaleCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type SaleCountableEdge = {
  __typename?: 'SaleCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Sale;
};

/** Creates a new sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleCreate = {
  __typename?: 'SaleCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  sale?: Maybe<Sale>;
};

export type SaleCreated = {
  __typename?: 'SaleCreated';
  /** Added in Saleor 3.2. Look up a sale. Note: this feature is in a preview state and can be subject to changes at later point. */
  sale?: Maybe<Sale>;
};


export type SaleCreatedSaleArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleDelete = {
  __typename?: 'SaleDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  sale?: Maybe<Sale>;
};

export type SaleDeleted = {
  __typename?: 'SaleDeleted';
  /** Added in Saleor 3.2. Look up a sale. Note: this feature is in a preview state and can be subject to changes at later point. */
  sale?: Maybe<Sale>;
};


export type SaleDeletedSaleArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

export type SaleFilterInput = {
  metadata?: InputMaybe<Array<MetadataFilter>>;
  saleType?: InputMaybe<DiscountValueTypeEnum>;
  search?: InputMaybe<Scalars['String']>;
  started?: InputMaybe<DateTimeRangeInput>;
  status?: InputMaybe<Array<DiscountStatusEnum>>;
  updatedAt?: InputMaybe<DateTimeRangeInput>;
};

export type SaleInput = {
  /** Categories related to the discount. */
  categories?: InputMaybe<Array<Scalars['ID']>>;
  /** Collections related to the discount. */
  collections?: InputMaybe<Array<Scalars['ID']>>;
  /** End date of the voucher in ISO 8601 format. */
  endDate?: InputMaybe<Scalars['DateTime']>;
  /** Voucher name. */
  name?: InputMaybe<Scalars['String']>;
  /** Products related to the discount. */
  products?: InputMaybe<Array<Scalars['ID']>>;
  /** Start date of the voucher in ISO 8601 format. */
  startDate?: InputMaybe<Scalars['DateTime']>;
  /** Fixed or percentage. */
  type?: InputMaybe<DiscountValueTypeEnum>;
  /** Value of the voucher. */
  value?: InputMaybe<Scalars['PositiveDecimal']>;
  variants?: InputMaybe<Array<Scalars['ID']>>;
};

/** Removes products, categories, collections from a sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleRemoveCatalogues = {
  __typename?: 'SaleRemoveCatalogues';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Sale of which catalogue IDs will be modified. */
  sale?: Maybe<Sale>;
};

export enum SaleSortField {
  /** Sort sales by created at. */
  CreatedAt = 'CREATED_AT',
  /** Sort sales by end date. */
  EndDate = 'END_DATE',
  /** Sort sales by last modified at. */
  LastModifiedAt = 'LAST_MODIFIED_AT',
  /** Sort sales by name. */
  Name = 'NAME',
  /** Sort sales by start date. */
  StartDate = 'START_DATE',
  /** Sort sales by type. */
  Type = 'TYPE',
  /** Sort sales by value. */
  Value = 'VALUE'
}

export type SaleSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort sales by the selected field. */
  field: SaleSortField;
};

export type SaleTranslatableContent = Node & {
  __typename?: 'SaleTranslatableContent';
  id: Scalars['ID'];
  name: Scalars['String'];
  /**
   * Sales allow creating discounts for categories, collections or products and are visible to all the customers. Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  sale?: Maybe<Sale>;
  /** Returns translated sale fields for the given language code. */
  translation?: Maybe<SaleTranslation>;
};


export type SaleTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a sale. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type SaleTranslate = {
  __typename?: 'SaleTranslate';
  errors: Array<TranslationError>;
  sale?: Maybe<Sale>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type SaleTranslation = Node & {
  __typename?: 'SaleTranslation';
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name?: Maybe<Scalars['String']>;
};

export enum SaleType {
  Fixed = 'FIXED',
  Percentage = 'PERCENTAGE'
}

/** Updates a sale. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type SaleUpdate = {
  __typename?: 'SaleUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  sale?: Maybe<Sale>;
};

export type SaleUpdated = {
  __typename?: 'SaleUpdated';
  /** Added in Saleor 3.2. Look up a sale. Note: this feature is in a preview state and can be subject to changes at later point. */
  sale?: Maybe<Sale>;
};


export type SaleUpdatedSaleArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Represents a custom attribute. */
export type SelectedAttribute = {
  __typename?: 'SelectedAttribute';
  /** Name of an attribute displayed in the interface. */
  attribute: Attribute;
  /** Values of an attribute. */
  values: Array<AttributeValue>;
};

export type SeoInput = {
  /** SEO description. */
  description?: InputMaybe<Scalars['String']>;
  /** SEO title. */
  title?: InputMaybe<Scalars['String']>;
};

/** Sets the user's password from the token sent by email using the RequestPasswordReset mutation. */
export type SetPassword = {
  __typename?: 'SetPassword';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** CSRF token required to re-generate access token. */
  csrfToken?: Maybe<Scalars['String']>;
  errors: Array<AccountError>;
  /** JWT refresh token, required to re-generate access token. */
  refreshToken?: Maybe<Scalars['String']>;
  /** JWT token, required to authenticate. */
  token?: Maybe<Scalars['String']>;
  /** A user instance. */
  user?: Maybe<User>;
};

export type ShippingError = {
  __typename?: 'ShippingError';
  /** List of channels IDs which causes the error. */
  channels?: Maybe<Array<Scalars['ID']>>;
  /** The error code. */
  code: ShippingErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of warehouse IDs which causes the error. */
  warehouses?: Maybe<Array<Scalars['ID']>>;
};

/** An enumeration. */
export enum ShippingErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  DuplicatedInputItem = 'DUPLICATED_INPUT_ITEM',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  MaxLessThanMin = 'MAX_LESS_THAN_MIN',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethod = Node & ObjectWithMetadata & {
  __typename?: 'ShippingMethod';
  /** Describes if this shipping method is active and can be selected. */
  active: Scalars['Boolean'];
  /** Shipping method description (JSON). */
  description?: Maybe<Scalars['JSONString']>;
  /** Unique ID of ShippingMethod available for Order. */
  id: Scalars['ID'];
  /** Maximum delivery days for this shipping method. */
  maximumDeliveryDays?: Maybe<Scalars['Int']>;
  /** Maximum order price for this shipping method. */
  maximumOrderPrice?: Maybe<Money>;
  /**
   * Maximum order weight for this shipping method.
   * @deprecated This field will be removed in Saleor 4.0.
   */
  maximumOrderWeight?: Maybe<Weight>;
  /** Message connected to this shipping method. */
  message?: Maybe<Scalars['String']>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** Minimum delivery days for this shipping method. */
  minimumDeliveryDays?: Maybe<Scalars['Int']>;
  /** Minimal order price for this shipping method. */
  minimumOrderPrice?: Maybe<Money>;
  /**
   * Minimum order weight for this shipping method.
   * @deprecated This field will be removed in Saleor 4.0.
   */
  minimumOrderWeight?: Maybe<Weight>;
  /** Shipping method name. */
  name: Scalars['String'];
  /** The price of selected shipping method. */
  price: Money;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Returns translated shipping method fields for the given language code. */
  translation?: Maybe<ShippingMethodTranslation>;
  /**
   * Type of the shipping method.
   * @deprecated This field will be removed in Saleor 4.0.
   */
  type?: Maybe<ShippingMethodTypeEnum>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping methods that can be used as means of shipping for orders and checkouts. */
export type ShippingMethodTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Represents shipping method channel listing. */
export type ShippingMethodChannelListing = Node & {
  __typename?: 'ShippingMethodChannelListing';
  channel: Channel;
  id: Scalars['ID'];
  maximumOrderPrice?: Maybe<Money>;
  minimumOrderPrice?: Maybe<Money>;
  price?: Maybe<Money>;
};

export type ShippingMethodChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Maximum order price to use this shipping method. */
  maximumOrderPrice?: InputMaybe<Scalars['PositiveDecimal']>;
  /** Minimum order price to use this shipping method. */
  minimumOrderPrice?: InputMaybe<Scalars['PositiveDecimal']>;
  /** Shipping price of the shipping method in this channel. */
  price?: InputMaybe<Scalars['PositiveDecimal']>;
};

export type ShippingMethodChannelListingInput = {
  /** List of channels to which the shipping method should be assigned. */
  addChannels?: InputMaybe<Array<ShippingMethodChannelListingAddInput>>;
  /** List of channels from which the shipping method should be unassigned. */
  removeChannels?: InputMaybe<Array<Scalars['ID']>>;
};

/** Manage shipping method's availability in channels. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingMethodChannelListingUpdate = {
  __typename?: 'ShippingMethodChannelListingUpdate';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** An updated shipping method instance. */
  shippingMethod?: Maybe<ShippingMethodType>;
};

/** Represents shipping method postal code rule. */
export type ShippingMethodPostalCodeRule = Node & {
  __typename?: 'ShippingMethodPostalCodeRule';
  /** End address range. */
  end?: Maybe<Scalars['String']>;
  /** The ID of the object. */
  id: Scalars['ID'];
  /** Inclusion type of the postal code rule. */
  inclusionType?: Maybe<PostalCodeRuleInclusionTypeEnum>;
  /** Start address range. */
  start?: Maybe<Scalars['String']>;
};

export type ShippingMethodTranslatableContent = Node & {
  __typename?: 'ShippingMethodTranslatableContent';
  description?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  /**
   * Shipping method are the methods you'll use to get customer's orders  to them. They are directly exposed to the customers. Requires one of the following permissions: MANAGE_SHIPPING.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  shippingMethod?: Maybe<ShippingMethodType>;
  /** Returns translated shipping method fields for the given language code. */
  translation?: Maybe<ShippingMethodTranslation>;
};


export type ShippingMethodTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

export type ShippingMethodTranslation = Node & {
  __typename?: 'ShippingMethodTranslation';
  description?: Maybe<Scalars['JSONString']>;
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name?: Maybe<Scalars['String']>;
};

/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodType = Node & ObjectWithMetadata & {
  __typename?: 'ShippingMethodType';
  /** List of channels available for the method. Requires one of the following permissions: MANAGE_SHIPPING. */
  channelListings?: Maybe<Array<ShippingMethodChannelListing>>;
  /** Shipping method description. */
  description?: Maybe<Scalars['JSONString']>;
  /** List of excluded products for the shipping method. Requires one of the following permissions: MANAGE_SHIPPING. */
  excludedProducts?: Maybe<ProductCountableConnection>;
  /** Shipping method ID. */
  id: Scalars['ID'];
  /** Maximum number of days for delivery. */
  maximumDeliveryDays?: Maybe<Scalars['Int']>;
  /** The price of the cheapest variant (including discounts). */
  maximumOrderPrice?: Maybe<Money>;
  /** Maximum order weight to use this shipping method. */
  maximumOrderWeight?: Maybe<Weight>;
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** Minimal number of days for delivery. */
  minimumDeliveryDays?: Maybe<Scalars['Int']>;
  /** The price of the cheapest variant (including discounts). */
  minimumOrderPrice?: Maybe<Money>;
  /** Minimum order weight to use this shipping method. */
  minimumOrderWeight?: Maybe<Weight>;
  /** Shipping method name. */
  name: Scalars['String'];
  /** Postal code ranges rule of exclusion or inclusion of the shipping method. */
  postalCodeRules?: Maybe<Array<ShippingMethodPostalCodeRule>>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** Returns translated shipping method fields for the given language code. */
  translation?: Maybe<ShippingMethodTranslation>;
  /** Type of the shipping method. */
  type?: Maybe<ShippingMethodTypeEnum>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeExcludedProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers. */
export type ShippingMethodTypeTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** An enumeration. */
export enum ShippingMethodTypeEnum {
  Price = 'PRICE',
  Weight = 'WEIGHT'
}

export type ShippingPostalCodeRulesCreateInputRange = {
  /** End range of the postal code. */
  end?: InputMaybe<Scalars['String']>;
  /** Start range of the postal code. */
  start: Scalars['String'];
};

/** Deletes shipping prices. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingPriceBulkDelete = {
  __typename?: 'ShippingPriceBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
};

/** Creates a new shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingPriceCreate = {
  __typename?: 'ShippingPriceCreate';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingMethod?: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingPriceCreated = {
  __typename?: 'ShippingPriceCreated';
  /** Added in Saleor 3.2. Look up a shipping method. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingMethod?: Maybe<ShippingMethodType>;
  /** Added in Saleor 3.2. Look up a shipping zone. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingZone?: Maybe<ShippingZone>;
};


export type ShippingPriceCreatedShippingMethodArgs = {
  channel?: InputMaybe<Scalars['String']>;
};


export type ShippingPriceCreatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingPriceDelete = {
  __typename?: 'ShippingPriceDelete';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** A shipping method to delete. */
  shippingMethod?: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingPriceDeleted = {
  __typename?: 'ShippingPriceDeleted';
  /** Added in Saleor 3.2. Look up a shipping method. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingMethod?: Maybe<ShippingMethodType>;
  /** Added in Saleor 3.2. Look up a shipping zone. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingZone?: Maybe<ShippingZone>;
};


export type ShippingPriceDeletedShippingMethodArgs = {
  channel?: InputMaybe<Scalars['String']>;
};


export type ShippingPriceDeletedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Exclude products from shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingPriceExcludeProducts = {
  __typename?: 'ShippingPriceExcludeProducts';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** A shipping method with new list of excluded products. */
  shippingMethod?: Maybe<ShippingMethodType>;
};

export type ShippingPriceExcludeProductsInput = {
  /** List of products which will be excluded. */
  products: Array<Scalars['ID']>;
};

export type ShippingPriceInput = {
  /** Postal code rules to add. */
  addPostalCodeRules?: InputMaybe<Array<ShippingPostalCodeRulesCreateInputRange>>;
  /** Postal code rules to delete. */
  deletePostalCodeRules?: InputMaybe<Array<Scalars['ID']>>;
  /** Shipping method description. */
  description?: InputMaybe<Scalars['JSONString']>;
  /** Inclusion type for currently assigned postal code rules. */
  inclusionType?: InputMaybe<PostalCodeRuleInclusionTypeEnum>;
  /** Maximum number of days for delivery. */
  maximumDeliveryDays?: InputMaybe<Scalars['Int']>;
  /** Maximum order weight to use this shipping method. */
  maximumOrderWeight?: InputMaybe<Scalars['WeightScalar']>;
  /** Minimal number of days for delivery. */
  minimumDeliveryDays?: InputMaybe<Scalars['Int']>;
  /** Minimum order weight to use this shipping method. */
  minimumOrderWeight?: InputMaybe<Scalars['WeightScalar']>;
  /** Name of the shipping method. */
  name?: InputMaybe<Scalars['String']>;
  /** Shipping zone this method belongs to. */
  shippingZone?: InputMaybe<Scalars['ID']>;
  /** Shipping type: price or weight based. */
  type?: InputMaybe<ShippingMethodTypeEnum>;
};

/** Remove product from excluded list for shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingPriceRemoveProductFromExclude = {
  __typename?: 'ShippingPriceRemoveProductFromExclude';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  /** A shipping method with new list of excluded products. */
  shippingMethod?: Maybe<ShippingMethodType>;
};

/** Creates/updates translations for a shipping method. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type ShippingPriceTranslate = {
  __typename?: 'ShippingPriceTranslate';
  errors: Array<TranslationError>;
  shippingMethod?: Maybe<ShippingMethodType>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ShippingPriceTranslationInput = {
  /** Translated shipping method description (JSON). */
  description?: InputMaybe<Scalars['JSONString']>;
  name?: InputMaybe<Scalars['String']>;
};

/** Updates a new shipping price. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingPriceUpdate = {
  __typename?: 'ShippingPriceUpdate';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingMethod?: Maybe<ShippingMethodType>;
  /** A shipping zone to which the shipping method belongs. */
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingPriceUpdated = {
  __typename?: 'ShippingPriceUpdated';
  /** Added in Saleor 3.2. Look up a shipping method. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingMethod?: Maybe<ShippingMethodType>;
  /** Added in Saleor 3.2. Look up a shipping zone. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingZone?: Maybe<ShippingZone>;
};


export type ShippingPriceUpdatedShippingMethodArgs = {
  channel?: InputMaybe<Scalars['String']>;
};


export type ShippingPriceUpdatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZone = Node & ObjectWithMetadata & {
  __typename?: 'ShippingZone';
  /** List of channels for shipping zone. */
  channels: Array<Channel>;
  /** List of countries available for the method. */
  countries: Array<CountryDisplay>;
  default: Scalars['Boolean'];
  /** Description of a shipping zone. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** Lowest and highest prices for the shipping. */
  priceRange?: Maybe<MoneyRange>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** List of shipping methods available for orders shipped to countries within this shipping zone. */
  shippingMethods?: Maybe<Array<ShippingMethodType>>;
  /** List of warehouses for shipping zone. */
  warehouses: Array<Warehouse>;
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZoneMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZoneMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZonePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly. */
export type ShippingZonePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};

/** Deletes shipping zones. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingZoneBulkDelete = {
  __typename?: 'ShippingZoneBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
};

export type ShippingZoneCountableConnection = {
  __typename?: 'ShippingZoneCountableConnection';
  edges: Array<ShippingZoneCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type ShippingZoneCountableEdge = {
  __typename?: 'ShippingZoneCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: ShippingZone;
};

/** Creates a new shipping zone. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingZoneCreate = {
  __typename?: 'ShippingZoneCreate';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingZoneCreateInput = {
  /** List of channels to assign to the shipping zone. */
  addChannels?: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to assign to a shipping zone */
  addWarehouses?: InputMaybe<Array<Scalars['ID']>>;
  /** List of countries in this shipping zone. */
  countries?: InputMaybe<Array<Scalars['String']>>;
  /** Default shipping zone will be used for countries not covered by other zones. */
  default?: InputMaybe<Scalars['Boolean']>;
  /** Description of the shipping zone. */
  description?: InputMaybe<Scalars['String']>;
  /** Shipping zone's name. Visible only to the staff. */
  name?: InputMaybe<Scalars['String']>;
};

export type ShippingZoneCreated = {
  __typename?: 'ShippingZoneCreated';
  /** Added in Saleor 3.2. Look up a shipping zone. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingZone?: Maybe<ShippingZone>;
};


export type ShippingZoneCreatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a shipping zone. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingZoneDelete = {
  __typename?: 'ShippingZoneDelete';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingZoneDeleted = {
  __typename?: 'ShippingZoneDeleted';
  /** Added in Saleor 3.2. Look up a shipping zone. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingZone?: Maybe<ShippingZone>;
};


export type ShippingZoneDeletedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

export type ShippingZoneFilterInput = {
  channels?: InputMaybe<Array<Scalars['ID']>>;
  search?: InputMaybe<Scalars['String']>;
};

/** Updates a new shipping zone. Requires one of the following permissions: MANAGE_SHIPPING. */
export type ShippingZoneUpdate = {
  __typename?: 'ShippingZoneUpdate';
  errors: Array<ShippingError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shippingErrors: Array<ShippingError>;
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingZoneUpdateInput = {
  /** List of channels to assign to the shipping zone. */
  addChannels?: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to assign to a shipping zone */
  addWarehouses?: InputMaybe<Array<Scalars['ID']>>;
  /** List of countries in this shipping zone. */
  countries?: InputMaybe<Array<Scalars['String']>>;
  /** Default shipping zone will be used for countries not covered by other zones. */
  default?: InputMaybe<Scalars['Boolean']>;
  /** Description of the shipping zone. */
  description?: InputMaybe<Scalars['String']>;
  /** Shipping zone's name. Visible only to the staff. */
  name?: InputMaybe<Scalars['String']>;
  /** List of channels to unassign from the shipping zone. */
  removeChannels?: InputMaybe<Array<Scalars['ID']>>;
  /** List of warehouses to unassign from a shipping zone */
  removeWarehouses?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShippingZoneUpdated = {
  __typename?: 'ShippingZoneUpdated';
  /** Added in Saleor 3.2. Look up a shipping zone. Note: this feature is in a preview state and can be subject to changes at later point. */
  shippingZone?: Maybe<ShippingZone>;
};


export type ShippingZoneUpdatedShippingZoneArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Represents a shop resource containing general shop data and configuration. */
export type Shop = {
  __typename?: 'Shop';
  /** Enable automatic fulfillment for all digital products. Requires one of the following permissions: MANAGE_SETTINGS. */
  automaticFulfillmentDigitalProducts?: Maybe<Scalars['Boolean']>;
  /** List of available external authentications. */
  availableExternalAuthentications: Array<ExternalAuthentication>;
  /** List of available payment gateways. */
  availablePaymentGateways: Array<PaymentGateway>;
  /** Shipping methods that are available for the shop. */
  availableShippingMethods?: Maybe<Array<ShippingMethod>>;
  /** Added in Saleor 3.1. List of all currencies supported by shop's channels. Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP. */
  channelCurrencies: Array<Scalars['String']>;
  /** Charge taxes on shipping. */
  chargeTaxesOnShipping: Scalars['Boolean'];
  /** Company address. */
  companyAddress?: Maybe<Address>;
  /** List of countries available in the shop. */
  countries: Array<CountryDisplay>;
  /** URL of a view where customers can set their password. */
  customerSetPasswordUrl?: Maybe<Scalars['String']>;
  /** Shop's default country. */
  defaultCountry?: Maybe<CountryDisplay>;
  /** Default number of max downloads per digital content URL. Requires one of the following permissions: MANAGE_SETTINGS. */
  defaultDigitalMaxDownloads?: Maybe<Scalars['Int']>;
  /** Default number of days which digital content URL will be valid. Requires one of the following permissions: MANAGE_SETTINGS. */
  defaultDigitalUrlValidDays?: Maybe<Scalars['Int']>;
  /** Default shop's email sender's address. Requires one of the following permissions: MANAGE_SETTINGS. */
  defaultMailSenderAddress?: Maybe<Scalars['String']>;
  /** Default shop's email sender's name. Requires one of the following permissions: MANAGE_SETTINGS. */
  defaultMailSenderName?: Maybe<Scalars['String']>;
  /** Default weight unit. */
  defaultWeightUnit?: Maybe<WeightUnitsEnum>;
  /** Shop's description. */
  description?: Maybe<Scalars['String']>;
  /** Display prices with tax in store. */
  displayGrossPrices: Scalars['Boolean'];
  /** Shop's domain data. */
  domain: Domain;
  /** Added in Saleor 3.1. Allow to approve fulfillments which are unpaid. */
  fulfillmentAllowUnpaid: Scalars['Boolean'];
  /** Added in Saleor 3.1. Automatically approve all new fulfillments. */
  fulfillmentAutoApprove: Scalars['Boolean'];
  /** Header text. */
  headerText?: Maybe<Scalars['String']>;
  /** Include taxes in prices. */
  includeTaxesInPrices: Scalars['Boolean'];
  /** List of the shops's supported languages. */
  languages: Array<LanguageDisplay>;
  /** Added in Saleor 3.1. Default number of maximum line quantity in single checkout (per single checkout line). Note: this feature is in a preview state and can be subject to changes at later point. Requires one of the following permissions: MANAGE_SETTINGS. */
  limitQuantityPerCheckout?: Maybe<Scalars['Int']>;
  /** Resource limitations and current usage if any set for a shop Requires one of the following permissions: AUTHENTICATED_STAFF_USER. */
  limits: LimitInfo;
  /** Shop's name. */
  name: Scalars['String'];
  /** List of available permissions. */
  permissions: Array<Permission>;
  /** List of possible phone prefixes. */
  phonePrefixes: Array<Scalars['String']>;
  /** Added in Saleor 3.1. Default number of minutes stock will be reserved for anonymous checkout or null when stock reservation is disabled. Requires one of the following permissions: MANAGE_SETTINGS. */
  reserveStockDurationAnonymousUser?: Maybe<Scalars['Int']>;
  /** Added in Saleor 3.1. Default number of minutes stock will be reserved for authenticated checkout or null when stock reservation is disabled. Requires one of the following permissions: MANAGE_SETTINGS. */
  reserveStockDurationAuthenticatedUser?: Maybe<Scalars['Int']>;
  /** List of staff notification recipients. Requires one of the following permissions: MANAGE_SETTINGS. */
  staffNotificationRecipients?: Maybe<Array<StaffNotificationRecipient>>;
  /** Enable inventory tracking. */
  trackInventoryByDefault?: Maybe<Scalars['Boolean']>;
  /** Returns translated shop fields for the given language code. */
  translation?: Maybe<ShopTranslation>;
  /** Saleor API version. Requires one of the following permissions: AUTHENTICATED_STAFF_USER, AUTHENTICATED_APP. */
  version: Scalars['String'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopAvailablePaymentGatewaysArgs = {
  channel?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopAvailableShippingMethodsArgs = {
  address?: InputMaybe<AddressInput>;
  channel: Scalars['String'];
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopCountriesArgs = {
  filter?: InputMaybe<CountryFilterInput>;
  languageCode?: InputMaybe<LanguageCodeEnum>;
};


/** Represents a shop resource containing general shop data and configuration. */
export type ShopTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Update the shop's address. If the `null` value is passed, the currently selected address will be deleted. Requires one of the following permissions: MANAGE_SETTINGS. */
export type ShopAddressUpdate = {
  __typename?: 'ShopAddressUpdate';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop?: Maybe<Shop>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

/** Updates site domain of the shop. Requires one of the following permissions: MANAGE_SETTINGS. */
export type ShopDomainUpdate = {
  __typename?: 'ShopDomainUpdate';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop?: Maybe<Shop>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

export type ShopError = {
  __typename?: 'ShopError';
  /** The error code. */
  code: ShopErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum ShopErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  CannotFetchTaxRates = 'CANNOT_FETCH_TAX_RATES',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

/** Fetch tax rates. Requires one of the following permissions: MANAGE_SETTINGS. */
export type ShopFetchTaxRates = {
  __typename?: 'ShopFetchTaxRates';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop?: Maybe<Shop>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

export type ShopSettingsInput = {
  /** Enable automatic fulfillment for all digital products. */
  automaticFulfillmentDigitalProducts?: InputMaybe<Scalars['Boolean']>;
  /** Charge taxes on shipping. */
  chargeTaxesOnShipping?: InputMaybe<Scalars['Boolean']>;
  /** URL of a view where customers can set their password. */
  customerSetPasswordUrl?: InputMaybe<Scalars['String']>;
  /** Default number of max downloads per digital content URL. */
  defaultDigitalMaxDownloads?: InputMaybe<Scalars['Int']>;
  /** Default number of days which digital content URL will be valid. */
  defaultDigitalUrlValidDays?: InputMaybe<Scalars['Int']>;
  /** Default email sender's address. */
  defaultMailSenderAddress?: InputMaybe<Scalars['String']>;
  /** Default email sender's name. */
  defaultMailSenderName?: InputMaybe<Scalars['String']>;
  /** Default weight unit. */
  defaultWeightUnit?: InputMaybe<WeightUnitsEnum>;
  /** SEO description. */
  description?: InputMaybe<Scalars['String']>;
  /** Display prices with tax in store. */
  displayGrossPrices?: InputMaybe<Scalars['Boolean']>;
  /** Added in Saleor 3.1. Enable ability to approve fulfillments which are unpaid. */
  fulfillmentAllowUnpaid?: InputMaybe<Scalars['Boolean']>;
  /** Added in Saleor 3.1. Enable automatic approval of all new fulfillments. */
  fulfillmentAutoApprove?: InputMaybe<Scalars['Boolean']>;
  /** Header text. */
  headerText?: InputMaybe<Scalars['String']>;
  /** Include taxes in prices. */
  includeTaxesInPrices?: InputMaybe<Scalars['Boolean']>;
  /** Added in Saleor 3.1. Default number of maximum line quantity in single checkout. Minimum possible value is 1, default value is 50. Note: this feature is in a preview state and can be subject to changes at later point. */
  limitQuantityPerCheckout?: InputMaybe<Scalars['Int']>;
  /** Added in Saleor 3.1. Default number of minutes stock will be reserved for anonymous checkout. Enter 0 or null to disable. */
  reserveStockDurationAnonymousUser?: InputMaybe<Scalars['Int']>;
  /** Added in Saleor 3.1. Default number of minutes stock will be reserved for authenticated checkout. Enter 0 or null to disable. */
  reserveStockDurationAuthenticatedUser?: InputMaybe<Scalars['Int']>;
  /** Enable inventory tracking. */
  trackInventoryByDefault?: InputMaybe<Scalars['Boolean']>;
};

/** Creates/updates translations for shop settings. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type ShopSettingsTranslate = {
  __typename?: 'ShopSettingsTranslate';
  errors: Array<TranslationError>;
  /** Updated shop settings. */
  shop?: Maybe<Shop>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
};

export type ShopSettingsTranslationInput = {
  description?: InputMaybe<Scalars['String']>;
  headerText?: InputMaybe<Scalars['String']>;
};

/** Updates shop settings. Requires one of the following permissions: MANAGE_SETTINGS. */
export type ShopSettingsUpdate = {
  __typename?: 'ShopSettingsUpdate';
  errors: Array<ShopError>;
  /** Updated shop. */
  shop?: Maybe<Shop>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
};

export type ShopTranslation = Node & {
  __typename?: 'ShopTranslation';
  description: Scalars['String'];
  headerText: Scalars['String'];
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
};

export type SiteDomainInput = {
  /** Domain name for shop. */
  domain?: InputMaybe<Scalars['String']>;
  /** Shop site name. */
  name?: InputMaybe<Scalars['String']>;
};

/** Deletes staff users. Requires one of the following permissions: MANAGE_STAFF. */
export type StaffBulkDelete = {
  __typename?: 'StaffBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<StaffError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  staffErrors: Array<StaffError>;
};

/** Creates a new staff user. Requires one of the following permissions: MANAGE_STAFF. */
export type StaffCreate = {
  __typename?: 'StaffCreate';
  errors: Array<StaffError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  staffErrors: Array<StaffError>;
  user?: Maybe<User>;
};

export type StaffCreateInput = {
  /** List of permission group IDs to which user should be assigned. */
  addGroups?: InputMaybe<Array<Scalars['ID']>>;
  /** The unique email address of the user. */
  email?: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** A note about the user. */
  note?: InputMaybe<Scalars['String']>;
  /** URL of a view where users should be redirected to set the password. URL in RFC 1808 format. */
  redirectUrl?: InputMaybe<Scalars['String']>;
};

/** Deletes a staff user. Requires one of the following permissions: MANAGE_STAFF. */
export type StaffDelete = {
  __typename?: 'StaffDelete';
  errors: Array<StaffError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  staffErrors: Array<StaffError>;
  user?: Maybe<User>;
};

export type StaffError = {
  __typename?: 'StaffError';
  /** A type of address that causes the error. */
  addressType?: Maybe<AddressTypeEnum>;
  /** The error code. */
  code: AccountErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** List of permission group IDs which cause the error. */
  groups?: Maybe<Array<Scalars['ID']>>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
  /** List of permissions which causes the error. */
  permissions?: Maybe<Array<PermissionEnum>>;
  /** List of user IDs which causes the error. */
  users?: Maybe<Array<Scalars['ID']>>;
};

export enum StaffMemberStatus {
  /** User account has been activated. */
  Active = 'ACTIVE',
  /** User account has not been activated yet. */
  Deactivated = 'DEACTIVATED'
}

/** Represents a recipient of email notifications send by Saleor, such as notifications about new orders. Notifications can be assigned to staff users or arbitrary email addresses. */
export type StaffNotificationRecipient = Node & {
  __typename?: 'StaffNotificationRecipient';
  /** Determines if a notification active. */
  active?: Maybe<Scalars['Boolean']>;
  /** Returns email address of a user subscribed to email notifications. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Returns a user subscribed to email notifications. */
  user?: Maybe<User>;
};

/** Creates a new staff notification recipient. Requires one of the following permissions: MANAGE_SETTINGS. */
export type StaffNotificationRecipientCreate = {
  __typename?: 'StaffNotificationRecipientCreate';
  errors: Array<ShopError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
  staffNotificationRecipient?: Maybe<StaffNotificationRecipient>;
};

/** Delete staff notification recipient. Requires one of the following permissions: MANAGE_SETTINGS. */
export type StaffNotificationRecipientDelete = {
  __typename?: 'StaffNotificationRecipientDelete';
  errors: Array<ShopError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
  staffNotificationRecipient?: Maybe<StaffNotificationRecipient>;
};

export type StaffNotificationRecipientInput = {
  /** Determines if a notification active. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Email address of a user subscribed to email notifications. */
  email?: InputMaybe<Scalars['String']>;
  /** The ID of the user subscribed to email notifications.. */
  user?: InputMaybe<Scalars['ID']>;
};

/** Updates a staff notification recipient. Requires one of the following permissions: MANAGE_SETTINGS. */
export type StaffNotificationRecipientUpdate = {
  __typename?: 'StaffNotificationRecipientUpdate';
  errors: Array<ShopError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  shopErrors: Array<ShopError>;
  staffNotificationRecipient?: Maybe<StaffNotificationRecipient>;
};

/** Updates an existing staff user. Requires one of the following permissions: MANAGE_STAFF. */
export type StaffUpdate = {
  __typename?: 'StaffUpdate';
  errors: Array<StaffError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  staffErrors: Array<StaffError>;
  user?: Maybe<User>;
};

export type StaffUpdateInput = {
  /** List of permission group IDs to which user should be assigned. */
  addGroups?: InputMaybe<Array<Scalars['ID']>>;
  /** The unique email address of the user. */
  email?: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** A note about the user. */
  note?: InputMaybe<Scalars['String']>;
  /** List of permission group IDs from which user should be unassigned. */
  removeGroups?: InputMaybe<Array<Scalars['ID']>>;
};

export type StaffUserInput = {
  ids?: InputMaybe<Array<Scalars['ID']>>;
  search?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<StaffMemberStatus>;
};

/** Represents stock. */
export type Stock = Node & {
  __typename?: 'Stock';
  id: Scalars['ID'];
  productVariant: ProductVariant;
  /** Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  quantity: Scalars['Int'];
  /** Quantity allocated for orders. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  quantityAllocated: Scalars['Int'];
  /** Quantity reserved for checkouts. Requires one of the following permissions: MANAGE_PRODUCTS, MANAGE_ORDERS. */
  quantityReserved: Scalars['Int'];
  warehouse: Warehouse;
};

export enum StockAvailability {
  InStock = 'IN_STOCK',
  OutOfStock = 'OUT_OF_STOCK'
}

export type StockCountableConnection = {
  __typename?: 'StockCountableConnection';
  edges: Array<StockCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type StockCountableEdge = {
  __typename?: 'StockCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Stock;
};

export type StockError = {
  __typename?: 'StockError';
  /** The error code. */
  code: StockErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum StockErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type StockFilterInput = {
  quantity?: InputMaybe<Scalars['Float']>;
  search?: InputMaybe<Scalars['String']>;
};

export type StockInput = {
  /** Quantity of items available for sell. */
  quantity: Scalars['Int'];
  /** Warehouse in which stock is located. */
  warehouse: Scalars['ID'];
};

/** Enum representing the type of a payment storage in a gateway. */
export enum StorePaymentMethodEnum {
  /** Storage is disabled. The payment is not stored. */
  None = 'NONE',
  /** Off session storage type. The payment is stored to be reused even if the customer is absent. */
  OffSession = 'OFF_SESSION',
  /** On session storage type. The payment is stored only to be reused when the customer is present in the checkout flow. */
  OnSession = 'ON_SESSION'
}

export type Subscription = {
  __typename?: 'Subscription';
  /** Added in Saleor 3.2. Look up subscription event. Note: this feature is in a preview state and can be subject to changes at later point. */
  event?: Maybe<Event>;
};

/** Representation of tax types fetched from tax gateway. */
export type TaxType = {
  __typename?: 'TaxType';
  /** Description of the tax type. */
  description?: Maybe<Scalars['String']>;
  /** External tax code used to identify given tax group. */
  taxCode?: Maybe<Scalars['String']>;
};

/** Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal. */
export type TaxedMoney = {
  __typename?: 'TaxedMoney';
  /** Currency code. */
  currency: Scalars['String'];
  /** Amount of money including taxes. */
  gross: Money;
  /** Amount of money without taxes. */
  net: Money;
  /** Amount of taxes. */
  tax: Money;
};

/** Represents a range of monetary values. */
export type TaxedMoneyRange = {
  __typename?: 'TaxedMoneyRange';
  /** Lower bound of a price range. */
  start?: Maybe<TaxedMoney>;
  /** Upper bound of a price range. */
  stop?: Maybe<TaxedMoney>;
};

export type TimePeriod = {
  __typename?: 'TimePeriod';
  /** The length of the period. */
  amount: Scalars['Int'];
  /** The type of the period. */
  type: TimePeriodTypeEnum;
};

export type TimePeriodInputType = {
  /** The length of the period. */
  amount: Scalars['Int'];
  /** The type of the period. */
  type: TimePeriodTypeEnum;
};

/** An enumeration. */
export enum TimePeriodTypeEnum {
  Day = 'DAY',
  Month = 'MONTH',
  Week = 'WEEK',
  Year = 'YEAR'
}

/** An object representing a single payment. */
export type Transaction = Node & {
  __typename?: 'Transaction';
  /** Total amount of the transaction. */
  amount?: Maybe<Money>;
  created: Scalars['DateTime'];
  error?: Maybe<Scalars['String']>;
  gatewayResponse: Scalars['JSONString'];
  id: Scalars['ID'];
  isSuccess: Scalars['Boolean'];
  kind: TransactionKind;
  payment: Payment;
  token: Scalars['String'];
};

/** An enumeration. */
export enum TransactionKind {
  ActionToConfirm = 'ACTION_TO_CONFIRM',
  Auth = 'AUTH',
  Cancel = 'CANCEL',
  Capture = 'CAPTURE',
  Confirm = 'CONFIRM',
  External = 'EXTERNAL',
  Pending = 'PENDING',
  Refund = 'REFUND',
  RefundOngoing = 'REFUND_ONGOING',
  Void = 'VOID'
}

export type TranslatableItem = AttributeTranslatableContent | AttributeValueTranslatableContent | CategoryTranslatableContent | CollectionTranslatableContent | MenuItemTranslatableContent | PageTranslatableContent | ProductTranslatableContent | ProductVariantTranslatableContent | SaleTranslatableContent | ShippingMethodTranslatableContent | VoucherTranslatableContent;

export type TranslatableItemConnection = {
  __typename?: 'TranslatableItemConnection';
  edges: Array<TranslatableItemEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type TranslatableItemEdge = {
  __typename?: 'TranslatableItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: TranslatableItem;
};

export enum TranslatableKinds {
  Attribute = 'ATTRIBUTE',
  AttributeValue = 'ATTRIBUTE_VALUE',
  Category = 'CATEGORY',
  Collection = 'COLLECTION',
  MenuItem = 'MENU_ITEM',
  Page = 'PAGE',
  Product = 'PRODUCT',
  Sale = 'SALE',
  ShippingMethod = 'SHIPPING_METHOD',
  Variant = 'VARIANT',
  Voucher = 'VOUCHER'
}

export type TranslationCreated = {
  __typename?: 'TranslationCreated';
  /** Added in Saleor 3.2. Look up a translation. Note: this feature is in a preview state and can be subject to changes at later point. */
  translation?: Maybe<TranslationTypes>;
};

export type TranslationError = {
  __typename?: 'TranslationError';
  /** The error code. */
  code: TranslationErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum TranslationErrorCode {
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED'
}

export type TranslationInput = {
  description?: InputMaybe<Scalars['JSONString']>;
  name?: InputMaybe<Scalars['String']>;
  seoDescription?: InputMaybe<Scalars['String']>;
  seoTitle?: InputMaybe<Scalars['String']>;
};

export type TranslationTypes = AttributeTranslation | AttributeValueTranslation | CategoryTranslation | CollectionTranslation | MenuItemTranslation | PageTranslation | ProductTranslation | ProductVariantTranslation | SaleTranslation | ShippingMethodTranslation | VoucherTranslation;

export type TranslationUpdated = {
  __typename?: 'TranslationUpdated';
  /** Added in Saleor 3.2. Look up a translation. Note: this feature is in a preview state and can be subject to changes at later point. */
  translation?: Maybe<TranslationTypes>;
};

export type UpdateInvoiceInput = {
  /** Invoice number */
  number?: InputMaybe<Scalars['String']>;
  /** URL of an invoice to download. */
  url?: InputMaybe<Scalars['String']>;
};

/** Updates metadata of an object. To use it, you need to have access to the modified object. */
export type UpdateMetadata = {
  __typename?: 'UpdateMetadata';
  errors: Array<MetadataError>;
  item?: Maybe<ObjectWithMetadata>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

/** Updates private metadata of an object. To use it, you need to be an authenticated staff user or an app and have access to the modified object. */
export type UpdatePrivateMetadata = {
  __typename?: 'UpdatePrivateMetadata';
  errors: Array<MetadataError>;
  item?: Maybe<ObjectWithMetadata>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  metadataErrors: Array<MetadataError>;
};

export type UploadError = {
  __typename?: 'UploadError';
  /** The error code. */
  code: UploadErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum UploadErrorCode {
  GraphqlError = 'GRAPHQL_ERROR'
}

/** Represents user data. */
export type User = Node & ObjectWithMetadata & {
  __typename?: 'User';
  /** List of all user's addresses. */
  addresses?: Maybe<Array<Address>>;
  avatar?: Maybe<Image>;
  /**
   * Returns the last open checkout of this user.
   * @deprecated This field will be removed in Saleor 4.0. Use the `checkoutTokens` field to fetch the user checkouts.
   */
  checkout?: Maybe<Checkout>;
  /** Returns the checkout UUID's assigned to this user. */
  checkoutTokens?: Maybe<Array<Scalars['UUID']>>;
  dateJoined: Scalars['DateTime'];
  defaultBillingAddress?: Maybe<Address>;
  defaultShippingAddress?: Maybe<Address>;
  /** List of user's permission groups which user can manage. */
  editableGroups?: Maybe<Array<Group>>;
  email: Scalars['String'];
  /** List of events associated with the user. Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF. */
  events?: Maybe<Array<CustomerEvent>>;
  firstName: Scalars['String'];
  /** List of the user gift cards. */
  giftCards?: Maybe<GiftCardCountableConnection>;
  id: Scalars['ID'];
  isActive: Scalars['Boolean'];
  isStaff: Scalars['Boolean'];
  /** User language code. */
  languageCode: LanguageCodeEnum;
  lastLogin?: Maybe<Scalars['DateTime']>;
  lastName: Scalars['String'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  /** A note about the customer. Requires one of the following permissions: MANAGE_USERS, MANAGE_STAFF. */
  note?: Maybe<Scalars['String']>;
  /** List of user's orders. Requires one of the following permissions: AccountPermissions.MANAGE_STAFF, AuthorizationFilters.OWNER */
  orders?: Maybe<OrderCountableConnection>;
  /** List of user's permission groups. */
  permissionGroups?: Maybe<Array<Group>>;
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** List of stored payment sources. */
  storedPaymentSources?: Maybe<Array<PaymentSource>>;
  updatedAt: Scalars['DateTime'];
  /** List of user's permissions. */
  userPermissions?: Maybe<Array<UserPermission>>;
};


/** Represents user data. */
export type UserAvatarArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserCheckoutTokensArgs = {
  channel?: InputMaybe<Scalars['String']>;
};


/** Represents user data. */
export type UserGiftCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents user data. */
export type UserMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents user data. */
export type UserOrdersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents user data. */
export type UserPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents user data. */
export type UserPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents user data. */
export type UserStoredPaymentSourcesArgs = {
  channel?: InputMaybe<Scalars['String']>;
};

/** Deletes a user avatar. Only for staff members. Requires one of the following permissions: AUTHENTICATED_STAFF_USER. */
export type UserAvatarDelete = {
  __typename?: 'UserAvatarDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user?: Maybe<User>;
};

/** Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec Requires one of the following permissions: AUTHENTICATED_STAFF_USER. */
export type UserAvatarUpdate = {
  __typename?: 'UserAvatarUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** An updated user instance. */
  user?: Maybe<User>;
};

/** Activate or deactivate users. Requires one of the following permissions: MANAGE_USERS. */
export type UserBulkSetActive = {
  __typename?: 'UserBulkSetActive';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  errors: Array<AccountError>;
};

export type UserCountableConnection = {
  __typename?: 'UserCountableConnection';
  edges: Array<UserCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type UserCountableEdge = {
  __typename?: 'UserCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: User;
};

export type UserCreateInput = {
  /** Slug of a channel which will be used for notify user. Optional when only one channel exists. */
  channel?: InputMaybe<Scalars['String']>;
  /** Billing address of the customer. */
  defaultBillingAddress?: InputMaybe<AddressInput>;
  /** Shipping address of the customer. */
  defaultShippingAddress?: InputMaybe<AddressInput>;
  /** The unique email address of the user. */
  email?: InputMaybe<Scalars['String']>;
  /** Given name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User account is active. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** User language code. */
  languageCode?: InputMaybe<LanguageCodeEnum>;
  /** Family name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** A note about the user. */
  note?: InputMaybe<Scalars['String']>;
  /** URL of a view where users should be redirected to set the password. URL in RFC 1808 format. */
  redirectUrl?: InputMaybe<Scalars['String']>;
};

export type UserPermission = {
  __typename?: 'UserPermission';
  /** Internal code for permission. */
  code: PermissionEnum;
  /** Describe action(s) allowed to do by permission. */
  name: Scalars['String'];
  /** List of user permission groups which contains this permission. */
  sourcePermissionGroups?: Maybe<Array<Group>>;
};


export type UserPermissionSourcePermissionGroupsArgs = {
  userId: Scalars['ID'];
};

export enum UserSortField {
  /** Sort users by created at. */
  CreatedAt = 'CREATED_AT',
  /** Sort users by email. */
  Email = 'EMAIL',
  /** Sort users by first name. */
  FirstName = 'FIRST_NAME',
  /** Sort users by last modified at. */
  LastModifiedAt = 'LAST_MODIFIED_AT',
  /** Sort users by last name. */
  LastName = 'LAST_NAME',
  /** Sort users by order count. */
  OrderCount = 'ORDER_COUNT'
}

export type UserSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort users by the selected field. */
  field: UserSortField;
};

/** Represents a VAT rate for a country. */
export type Vat = {
  __typename?: 'VAT';
  /** Country code. */
  countryCode: Scalars['String'];
  /** Country's VAT rate exceptions for specific types of goods. */
  reducedRates: Array<ReducedRate>;
  /** Standard VAT rate in percent. */
  standardRate?: Maybe<Scalars['Float']>;
};

export enum VariantAttributeScope {
  All = 'ALL',
  NotVariantSelection = 'NOT_VARIANT_SELECTION',
  VariantSelection = 'VARIANT_SELECTION'
}

/** Assign an media to a product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type VariantMediaAssign = {
  __typename?: 'VariantMediaAssign';
  errors: Array<ProductError>;
  media?: Maybe<ProductMedia>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant?: Maybe<ProductVariant>;
};

/** Unassign an media from a product variant. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type VariantMediaUnassign = {
  __typename?: 'VariantMediaUnassign';
  errors: Array<ProductError>;
  media?: Maybe<ProductMedia>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  productErrors: Array<ProductError>;
  productVariant?: Maybe<ProductVariant>;
};

/** Represents availability of a variant in the storefront. */
export type VariantPricingInfo = {
  __typename?: 'VariantPricingInfo';
  /** The discount amount if in sale (null otherwise). */
  discount?: Maybe<TaxedMoney>;
  /** The discount amount in the local currency. */
  discountLocalCurrency?: Maybe<TaxedMoney>;
  /** Whether it is in sale or not. */
  onSale?: Maybe<Scalars['Boolean']>;
  /** The price, with any discount subtracted. */
  price?: Maybe<TaxedMoney>;
  /** The discounted price in the local currency. */
  priceLocalCurrency?: Maybe<TaxedMoney>;
  /** The price without any discount. */
  priceUndiscounted?: Maybe<TaxedMoney>;
};

/** Verify JWT token. */
export type VerifyToken = {
  __typename?: 'VerifyToken';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  accountErrors: Array<AccountError>;
  errors: Array<AccountError>;
  /** Determine if token is valid or not. */
  isValid: Scalars['Boolean'];
  /** JWT payload. */
  payload?: Maybe<Scalars['GenericScalar']>;
  /** User assigned to token. */
  user?: Maybe<User>;
};

/** An enumeration. */
export enum VolumeUnitsEnum {
  AcreFt = 'ACRE_FT',
  AcreIn = 'ACRE_IN',
  CubicCentimeter = 'CUBIC_CENTIMETER',
  CubicDecimeter = 'CUBIC_DECIMETER',
  CubicFoot = 'CUBIC_FOOT',
  CubicInch = 'CUBIC_INCH',
  CubicMeter = 'CUBIC_METER',
  CubicMillimeter = 'CUBIC_MILLIMETER',
  CubicYard = 'CUBIC_YARD',
  FlOz = 'FL_OZ',
  Liter = 'LITER',
  Pint = 'PINT',
  Qt = 'QT'
}

/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type Voucher = Node & ObjectWithMetadata & {
  __typename?: 'Voucher';
  applyOncePerCustomer: Scalars['Boolean'];
  applyOncePerOrder: Scalars['Boolean'];
  /** List of categories this voucher applies to. */
  categories?: Maybe<CategoryCountableConnection>;
  /** List of availability in channels for the voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  channelListings?: Maybe<Array<VoucherChannelListing>>;
  code: Scalars['String'];
  /** List of collections this voucher applies to. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  collections?: Maybe<CollectionCountableConnection>;
  /** List of countries available for the shipping voucher. */
  countries?: Maybe<Array<CountryDisplay>>;
  /** Currency code for voucher. */
  currency?: Maybe<Scalars['String']>;
  /** Voucher value. */
  discountValue?: Maybe<Scalars['Float']>;
  /** Determines a type of discount for voucher - value or percentage */
  discountValueType: DiscountValueTypeEnum;
  endDate?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  minCheckoutItemsQuantity?: Maybe<Scalars['Int']>;
  /** Minimum order value to apply voucher. */
  minSpent?: Maybe<Money>;
  name?: Maybe<Scalars['String']>;
  onlyForStaff: Scalars['Boolean'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  /** List of products this voucher applies to. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  products?: Maybe<ProductCountableConnection>;
  startDate: Scalars['DateTime'];
  /** Returns translated voucher fields for the given language code. */
  translation?: Maybe<VoucherTranslation>;
  /** Determines a type of voucher. */
  type: VoucherTypeEnum;
  usageLimit?: Maybe<Scalars['Int']>;
  used: Scalars['Int'];
  /** Added in Saleor 3.1. List of product variants this voucher applies to. Requires one of the following permissions: MANAGE_DISCOUNTS. */
  variants?: Maybe<ProductVariantCountableConnection>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherCollectionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherMetafieldArgs = {
  key: Scalars['String'];
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherPrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherPrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherProductsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherTranslationArgs = {
  languageCode: LanguageCodeEnum;
};


/** Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. */
export type VoucherVariantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Adds products, categories, collections to a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherAddCatalogues = {
  __typename?: 'VoucherAddCatalogues';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Voucher of which catalogue IDs will be modified. */
  voucher?: Maybe<Voucher>;
};

/** Deletes vouchers. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherBulkDelete = {
  __typename?: 'VoucherBulkDelete';
  /** Returns how many objects were affected. */
  count: Scalars['Int'];
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
};

/** Represents voucher channel listing. */
export type VoucherChannelListing = Node & {
  __typename?: 'VoucherChannelListing';
  channel: Channel;
  currency: Scalars['String'];
  discountValue: Scalars['Float'];
  id: Scalars['ID'];
  minSpent?: Maybe<Money>;
};

export type VoucherChannelListingAddInput = {
  /** ID of a channel. */
  channelId: Scalars['ID'];
  /** Value of the voucher. */
  discountValue?: InputMaybe<Scalars['PositiveDecimal']>;
  /** Min purchase amount required to apply the voucher. */
  minAmountSpent?: InputMaybe<Scalars['PositiveDecimal']>;
};

export type VoucherChannelListingInput = {
  /** List of channels to which the voucher should be assigned. */
  addChannels?: InputMaybe<Array<VoucherChannelListingAddInput>>;
  /** List of channels from which the voucher should be unassigned. */
  removeChannels?: InputMaybe<Array<Scalars['ID']>>;
};

/** Manage voucher's availability in channels. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherChannelListingUpdate = {
  __typename?: 'VoucherChannelListingUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** An updated voucher instance. */
  voucher?: Maybe<Voucher>;
};

export type VoucherCountableConnection = {
  __typename?: 'VoucherCountableConnection';
  edges: Array<VoucherCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type VoucherCountableEdge = {
  __typename?: 'VoucherCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Voucher;
};

/** Creates a new voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherCreate = {
  __typename?: 'VoucherCreate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  voucher?: Maybe<Voucher>;
};

/** Deletes a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherDelete = {
  __typename?: 'VoucherDelete';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  voucher?: Maybe<Voucher>;
};

export enum VoucherDiscountType {
  Fixed = 'FIXED',
  Percentage = 'PERCENTAGE',
  Shipping = 'SHIPPING'
}

export type VoucherFilterInput = {
  discountType?: InputMaybe<Array<VoucherDiscountType>>;
  metadata?: InputMaybe<Array<MetadataFilter>>;
  search?: InputMaybe<Scalars['String']>;
  started?: InputMaybe<DateTimeRangeInput>;
  status?: InputMaybe<Array<DiscountStatusEnum>>;
  timesUsed?: InputMaybe<IntRangeInput>;
};

export type VoucherInput = {
  /** Voucher should be applied once per customer. */
  applyOncePerCustomer?: InputMaybe<Scalars['Boolean']>;
  /** Voucher should be applied to the cheapest item or entire order. */
  applyOncePerOrder?: InputMaybe<Scalars['Boolean']>;
  /** Categories discounted by the voucher. */
  categories?: InputMaybe<Array<Scalars['ID']>>;
  /** Code to use the voucher. */
  code?: InputMaybe<Scalars['String']>;
  /** Collections discounted by the voucher. */
  collections?: InputMaybe<Array<Scalars['ID']>>;
  /** Country codes that can be used with the shipping voucher. */
  countries?: InputMaybe<Array<Scalars['String']>>;
  /** Choices: fixed or percentage. */
  discountValueType?: InputMaybe<DiscountValueTypeEnum>;
  /** End date of the voucher in ISO 8601 format. */
  endDate?: InputMaybe<Scalars['DateTime']>;
  /** Minimal quantity of checkout items required to apply the voucher. */
  minCheckoutItemsQuantity?: InputMaybe<Scalars['Int']>;
  /** Voucher name. */
  name?: InputMaybe<Scalars['String']>;
  /** Voucher can be used only by staff user. */
  onlyForStaff?: InputMaybe<Scalars['Boolean']>;
  /** Products discounted by the voucher. */
  products?: InputMaybe<Array<Scalars['ID']>>;
  /** Start date of the voucher in ISO 8601 format. */
  startDate?: InputMaybe<Scalars['DateTime']>;
  /** Voucher type: PRODUCT, CATEGORY SHIPPING or ENTIRE_ORDER. */
  type?: InputMaybe<VoucherTypeEnum>;
  /** Limit number of times this voucher can be used in total. */
  usageLimit?: InputMaybe<Scalars['Int']>;
  /** Added in Saleor 3.1. Variants discounted by the voucher. */
  variants?: InputMaybe<Array<Scalars['ID']>>;
};

/** Removes products, categories, collections from a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherRemoveCatalogues = {
  __typename?: 'VoucherRemoveCatalogues';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  /** Voucher of which catalogue IDs will be modified. */
  voucher?: Maybe<Voucher>;
};

export enum VoucherSortField {
  /** Sort vouchers by code. */
  Code = 'CODE',
  /** Sort vouchers by end date. */
  EndDate = 'END_DATE',
  /** Sort vouchers by minimum spent amount. */
  MinimumSpentAmount = 'MINIMUM_SPENT_AMOUNT',
  /** Sort vouchers by start date. */
  StartDate = 'START_DATE',
  /** Sort vouchers by type. */
  Type = 'TYPE',
  /** Sort vouchers by usage limit. */
  UsageLimit = 'USAGE_LIMIT',
  /** Sort vouchers by value. */
  Value = 'VALUE'
}

export type VoucherSortingInput = {
  /**
   * Specifies the channel in which to sort the data.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use root-level channel argument instead.
   */
  channel?: InputMaybe<Scalars['String']>;
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort vouchers by the selected field. */
  field: VoucherSortField;
};

export type VoucherTranslatableContent = Node & {
  __typename?: 'VoucherTranslatableContent';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  /** Returns translated voucher fields for the given language code. */
  translation?: Maybe<VoucherTranslation>;
  /**
   * Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes. Requires one of the following permissions: MANAGE_DISCOUNTS.
   * @deprecated This field will be removed in Saleor 4.0. Get model fields from the root level queries.
   */
  voucher?: Maybe<Voucher>;
};


export type VoucherTranslatableContentTranslationArgs = {
  languageCode: LanguageCodeEnum;
};

/** Creates/updates translations for a voucher. Requires one of the following permissions: MANAGE_TRANSLATIONS. */
export type VoucherTranslate = {
  __typename?: 'VoucherTranslate';
  errors: Array<TranslationError>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  translationErrors: Array<TranslationError>;
  voucher?: Maybe<Voucher>;
};

export type VoucherTranslation = Node & {
  __typename?: 'VoucherTranslation';
  id: Scalars['ID'];
  /** Translation language. */
  language: LanguageDisplay;
  name?: Maybe<Scalars['String']>;
};

export enum VoucherTypeEnum {
  EntireOrder = 'ENTIRE_ORDER',
  Shipping = 'SHIPPING',
  SpecificProduct = 'SPECIFIC_PRODUCT'
}

/** Updates a voucher. Requires one of the following permissions: MANAGE_DISCOUNTS. */
export type VoucherUpdate = {
  __typename?: 'VoucherUpdate';
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  discountErrors: Array<DiscountError>;
  errors: Array<DiscountError>;
  voucher?: Maybe<Voucher>;
};

/** Represents warehouse. */
export type Warehouse = Node & ObjectWithMetadata & {
  __typename?: 'Warehouse';
  address: Address;
  /** Added in Saleor 3.1. Click and collect options: local, all or disabled. Note: this feature is in a preview state and can be subject to changes at later point. */
  clickAndCollectOption: WarehouseClickAndCollectOptionEnum;
  /**
   * Warehouse company name.
   * @deprecated This field will be removed in Saleor 4.0. Use `Address.companyName` instead.
   */
  companyName: Scalars['String'];
  email: Scalars['String'];
  id: Scalars['ID'];
  isPrivate: Scalars['Boolean'];
  /** List of public metadata items. Can be accessed without permissions. */
  metadata: Array<MetadataItem>;
  /**
   * A single key from public metadata.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafield?: Maybe<Scalars['String']>;
  /**
   * Public metadata. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  metafields?: Maybe<Scalars['Metadata']>;
  name: Scalars['String'];
  /** List of private metadata items. Requires staff permissions to access. */
  privateMetadata: Array<MetadataItem>;
  /**
   * A single key from private metadata. Requires staff permissions to access.
   *
   * Tip: Use GraphQL aliases to fetch multiple keys.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafield?: Maybe<Scalars['String']>;
  /**
   * Private metadata. Requires staff permissions to access. Use `keys` to control which fields you want to include. The default is to include everything.
   *
   * Added in Saleor 3.3.
   *
   * Note: this feature is in a preview state and can be subject to changes at later point.
   */
  privateMetafields?: Maybe<Scalars['Metadata']>;
  shippingZones: ShippingZoneCountableConnection;
  slug: Scalars['String'];
};


/** Represents warehouse. */
export type WarehouseMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents warehouse. */
export type WarehouseMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents warehouse. */
export type WarehousePrivateMetafieldArgs = {
  key: Scalars['String'];
};


/** Represents warehouse. */
export type WarehousePrivateMetafieldsArgs = {
  keys?: InputMaybe<Array<Scalars['String']>>;
};


/** Represents warehouse. */
export type WarehouseShippingZonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An enumeration. */
export enum WarehouseClickAndCollectOptionEnum {
  All = 'ALL',
  Disabled = 'DISABLED',
  Local = 'LOCAL'
}

export type WarehouseCountableConnection = {
  __typename?: 'WarehouseCountableConnection';
  edges: Array<WarehouseCountableEdge>;
  /** Pagination data for this connection. */
  pageInfo: PageInfo;
  /** A total count of items in the collection. */
  totalCount?: Maybe<Scalars['Int']>;
};

export type WarehouseCountableEdge = {
  __typename?: 'WarehouseCountableEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node: Warehouse;
};

/** Creates new warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type WarehouseCreate = {
  __typename?: 'WarehouseCreate';
  errors: Array<WarehouseError>;
  warehouse?: Maybe<Warehouse>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export type WarehouseCreateInput = {
  /** Address of the warehouse. */
  address: AddressInput;
  /** The email address of the warehouse. */
  email?: InputMaybe<Scalars['String']>;
  /** Warehouse name. */
  name: Scalars['String'];
  /** Shipping zones supported by the warehouse. */
  shippingZones?: InputMaybe<Array<Scalars['ID']>>;
  /** Warehouse slug. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Deletes selected warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type WarehouseDelete = {
  __typename?: 'WarehouseDelete';
  errors: Array<WarehouseError>;
  warehouse?: Maybe<Warehouse>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export type WarehouseError = {
  __typename?: 'WarehouseError';
  /** The error code. */
  code: WarehouseErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum WarehouseErrorCode {
  AlreadyExists = 'ALREADY_EXISTS',
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

export type WarehouseFilterInput = {
  clickAndCollectOption?: InputMaybe<WarehouseClickAndCollectOptionEnum>;
  ids?: InputMaybe<Array<Scalars['ID']>>;
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  search?: InputMaybe<Scalars['String']>;
};

/** Add shipping zone to given warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type WarehouseShippingZoneAssign = {
  __typename?: 'WarehouseShippingZoneAssign';
  errors: Array<WarehouseError>;
  warehouse?: Maybe<Warehouse>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

/** Remove shipping zone from given warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type WarehouseShippingZoneUnassign = {
  __typename?: 'WarehouseShippingZoneUnassign';
  errors: Array<WarehouseError>;
  warehouse?: Maybe<Warehouse>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export enum WarehouseSortField {
  /** Sort warehouses by name. */
  Name = 'NAME'
}

export type WarehouseSortingInput = {
  /** Specifies the direction in which to sort products. */
  direction: OrderDirection;
  /** Sort warehouses by the selected field. */
  field: WarehouseSortField;
};

/** Updates given warehouse. Requires one of the following permissions: MANAGE_PRODUCTS. */
export type WarehouseUpdate = {
  __typename?: 'WarehouseUpdate';
  errors: Array<WarehouseError>;
  warehouse?: Maybe<Warehouse>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  warehouseErrors: Array<WarehouseError>;
};

export type WarehouseUpdateInput = {
  /** Address of the warehouse. */
  address?: InputMaybe<AddressInput>;
  /** Added in Saleor 3.1. Click and collect options: local, all or disabled. Note: this feature is in a preview state and can be subject to changes at later point. */
  clickAndCollectOption?: InputMaybe<WarehouseClickAndCollectOptionEnum>;
  /** The email address of the warehouse. */
  email?: InputMaybe<Scalars['String']>;
  /** Added in Saleor 3.1. Visibility of warehouse stocks. Note: this feature is in a preview state and can be subject to changes at later point. */
  isPrivate?: InputMaybe<Scalars['Boolean']>;
  /** Warehouse name. */
  name?: InputMaybe<Scalars['String']>;
  /** Warehouse slug. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Webhook. */
export type Webhook = Node & {
  __typename?: 'Webhook';
  app: App;
  /** List of asynchronous webhook events. */
  asyncEvents: Array<WebhookEventAsync>;
  /** Event deliveries. */
  eventDeliveries?: Maybe<EventDeliveryCountableConnection>;
  /**
   * List of webhook events.
   * @deprecated This field will be removed in Saleor 4.0. Use `asyncEvents` or `syncEvents` instead.
   */
  events: Array<WebhookEvent>;
  id: Scalars['ID'];
  /** Informs if webhook is activated. */
  isActive: Scalars['Boolean'];
  name: Scalars['String'];
  /** Used to create a hash signature with each payload. */
  secretKey?: Maybe<Scalars['String']>;
  /** Used to define payloads for specific events. */
  subscriptionQuery?: Maybe<Scalars['String']>;
  /** List of synchronous webhook events. */
  syncEvents: Array<WebhookEventSync>;
  /** Target URL for webhook. */
  targetUrl: Scalars['String'];
};


/** Webhook. */
export type WebhookEventDeliveriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<EventDeliveryFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortBy?: InputMaybe<EventDeliverySortingInput>;
};

/** Creates a new webhook subscription. Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP. */
export type WebhookCreate = {
  __typename?: 'WebhookCreate';
  errors: Array<WebhookError>;
  webhook?: Maybe<Webhook>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  webhookErrors: Array<WebhookError>;
};

export type WebhookCreateInput = {
  /** ID of the app to which webhook belongs. */
  app?: InputMaybe<Scalars['ID']>;
  /** The asynchronous events that webhook wants to subscribe. */
  asyncEvents?: InputMaybe<Array<WebhookEventTypeAsyncEnum>>;
  /**
   * The events that webhook wants to subscribe.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `asyncEvents` or `syncEvents` instead.
   */
  events?: InputMaybe<Array<WebhookEventTypeEnum>>;
  /** Determine if webhook will be set active or not. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** The name of the webhook. */
  name?: InputMaybe<Scalars['String']>;
  /** Added in Saleor 3.2. Subscription query used to define a webhook payload. Note: this feature is in a preview state and can be subject to changes at later point. */
  query?: InputMaybe<Scalars['String']>;
  /** The secret key used to create a hash signature with each payload. */
  secretKey?: InputMaybe<Scalars['String']>;
  /** The synchronous events that webhook wants to subscribe. */
  syncEvents?: InputMaybe<Array<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  targetUrl?: InputMaybe<Scalars['String']>;
};

/** Deletes a webhook subscription. Requires one of the following permissions: MANAGE_APPS, AUTHENTICATED_APP. */
export type WebhookDelete = {
  __typename?: 'WebhookDelete';
  errors: Array<WebhookError>;
  webhook?: Maybe<Webhook>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  webhookErrors: Array<WebhookError>;
};

export type WebhookError = {
  __typename?: 'WebhookError';
  /** The error code. */
  code: WebhookErrorCode;
  /** Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field. */
  field?: Maybe<Scalars['String']>;
  /** The error message. */
  message?: Maybe<Scalars['String']>;
};

/** An enumeration. */
export enum WebhookErrorCode {
  GraphqlError = 'GRAPHQL_ERROR',
  Invalid = 'INVALID',
  NotFound = 'NOT_FOUND',
  Required = 'REQUIRED',
  Unique = 'UNIQUE'
}

/** Webhook event. */
export type WebhookEvent = {
  __typename?: 'WebhookEvent';
  /** Internal name of the event type. */
  eventType: WebhookEventTypeEnum;
  /** Display name of the event. */
  name: Scalars['String'];
};

/** Asynchronous webhook event. */
export type WebhookEventAsync = {
  __typename?: 'WebhookEventAsync';
  /** Internal name of the event type. */
  eventType: WebhookEventTypeAsyncEnum;
  /** Display name of the event. */
  name: Scalars['String'];
};

/** Synchronous webhook event. */
export type WebhookEventSync = {
  __typename?: 'WebhookEventSync';
  /** Internal name of the event type. */
  eventType: WebhookEventTypeSyncEnum;
  /** Display name of the event. */
  name: Scalars['String'];
};

/** Enum determining type of webhook. */
export enum WebhookEventTypeAsyncEnum {
  /** All the events. */
  AnyEvents = 'ANY_EVENTS',
  /** A new category created. */
  CategoryCreated = 'CATEGORY_CREATED',
  /** A category is deleted. */
  CategoryDeleted = 'CATEGORY_DELETED',
  /** A category is updated. */
  CategoryUpdated = 'CATEGORY_UPDATED',
  /** A new channel created. */
  ChannelCreated = 'CHANNEL_CREATED',
  /** A channel is deleted. */
  ChannelDeleted = 'CHANNEL_DELETED',
  /** A channel status is changed. */
  ChannelStatusChanged = 'CHANNEL_STATUS_CHANGED',
  /** A channel is updated. */
  ChannelUpdated = 'CHANNEL_UPDATED',
  /** A new checkout is created. */
  CheckoutCreated = 'CHECKOUT_CREATED',
  /** A checkout is updated. It also triggers all updates related to the checkout. */
  CheckoutUpdated = 'CHECKOUT_UPDATED',
  /** A new collection is created. */
  CollectionCreated = 'COLLECTION_CREATED',
  /** A collection is deleted. */
  CollectionDeleted = 'COLLECTION_DELETED',
  /** A collection is updated. */
  CollectionUpdated = 'COLLECTION_UPDATED',
  /** A new customer account is created. */
  CustomerCreated = 'CUSTOMER_CREATED',
  /** A customer account is updated. */
  CustomerUpdated = 'CUSTOMER_UPDATED',
  DraftOrderCreated = 'DRAFT_ORDER_CREATED',
  DraftOrderDeleted = 'DRAFT_ORDER_DELETED',
  DraftOrderUpdated = 'DRAFT_ORDER_UPDATED',
  /** A fulfillment is cancelled. */
  FulfillmentCanceled = 'FULFILLMENT_CANCELED',
  /** A new fulfillment is created. */
  FulfillmentCreated = 'FULFILLMENT_CREATED',
  /** A new gift card created. */
  GiftCardCreated = 'GIFT_CARD_CREATED',
  /** A gift card is deleted. */
  GiftCardDeleted = 'GIFT_CARD_DELETED',
  /** A gift card status is changed. */
  GiftCardStatusChanged = 'GIFT_CARD_STATUS_CHANGED',
  /** A gift card is updated. */
  GiftCardUpdated = 'GIFT_CARD_UPDATED',
  /** An invoice is deleted. */
  InvoiceDeleted = 'INVOICE_DELETED',
  /** An invoice for order requested. */
  InvoiceRequested = 'INVOICE_REQUESTED',
  /** Invoice has been sent. */
  InvoiceSent = 'INVOICE_SENT',
  /** User notification triggered. */
  NotifyUser = 'NOTIFY_USER',
  /** An order is cancelled. */
  OrderCancelled = 'ORDER_CANCELLED',
  /** An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled. */
  OrderConfirmed = 'ORDER_CONFIRMED',
  /** A new order is placed. */
  OrderCreated = 'ORDER_CREATED',
  /** An order is fulfilled. */
  OrderFulfilled = 'ORDER_FULFILLED',
  /** Payment is made and an order is fully paid. */
  OrderFullyPaid = 'ORDER_FULLY_PAID',
  /** An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED. */
  OrderUpdated = 'ORDER_UPDATED',
  /** A new page is created. */
  PageCreated = 'PAGE_CREATED',
  /** A page is deleted. */
  PageDeleted = 'PAGE_DELETED',
  /** A page is updated. */
  PageUpdated = 'PAGE_UPDATED',
  /** A new product is created. */
  ProductCreated = 'PRODUCT_CREATED',
  /** A product is deleted. */
  ProductDeleted = 'PRODUCT_DELETED',
  /** A product is updated. */
  ProductUpdated = 'PRODUCT_UPDATED',
  ProductVariantBackInStock = 'PRODUCT_VARIANT_BACK_IN_STOCK',
  /** A new product variant is created. */
  ProductVariantCreated = 'PRODUCT_VARIANT_CREATED',
  /** A product variant is deleted. */
  ProductVariantDeleted = 'PRODUCT_VARIANT_DELETED',
  ProductVariantOutOfStock = 'PRODUCT_VARIANT_OUT_OF_STOCK',
  /** A product variant is updated. */
  ProductVariantUpdated = 'PRODUCT_VARIANT_UPDATED',
  SaleCreated = 'SALE_CREATED',
  SaleDeleted = 'SALE_DELETED',
  SaleUpdated = 'SALE_UPDATED',
  /** A new shipping price is created. */
  ShippingPriceCreated = 'SHIPPING_PRICE_CREATED',
  /** A shipping price is deleted. */
  ShippingPriceDeleted = 'SHIPPING_PRICE_DELETED',
  /** A shipping price is updated. */
  ShippingPriceUpdated = 'SHIPPING_PRICE_UPDATED',
  /** A new shipping zone is created. */
  ShippingZoneCreated = 'SHIPPING_ZONE_CREATED',
  /** A shipping zone is deleted. */
  ShippingZoneDeleted = 'SHIPPING_ZONE_DELETED',
  /** A shipping zone is updated. */
  ShippingZoneUpdated = 'SHIPPING_ZONE_UPDATED',
  TranslationCreated = 'TRANSLATION_CREATED',
  TranslationUpdated = 'TRANSLATION_UPDATED'
}

/** Enum determining type of webhook. */
export enum WebhookEventTypeEnum {
  /** All the events. */
  AnyEvents = 'ANY_EVENTS',
  /** A new category created. */
  CategoryCreated = 'CATEGORY_CREATED',
  /** A category is deleted. */
  CategoryDeleted = 'CATEGORY_DELETED',
  /** A category is updated. */
  CategoryUpdated = 'CATEGORY_UPDATED',
  /** A new channel created. */
  ChannelCreated = 'CHANNEL_CREATED',
  /** A channel is deleted. */
  ChannelDeleted = 'CHANNEL_DELETED',
  /** A channel status is changed. */
  ChannelStatusChanged = 'CHANNEL_STATUS_CHANGED',
  /** A channel is updated. */
  ChannelUpdated = 'CHANNEL_UPDATED',
  /** A new checkout is created. */
  CheckoutCreated = 'CHECKOUT_CREATED',
  CheckoutFilterShippingMethods = 'CHECKOUT_FILTER_SHIPPING_METHODS',
  /** A checkout is updated. It also triggers all updates related to the checkout. */
  CheckoutUpdated = 'CHECKOUT_UPDATED',
  /** A new collection is created. */
  CollectionCreated = 'COLLECTION_CREATED',
  /** A collection is deleted. */
  CollectionDeleted = 'COLLECTION_DELETED',
  /** A collection is updated. */
  CollectionUpdated = 'COLLECTION_UPDATED',
  /** A new customer account is created. */
  CustomerCreated = 'CUSTOMER_CREATED',
  /** A customer account is updated. */
  CustomerUpdated = 'CUSTOMER_UPDATED',
  DraftOrderCreated = 'DRAFT_ORDER_CREATED',
  DraftOrderDeleted = 'DRAFT_ORDER_DELETED',
  DraftOrderUpdated = 'DRAFT_ORDER_UPDATED',
  /** A fulfillment is cancelled. */
  FulfillmentCanceled = 'FULFILLMENT_CANCELED',
  /** A new fulfillment is created. */
  FulfillmentCreated = 'FULFILLMENT_CREATED',
  /** A new gift card created. */
  GiftCardCreated = 'GIFT_CARD_CREATED',
  /** A gift card is deleted. */
  GiftCardDeleted = 'GIFT_CARD_DELETED',
  /** A gift card status is changed. */
  GiftCardStatusChanged = 'GIFT_CARD_STATUS_CHANGED',
  /** A gift card is updated. */
  GiftCardUpdated = 'GIFT_CARD_UPDATED',
  /** An invoice is deleted. */
  InvoiceDeleted = 'INVOICE_DELETED',
  /** An invoice for order requested. */
  InvoiceRequested = 'INVOICE_REQUESTED',
  /** Invoice has been sent. */
  InvoiceSent = 'INVOICE_SENT',
  /** User notification triggered. */
  NotifyUser = 'NOTIFY_USER',
  /** An order is cancelled. */
  OrderCancelled = 'ORDER_CANCELLED',
  /** An order is confirmed (status change unconfirmed -> unfulfilled) by a staff user using the OrderConfirm mutation. It also triggers when the user completes the checkout and the shop setting `automatically_confirm_all_new_orders` is enabled. */
  OrderConfirmed = 'ORDER_CONFIRMED',
  /** A new order is placed. */
  OrderCreated = 'ORDER_CREATED',
  OrderFilterShippingMethods = 'ORDER_FILTER_SHIPPING_METHODS',
  /** An order is fulfilled. */
  OrderFulfilled = 'ORDER_FULFILLED',
  /** Payment is made and an order is fully paid. */
  OrderFullyPaid = 'ORDER_FULLY_PAID',
  /** An order is updated; triggered for all changes related to an order; covers all other order webhooks, except for ORDER_CREATED. */
  OrderUpdated = 'ORDER_UPDATED',
  /** A new page is created. */
  PageCreated = 'PAGE_CREATED',
  /** A page is deleted. */
  PageDeleted = 'PAGE_DELETED',
  /** A page is updated. */
  PageUpdated = 'PAGE_UPDATED',
  PaymentAuthorize = 'PAYMENT_AUTHORIZE',
  PaymentCapture = 'PAYMENT_CAPTURE',
  PaymentConfirm = 'PAYMENT_CONFIRM',
  PaymentListGateways = 'PAYMENT_LIST_GATEWAYS',
  PaymentProcess = 'PAYMENT_PROCESS',
  PaymentRefund = 'PAYMENT_REFUND',
  PaymentVoid = 'PAYMENT_VOID',
  /** A new product is created. */
  ProductCreated = 'PRODUCT_CREATED',
  /** A product is deleted. */
  ProductDeleted = 'PRODUCT_DELETED',
  /** A product is updated. */
  ProductUpdated = 'PRODUCT_UPDATED',
  ProductVariantBackInStock = 'PRODUCT_VARIANT_BACK_IN_STOCK',
  /** A new product variant is created. */
  ProductVariantCreated = 'PRODUCT_VARIANT_CREATED',
  /** A product variant is deleted. */
  ProductVariantDeleted = 'PRODUCT_VARIANT_DELETED',
  ProductVariantOutOfStock = 'PRODUCT_VARIANT_OUT_OF_STOCK',
  /** A product variant is updated. */
  ProductVariantUpdated = 'PRODUCT_VARIANT_UPDATED',
  SaleCreated = 'SALE_CREATED',
  SaleDeleted = 'SALE_DELETED',
  SaleUpdated = 'SALE_UPDATED',
  ShippingListMethodsForCheckout = 'SHIPPING_LIST_METHODS_FOR_CHECKOUT',
  /** A new shipping price is created. */
  ShippingPriceCreated = 'SHIPPING_PRICE_CREATED',
  /** A shipping price is deleted. */
  ShippingPriceDeleted = 'SHIPPING_PRICE_DELETED',
  /** A shipping price is updated. */
  ShippingPriceUpdated = 'SHIPPING_PRICE_UPDATED',
  /** A new shipping zone is created. */
  ShippingZoneCreated = 'SHIPPING_ZONE_CREATED',
  /** A shipping zone is deleted. */
  ShippingZoneDeleted = 'SHIPPING_ZONE_DELETED',
  /** A shipping zone is updated. */
  ShippingZoneUpdated = 'SHIPPING_ZONE_UPDATED',
  TranslationCreated = 'TRANSLATION_CREATED',
  TranslationUpdated = 'TRANSLATION_UPDATED'
}

/** Enum determining type of webhook. */
export enum WebhookEventTypeSyncEnum {
  CheckoutFilterShippingMethods = 'CHECKOUT_FILTER_SHIPPING_METHODS',
  OrderFilterShippingMethods = 'ORDER_FILTER_SHIPPING_METHODS',
  PaymentAuthorize = 'PAYMENT_AUTHORIZE',
  PaymentCapture = 'PAYMENT_CAPTURE',
  PaymentConfirm = 'PAYMENT_CONFIRM',
  PaymentListGateways = 'PAYMENT_LIST_GATEWAYS',
  PaymentProcess = 'PAYMENT_PROCESS',
  PaymentRefund = 'PAYMENT_REFUND',
  PaymentVoid = 'PAYMENT_VOID',
  ShippingListMethodsForCheckout = 'SHIPPING_LIST_METHODS_FOR_CHECKOUT'
}

/** An enumeration. */
export enum WebhookSampleEventTypeEnum {
  CategoryCreated = 'CATEGORY_CREATED',
  CategoryDeleted = 'CATEGORY_DELETED',
  CategoryUpdated = 'CATEGORY_UPDATED',
  ChannelCreated = 'CHANNEL_CREATED',
  ChannelDeleted = 'CHANNEL_DELETED',
  ChannelStatusChanged = 'CHANNEL_STATUS_CHANGED',
  ChannelUpdated = 'CHANNEL_UPDATED',
  CheckoutCreated = 'CHECKOUT_CREATED',
  CheckoutUpdated = 'CHECKOUT_UPDATED',
  CollectionCreated = 'COLLECTION_CREATED',
  CollectionDeleted = 'COLLECTION_DELETED',
  CollectionUpdated = 'COLLECTION_UPDATED',
  CustomerCreated = 'CUSTOMER_CREATED',
  CustomerUpdated = 'CUSTOMER_UPDATED',
  DraftOrderCreated = 'DRAFT_ORDER_CREATED',
  DraftOrderDeleted = 'DRAFT_ORDER_DELETED',
  DraftOrderUpdated = 'DRAFT_ORDER_UPDATED',
  FulfillmentCanceled = 'FULFILLMENT_CANCELED',
  FulfillmentCreated = 'FULFILLMENT_CREATED',
  GiftCardCreated = 'GIFT_CARD_CREATED',
  GiftCardDeleted = 'GIFT_CARD_DELETED',
  GiftCardStatusChanged = 'GIFT_CARD_STATUS_CHANGED',
  GiftCardUpdated = 'GIFT_CARD_UPDATED',
  InvoiceDeleted = 'INVOICE_DELETED',
  InvoiceRequested = 'INVOICE_REQUESTED',
  InvoiceSent = 'INVOICE_SENT',
  NotifyUser = 'NOTIFY_USER',
  OrderCancelled = 'ORDER_CANCELLED',
  OrderConfirmed = 'ORDER_CONFIRMED',
  OrderCreated = 'ORDER_CREATED',
  OrderFulfilled = 'ORDER_FULFILLED',
  OrderFullyPaid = 'ORDER_FULLY_PAID',
  OrderUpdated = 'ORDER_UPDATED',
  PageCreated = 'PAGE_CREATED',
  PageDeleted = 'PAGE_DELETED',
  PageUpdated = 'PAGE_UPDATED',
  ProductCreated = 'PRODUCT_CREATED',
  ProductDeleted = 'PRODUCT_DELETED',
  ProductUpdated = 'PRODUCT_UPDATED',
  ProductVariantBackInStock = 'PRODUCT_VARIANT_BACK_IN_STOCK',
  ProductVariantCreated = 'PRODUCT_VARIANT_CREATED',
  ProductVariantDeleted = 'PRODUCT_VARIANT_DELETED',
  ProductVariantOutOfStock = 'PRODUCT_VARIANT_OUT_OF_STOCK',
  ProductVariantUpdated = 'PRODUCT_VARIANT_UPDATED',
  SaleCreated = 'SALE_CREATED',
  SaleDeleted = 'SALE_DELETED',
  SaleUpdated = 'SALE_UPDATED',
  ShippingPriceCreated = 'SHIPPING_PRICE_CREATED',
  ShippingPriceDeleted = 'SHIPPING_PRICE_DELETED',
  ShippingPriceUpdated = 'SHIPPING_PRICE_UPDATED',
  ShippingZoneCreated = 'SHIPPING_ZONE_CREATED',
  ShippingZoneDeleted = 'SHIPPING_ZONE_DELETED',
  ShippingZoneUpdated = 'SHIPPING_ZONE_UPDATED',
  TranslationCreated = 'TRANSLATION_CREATED',
  TranslationUpdated = 'TRANSLATION_UPDATED'
}

/** Updates a webhook subscription. Requires one of the following permissions: MANAGE_APPS. */
export type WebhookUpdate = {
  __typename?: 'WebhookUpdate';
  errors: Array<WebhookError>;
  webhook?: Maybe<Webhook>;
  /** @deprecated This field will be removed in Saleor 4.0. Use `errors` field instead. */
  webhookErrors: Array<WebhookError>;
};

export type WebhookUpdateInput = {
  /** ID of the app to which webhook belongs. */
  app?: InputMaybe<Scalars['ID']>;
  /** The asynchronous events that webhook wants to subscribe. */
  asyncEvents?: InputMaybe<Array<WebhookEventTypeAsyncEnum>>;
  /**
   * The events that webhook wants to subscribe.
   *
   * DEPRECATED: this field will be removed in Saleor 4.0. Use `asyncEvents` or `syncEvents` instead.
   */
  events?: InputMaybe<Array<WebhookEventTypeEnum>>;
  /** Determine if webhook will be set active or not. */
  isActive?: InputMaybe<Scalars['Boolean']>;
  /** The new name of the webhook. */
  name?: InputMaybe<Scalars['String']>;
  /** Added in Saleor 3.2. Subscription query used to define a webhook payload. Note: this feature is in a preview state and can be subject to changes at later point. */
  query?: InputMaybe<Scalars['String']>;
  /** Use to create a hash signature with each payload. */
  secretKey?: InputMaybe<Scalars['String']>;
  /** The synchronous events that webhook wants to subscribe. */
  syncEvents?: InputMaybe<Array<WebhookEventTypeSyncEnum>>;
  /** The url to receive the payload. */
  targetUrl?: InputMaybe<Scalars['String']>;
};

/** Represents weight value in a specific weight unit. */
export type Weight = {
  __typename?: 'Weight';
  /** Weight unit. */
  unit: WeightUnitsEnum;
  /** Weight value. */
  value: Scalars['Float'];
};

/** An enumeration. */
export enum WeightUnitsEnum {
  G = 'G',
  Kg = 'KG',
  Lb = 'LB',
  Oz = 'OZ',
  Tonne = 'TONNE'
}

/** _Entity union as defined by Federation spec. */
export type _Entity = Address | App | Category | Collection | Group | PageType | Product | ProductMedia | ProductType | ProductVariant | User;

/** _Service manifest as defined by Federation spec. */
export type _Service = {
  __typename?: '_Service';
  sdl?: Maybe<Scalars['String']>;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  AccountAddressCreate: ResolverTypeWrapper<AccountAddressCreate>;
  AccountAddressDelete: ResolverTypeWrapper<AccountAddressDelete>;
  AccountAddressUpdate: ResolverTypeWrapper<AccountAddressUpdate>;
  AccountDelete: ResolverTypeWrapper<AccountDelete>;
  AccountError: ResolverTypeWrapper<AccountError>;
  AccountErrorCode: AccountErrorCode;
  AccountInput: AccountInput;
  AccountRegister: ResolverTypeWrapper<AccountRegister>;
  AccountRegisterInput: AccountRegisterInput;
  AccountRequestDeletion: ResolverTypeWrapper<AccountRequestDeletion>;
  AccountSetDefaultAddress: ResolverTypeWrapper<AccountSetDefaultAddress>;
  AccountUpdate: ResolverTypeWrapper<AccountUpdate>;
  Address: ResolverTypeWrapper<Address>;
  AddressCreate: ResolverTypeWrapper<AddressCreate>;
  AddressDelete: ResolverTypeWrapper<AddressDelete>;
  AddressInput: AddressInput;
  AddressSetDefault: ResolverTypeWrapper<AddressSetDefault>;
  AddressTypeEnum: AddressTypeEnum;
  AddressUpdate: ResolverTypeWrapper<AddressUpdate>;
  AddressValidationData: ResolverTypeWrapper<AddressValidationData>;
  Allocation: ResolverTypeWrapper<Allocation>;
  App: ResolverTypeWrapper<App>;
  AppActivate: ResolverTypeWrapper<AppActivate>;
  AppCountableConnection: ResolverTypeWrapper<AppCountableConnection>;
  AppCountableEdge: ResolverTypeWrapper<AppCountableEdge>;
  AppCreate: ResolverTypeWrapper<AppCreate>;
  AppDeactivate: ResolverTypeWrapper<AppDeactivate>;
  AppDelete: ResolverTypeWrapper<AppDelete>;
  AppDeleteFailedInstallation: ResolverTypeWrapper<AppDeleteFailedInstallation>;
  AppError: ResolverTypeWrapper<AppError>;
  AppErrorCode: AppErrorCode;
  AppExtension: ResolverTypeWrapper<AppExtension>;
  AppExtensionCountableConnection: ResolverTypeWrapper<AppExtensionCountableConnection>;
  AppExtensionCountableEdge: ResolverTypeWrapper<AppExtensionCountableEdge>;
  AppExtensionFilterInput: AppExtensionFilterInput;
  AppExtensionMountEnum: AppExtensionMountEnum;
  AppExtensionTargetEnum: AppExtensionTargetEnum;
  AppFetchManifest: ResolverTypeWrapper<AppFetchManifest>;
  AppFilterInput: AppFilterInput;
  AppInput: AppInput;
  AppInstall: ResolverTypeWrapper<AppInstall>;
  AppInstallInput: AppInstallInput;
  AppInstallation: ResolverTypeWrapper<AppInstallation>;
  AppManifestExtension: ResolverTypeWrapper<AppManifestExtension>;
  AppRetryInstall: ResolverTypeWrapper<AppRetryInstall>;
  AppSortField: AppSortField;
  AppSortingInput: AppSortingInput;
  AppToken: ResolverTypeWrapper<AppToken>;
  AppTokenCreate: ResolverTypeWrapper<AppTokenCreate>;
  AppTokenDelete: ResolverTypeWrapper<AppTokenDelete>;
  AppTokenInput: AppTokenInput;
  AppTokenVerify: ResolverTypeWrapper<AppTokenVerify>;
  AppTypeEnum: AppTypeEnum;
  AppUpdate: ResolverTypeWrapper<AppUpdate>;
  AreaUnitsEnum: AreaUnitsEnum;
  AssignNavigation: ResolverTypeWrapper<AssignNavigation>;
  AssignedVariantAttribute: ResolverTypeWrapper<AssignedVariantAttribute>;
  Attribute: ResolverTypeWrapper<Attribute>;
  AttributeBulkDelete: ResolverTypeWrapper<AttributeBulkDelete>;
  AttributeChoicesSortField: AttributeChoicesSortField;
  AttributeChoicesSortingInput: AttributeChoicesSortingInput;
  AttributeCountableConnection: ResolverTypeWrapper<AttributeCountableConnection>;
  AttributeCountableEdge: ResolverTypeWrapper<AttributeCountableEdge>;
  AttributeCreate: ResolverTypeWrapper<AttributeCreate>;
  AttributeCreateInput: AttributeCreateInput;
  AttributeDelete: ResolverTypeWrapper<AttributeDelete>;
  AttributeEntityTypeEnum: AttributeEntityTypeEnum;
  AttributeError: ResolverTypeWrapper<AttributeError>;
  AttributeErrorCode: AttributeErrorCode;
  AttributeFilterInput: AttributeFilterInput;
  AttributeInput: AttributeInput;
  AttributeInputTypeEnum: AttributeInputTypeEnum;
  AttributeReorderValues: ResolverTypeWrapper<AttributeReorderValues>;
  AttributeSortField: AttributeSortField;
  AttributeSortingInput: AttributeSortingInput;
  AttributeTranslatableContent: ResolverTypeWrapper<AttributeTranslatableContent>;
  AttributeTranslate: ResolverTypeWrapper<AttributeTranslate>;
  AttributeTranslation: ResolverTypeWrapper<AttributeTranslation>;
  AttributeTypeEnum: AttributeTypeEnum;
  AttributeUpdate: ResolverTypeWrapper<AttributeUpdate>;
  AttributeUpdateInput: AttributeUpdateInput;
  AttributeValue: ResolverTypeWrapper<AttributeValue>;
  AttributeValueBulkDelete: ResolverTypeWrapper<AttributeValueBulkDelete>;
  AttributeValueCountableConnection: ResolverTypeWrapper<AttributeValueCountableConnection>;
  AttributeValueCountableEdge: ResolverTypeWrapper<AttributeValueCountableEdge>;
  AttributeValueCreate: ResolverTypeWrapper<AttributeValueCreate>;
  AttributeValueCreateInput: AttributeValueCreateInput;
  AttributeValueDelete: ResolverTypeWrapper<AttributeValueDelete>;
  AttributeValueFilterInput: AttributeValueFilterInput;
  AttributeValueInput: AttributeValueInput;
  AttributeValueTranslatableContent: ResolverTypeWrapper<AttributeValueTranslatableContent>;
  AttributeValueTranslate: ResolverTypeWrapper<AttributeValueTranslate>;
  AttributeValueTranslation: ResolverTypeWrapper<AttributeValueTranslation>;
  AttributeValueTranslationInput: AttributeValueTranslationInput;
  AttributeValueUpdate: ResolverTypeWrapper<AttributeValueUpdate>;
  AttributeValueUpdateInput: AttributeValueUpdateInput;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  BulkAttributeValueInput: BulkAttributeValueInput;
  BulkProductError: ResolverTypeWrapper<BulkProductError>;
  BulkStockError: ResolverTypeWrapper<BulkStockError>;
  CardInput: CardInput;
  CatalogueInput: CatalogueInput;
  Category: ResolverTypeWrapper<Category>;
  CategoryBulkDelete: ResolverTypeWrapper<CategoryBulkDelete>;
  CategoryCountableConnection: ResolverTypeWrapper<CategoryCountableConnection>;
  CategoryCountableEdge: ResolverTypeWrapper<CategoryCountableEdge>;
  CategoryCreate: ResolverTypeWrapper<CategoryCreate>;
  CategoryCreated: ResolverTypeWrapper<CategoryCreated>;
  CategoryDelete: ResolverTypeWrapper<CategoryDelete>;
  CategoryDeleted: ResolverTypeWrapper<CategoryDeleted>;
  CategoryFilterInput: CategoryFilterInput;
  CategoryInput: CategoryInput;
  CategorySortField: CategorySortField;
  CategorySortingInput: CategorySortingInput;
  CategoryTranslatableContent: ResolverTypeWrapper<CategoryTranslatableContent>;
  CategoryTranslate: ResolverTypeWrapper<CategoryTranslate>;
  CategoryTranslation: ResolverTypeWrapper<CategoryTranslation>;
  CategoryUpdate: ResolverTypeWrapper<CategoryUpdate>;
  CategoryUpdated: ResolverTypeWrapper<CategoryUpdated>;
  Channel: ResolverTypeWrapper<Channel>;
  ChannelActivate: ResolverTypeWrapper<ChannelActivate>;
  ChannelCreate: ResolverTypeWrapper<ChannelCreate>;
  ChannelCreateInput: ChannelCreateInput;
  ChannelCreated: ResolverTypeWrapper<ChannelCreated>;
  ChannelDeactivate: ResolverTypeWrapper<ChannelDeactivate>;
  ChannelDelete: ResolverTypeWrapper<ChannelDelete>;
  ChannelDeleteInput: ChannelDeleteInput;
  ChannelDeleted: ResolverTypeWrapper<ChannelDeleted>;
  ChannelError: ResolverTypeWrapper<ChannelError>;
  ChannelErrorCode: ChannelErrorCode;
  ChannelStatusChanged: ResolverTypeWrapper<ChannelStatusChanged>;
  ChannelUpdate: ResolverTypeWrapper<ChannelUpdate>;
  ChannelUpdateInput: ChannelUpdateInput;
  ChannelUpdated: ResolverTypeWrapper<ChannelUpdated>;
  Checkout: ResolverTypeWrapper<Omit<Checkout, 'deliveryMethod'> & { deliveryMethod?: Maybe<ResolversTypes['DeliveryMethod']> }>;
  CheckoutAddPromoCode: ResolverTypeWrapper<CheckoutAddPromoCode>;
  CheckoutBillingAddressUpdate: ResolverTypeWrapper<CheckoutBillingAddressUpdate>;
  CheckoutComplete: ResolverTypeWrapper<CheckoutComplete>;
  CheckoutCountableConnection: ResolverTypeWrapper<CheckoutCountableConnection>;
  CheckoutCountableEdge: ResolverTypeWrapper<CheckoutCountableEdge>;
  CheckoutCreate: ResolverTypeWrapper<CheckoutCreate>;
  CheckoutCreateInput: CheckoutCreateInput;
  CheckoutCreated: ResolverTypeWrapper<CheckoutCreated>;
  CheckoutCustomerAttach: ResolverTypeWrapper<CheckoutCustomerAttach>;
  CheckoutCustomerDetach: ResolverTypeWrapper<CheckoutCustomerDetach>;
  CheckoutDeliveryMethodUpdate: ResolverTypeWrapper<CheckoutDeliveryMethodUpdate>;
  CheckoutEmailUpdate: ResolverTypeWrapper<CheckoutEmailUpdate>;
  CheckoutError: ResolverTypeWrapper<CheckoutError>;
  CheckoutErrorCode: CheckoutErrorCode;
  CheckoutFilterInput: CheckoutFilterInput;
  CheckoutLanguageCodeUpdate: ResolverTypeWrapper<CheckoutLanguageCodeUpdate>;
  CheckoutLine: ResolverTypeWrapper<CheckoutLine>;
  CheckoutLineCountableConnection: ResolverTypeWrapper<CheckoutLineCountableConnection>;
  CheckoutLineCountableEdge: ResolverTypeWrapper<CheckoutLineCountableEdge>;
  CheckoutLineDelete: ResolverTypeWrapper<CheckoutLineDelete>;
  CheckoutLineInput: CheckoutLineInput;
  CheckoutLineUpdateInput: CheckoutLineUpdateInput;
  CheckoutLinesAdd: ResolverTypeWrapper<CheckoutLinesAdd>;
  CheckoutLinesDelete: ResolverTypeWrapper<CheckoutLinesDelete>;
  CheckoutLinesUpdate: ResolverTypeWrapper<CheckoutLinesUpdate>;
  CheckoutPaymentCreate: ResolverTypeWrapper<CheckoutPaymentCreate>;
  CheckoutRemovePromoCode: ResolverTypeWrapper<CheckoutRemovePromoCode>;
  CheckoutShippingAddressUpdate: ResolverTypeWrapper<CheckoutShippingAddressUpdate>;
  CheckoutShippingMethodUpdate: ResolverTypeWrapper<CheckoutShippingMethodUpdate>;
  CheckoutSortField: CheckoutSortField;
  CheckoutSortingInput: CheckoutSortingInput;
  CheckoutUpdated: ResolverTypeWrapper<CheckoutUpdated>;
  ChoiceValue: ResolverTypeWrapper<ChoiceValue>;
  Collection: ResolverTypeWrapper<Collection>;
  CollectionAddProducts: ResolverTypeWrapper<CollectionAddProducts>;
  CollectionBulkDelete: ResolverTypeWrapper<CollectionBulkDelete>;
  CollectionChannelListing: ResolverTypeWrapper<CollectionChannelListing>;
  CollectionChannelListingError: ResolverTypeWrapper<CollectionChannelListingError>;
  CollectionChannelListingUpdate: ResolverTypeWrapper<CollectionChannelListingUpdate>;
  CollectionChannelListingUpdateInput: CollectionChannelListingUpdateInput;
  CollectionCountableConnection: ResolverTypeWrapper<CollectionCountableConnection>;
  CollectionCountableEdge: ResolverTypeWrapper<CollectionCountableEdge>;
  CollectionCreate: ResolverTypeWrapper<CollectionCreate>;
  CollectionCreateInput: CollectionCreateInput;
  CollectionCreated: ResolverTypeWrapper<CollectionCreated>;
  CollectionDelete: ResolverTypeWrapper<CollectionDelete>;
  CollectionDeleted: ResolverTypeWrapper<CollectionDeleted>;
  CollectionError: ResolverTypeWrapper<CollectionError>;
  CollectionErrorCode: CollectionErrorCode;
  CollectionFilterInput: CollectionFilterInput;
  CollectionInput: CollectionInput;
  CollectionPublished: CollectionPublished;
  CollectionRemoveProducts: ResolverTypeWrapper<CollectionRemoveProducts>;
  CollectionReorderProducts: ResolverTypeWrapper<CollectionReorderProducts>;
  CollectionSortField: CollectionSortField;
  CollectionSortingInput: CollectionSortingInput;
  CollectionTranslatableContent: ResolverTypeWrapper<CollectionTranslatableContent>;
  CollectionTranslate: ResolverTypeWrapper<CollectionTranslate>;
  CollectionTranslation: ResolverTypeWrapper<CollectionTranslation>;
  CollectionUpdate: ResolverTypeWrapper<CollectionUpdate>;
  CollectionUpdated: ResolverTypeWrapper<CollectionUpdated>;
  ConfigurationItem: ResolverTypeWrapper<ConfigurationItem>;
  ConfigurationItemInput: ConfigurationItemInput;
  ConfigurationTypeFieldEnum: ConfigurationTypeFieldEnum;
  ConfirmAccount: ResolverTypeWrapper<ConfirmAccount>;
  ConfirmEmailChange: ResolverTypeWrapper<ConfirmEmailChange>;
  CountryCode: CountryCode;
  CountryDisplay: ResolverTypeWrapper<CountryDisplay>;
  CountryFilterInput: CountryFilterInput;
  CreateToken: ResolverTypeWrapper<CreateToken>;
  CreditCard: ResolverTypeWrapper<CreditCard>;
  CustomerBulkDelete: ResolverTypeWrapper<CustomerBulkDelete>;
  CustomerCreate: ResolverTypeWrapper<CustomerCreate>;
  CustomerCreated: ResolverTypeWrapper<CustomerCreated>;
  CustomerDelete: ResolverTypeWrapper<CustomerDelete>;
  CustomerEvent: ResolverTypeWrapper<CustomerEvent>;
  CustomerEventsEnum: CustomerEventsEnum;
  CustomerFilterInput: CustomerFilterInput;
  CustomerInput: CustomerInput;
  CustomerUpdate: ResolverTypeWrapper<CustomerUpdate>;
  CustomerUpdated: ResolverTypeWrapper<CustomerUpdated>;
  Date: ResolverTypeWrapper<Scalars['Date']>;
  DateRangeInput: DateRangeInput;
  DateTime: ResolverTypeWrapper<Scalars['DateTime']>;
  DateTimeRangeInput: DateTimeRangeInput;
  DeactivateAllUserTokens: ResolverTypeWrapper<DeactivateAllUserTokens>;
  DeleteMetadata: ResolverTypeWrapper<DeleteMetadata>;
  DeletePrivateMetadata: ResolverTypeWrapper<DeletePrivateMetadata>;
  DeliveryMethod: ResolversTypes['ShippingMethod'] | ResolversTypes['Warehouse'];
  DigitalContent: ResolverTypeWrapper<DigitalContent>;
  DigitalContentCountableConnection: ResolverTypeWrapper<DigitalContentCountableConnection>;
  DigitalContentCountableEdge: ResolverTypeWrapper<DigitalContentCountableEdge>;
  DigitalContentCreate: ResolverTypeWrapper<DigitalContentCreate>;
  DigitalContentDelete: ResolverTypeWrapper<DigitalContentDelete>;
  DigitalContentInput: DigitalContentInput;
  DigitalContentUpdate: ResolverTypeWrapper<DigitalContentUpdate>;
  DigitalContentUploadInput: DigitalContentUploadInput;
  DigitalContentUrl: ResolverTypeWrapper<DigitalContentUrl>;
  DigitalContentUrlCreate: ResolverTypeWrapper<DigitalContentUrlCreate>;
  DigitalContentUrlCreateInput: DigitalContentUrlCreateInput;
  DiscountError: ResolverTypeWrapper<DiscountError>;
  DiscountErrorCode: DiscountErrorCode;
  DiscountStatusEnum: DiscountStatusEnum;
  DiscountValueTypeEnum: DiscountValueTypeEnum;
  DistanceUnitsEnum: DistanceUnitsEnum;
  Domain: ResolverTypeWrapper<Domain>;
  DraftOrderBulkDelete: ResolverTypeWrapper<DraftOrderBulkDelete>;
  DraftOrderComplete: ResolverTypeWrapper<DraftOrderComplete>;
  DraftOrderCreate: ResolverTypeWrapper<DraftOrderCreate>;
  DraftOrderCreateInput: DraftOrderCreateInput;
  DraftOrderCreated: ResolverTypeWrapper<DraftOrderCreated>;
  DraftOrderDelete: ResolverTypeWrapper<DraftOrderDelete>;
  DraftOrderDeleted: ResolverTypeWrapper<DraftOrderDeleted>;
  DraftOrderInput: DraftOrderInput;
  DraftOrderLinesBulkDelete: ResolverTypeWrapper<DraftOrderLinesBulkDelete>;
  DraftOrderUpdate: ResolverTypeWrapper<DraftOrderUpdate>;
  DraftOrderUpdated: ResolverTypeWrapper<DraftOrderUpdated>;
  Event: ResolversTypes['CategoryCreated'] | ResolversTypes['CategoryDeleted'] | ResolversTypes['CategoryUpdated'] | ResolversTypes['ChannelCreated'] | ResolversTypes['ChannelDeleted'] | ResolversTypes['ChannelStatusChanged'] | ResolversTypes['ChannelUpdated'] | ResolversTypes['CheckoutCreated'] | ResolversTypes['CheckoutUpdated'] | ResolversTypes['CollectionCreated'] | ResolversTypes['CollectionDeleted'] | ResolversTypes['CollectionUpdated'] | ResolversTypes['CustomerCreated'] | ResolversTypes['CustomerUpdated'] | ResolversTypes['DraftOrderCreated'] | ResolversTypes['DraftOrderDeleted'] | ResolversTypes['DraftOrderUpdated'] | ResolversTypes['FulfillmentCanceled'] | ResolversTypes['FulfillmentCreated'] | ResolversTypes['GiftCardCreated'] | ResolversTypes['GiftCardDeleted'] | ResolversTypes['GiftCardStatusChanged'] | ResolversTypes['GiftCardUpdated'] | ResolversTypes['InvoiceDeleted'] | ResolversTypes['InvoiceRequested'] | ResolversTypes['InvoiceSent'] | ResolversTypes['OrderCancelled'] | ResolversTypes['OrderConfirmed'] | ResolversTypes['OrderCreated'] | ResolversTypes['OrderFulfilled'] | ResolversTypes['OrderFullyPaid'] | ResolversTypes['OrderUpdated'] | ResolversTypes['PageCreated'] | ResolversTypes['PageDeleted'] | ResolversTypes['PageUpdated'] | ResolversTypes['ProductCreated'] | ResolversTypes['ProductDeleted'] | ResolversTypes['ProductUpdated'] | ResolversTypes['ProductVariantBackInStock'] | ResolversTypes['ProductVariantCreated'] | ResolversTypes['ProductVariantDeleted'] | ResolversTypes['ProductVariantOutOfStock'] | ResolversTypes['ProductVariantUpdated'] | ResolversTypes['SaleCreated'] | ResolversTypes['SaleDeleted'] | ResolversTypes['SaleUpdated'] | ResolversTypes['ShippingPriceCreated'] | ResolversTypes['ShippingPriceDeleted'] | ResolversTypes['ShippingPriceUpdated'] | ResolversTypes['ShippingZoneCreated'] | ResolversTypes['ShippingZoneDeleted'] | ResolversTypes['ShippingZoneUpdated'] | ResolversTypes['TranslationCreated'] | ResolversTypes['TranslationUpdated'];
  EventDelivery: ResolverTypeWrapper<EventDelivery>;
  EventDeliveryAttempt: ResolverTypeWrapper<EventDeliveryAttempt>;
  EventDeliveryAttemptCountableConnection: ResolverTypeWrapper<EventDeliveryAttemptCountableConnection>;
  EventDeliveryAttemptCountableEdge: ResolverTypeWrapper<EventDeliveryAttemptCountableEdge>;
  EventDeliveryAttemptSortField: EventDeliveryAttemptSortField;
  EventDeliveryAttemptSortingInput: EventDeliveryAttemptSortingInput;
  EventDeliveryCountableConnection: ResolverTypeWrapper<EventDeliveryCountableConnection>;
  EventDeliveryCountableEdge: ResolverTypeWrapper<EventDeliveryCountableEdge>;
  EventDeliveryFilterInput: EventDeliveryFilterInput;
  EventDeliveryRetry: ResolverTypeWrapper<EventDeliveryRetry>;
  EventDeliverySortField: EventDeliverySortField;
  EventDeliverySortingInput: EventDeliverySortingInput;
  EventDeliveryStatusEnum: EventDeliveryStatusEnum;
  ExportError: ResolverTypeWrapper<ExportError>;
  ExportErrorCode: ExportErrorCode;
  ExportEvent: ResolverTypeWrapper<ExportEvent>;
  ExportEventsEnum: ExportEventsEnum;
  ExportFile: ResolverTypeWrapper<ExportFile>;
  ExportFileCountableConnection: ResolverTypeWrapper<ExportFileCountableConnection>;
  ExportFileCountableEdge: ResolverTypeWrapper<ExportFileCountableEdge>;
  ExportFileFilterInput: ExportFileFilterInput;
  ExportFileSortField: ExportFileSortField;
  ExportFileSortingInput: ExportFileSortingInput;
  ExportGiftCards: ResolverTypeWrapper<ExportGiftCards>;
  ExportGiftCardsInput: ExportGiftCardsInput;
  ExportInfoInput: ExportInfoInput;
  ExportProducts: ResolverTypeWrapper<ExportProducts>;
  ExportProductsInput: ExportProductsInput;
  ExportScope: ExportScope;
  ExternalAuthentication: ResolverTypeWrapper<ExternalAuthentication>;
  ExternalAuthenticationUrl: ResolverTypeWrapper<ExternalAuthenticationUrl>;
  ExternalLogout: ResolverTypeWrapper<ExternalLogout>;
  ExternalNotificationError: ResolverTypeWrapper<ExternalNotificationError>;
  ExternalNotificationErrorCodes: ExternalNotificationErrorCodes;
  ExternalNotificationTrigger: ResolverTypeWrapper<ExternalNotificationTrigger>;
  ExternalNotificationTriggerInput: ExternalNotificationTriggerInput;
  ExternalObtainAccessTokens: ResolverTypeWrapper<ExternalObtainAccessTokens>;
  ExternalRefresh: ResolverTypeWrapper<ExternalRefresh>;
  ExternalVerify: ResolverTypeWrapper<ExternalVerify>;
  File: ResolverTypeWrapper<File>;
  FileTypesEnum: FileTypesEnum;
  FileUpload: ResolverTypeWrapper<FileUpload>;
  Float: ResolverTypeWrapper<Scalars['Float']>;
  Fulfillment: ResolverTypeWrapper<Fulfillment>;
  FulfillmentApprove: ResolverTypeWrapper<FulfillmentApprove>;
  FulfillmentCancel: ResolverTypeWrapper<FulfillmentCancel>;
  FulfillmentCancelInput: FulfillmentCancelInput;
  FulfillmentCanceled: ResolverTypeWrapper<FulfillmentCanceled>;
  FulfillmentCreated: ResolverTypeWrapper<FulfillmentCreated>;
  FulfillmentLine: ResolverTypeWrapper<FulfillmentLine>;
  FulfillmentRefundProducts: ResolverTypeWrapper<FulfillmentRefundProducts>;
  FulfillmentReturnProducts: ResolverTypeWrapper<FulfillmentReturnProducts>;
  FulfillmentStatus: FulfillmentStatus;
  FulfillmentUpdateTracking: ResolverTypeWrapper<FulfillmentUpdateTracking>;
  FulfillmentUpdateTrackingInput: FulfillmentUpdateTrackingInput;
  GatewayConfigLine: ResolverTypeWrapper<GatewayConfigLine>;
  GenericScalar: ResolverTypeWrapper<Scalars['GenericScalar']>;
  GiftCard: ResolverTypeWrapper<GiftCard>;
  GiftCardActivate: ResolverTypeWrapper<GiftCardActivate>;
  GiftCardAddNote: ResolverTypeWrapper<GiftCardAddNote>;
  GiftCardAddNoteInput: GiftCardAddNoteInput;
  GiftCardBulkActivate: ResolverTypeWrapper<GiftCardBulkActivate>;
  GiftCardBulkCreate: ResolverTypeWrapper<GiftCardBulkCreate>;
  GiftCardBulkCreateInput: GiftCardBulkCreateInput;
  GiftCardBulkDeactivate: ResolverTypeWrapper<GiftCardBulkDeactivate>;
  GiftCardBulkDelete: ResolverTypeWrapper<GiftCardBulkDelete>;
  GiftCardCountableConnection: ResolverTypeWrapper<GiftCardCountableConnection>;
  GiftCardCountableEdge: ResolverTypeWrapper<GiftCardCountableEdge>;
  GiftCardCreate: ResolverTypeWrapper<GiftCardCreate>;
  GiftCardCreateInput: GiftCardCreateInput;
  GiftCardCreated: ResolverTypeWrapper<GiftCardCreated>;
  GiftCardDeactivate: ResolverTypeWrapper<GiftCardDeactivate>;
  GiftCardDelete: ResolverTypeWrapper<GiftCardDelete>;
  GiftCardDeleted: ResolverTypeWrapper<GiftCardDeleted>;
  GiftCardError: ResolverTypeWrapper<GiftCardError>;
  GiftCardErrorCode: GiftCardErrorCode;
  GiftCardEvent: ResolverTypeWrapper<GiftCardEvent>;
  GiftCardEventBalance: ResolverTypeWrapper<GiftCardEventBalance>;
  GiftCardEventFilterInput: GiftCardEventFilterInput;
  GiftCardEventsEnum: GiftCardEventsEnum;
  GiftCardFilterInput: GiftCardFilterInput;
  GiftCardResend: ResolverTypeWrapper<GiftCardResend>;
  GiftCardResendInput: GiftCardResendInput;
  GiftCardSettings: ResolverTypeWrapper<GiftCardSettings>;
  GiftCardSettingsError: ResolverTypeWrapper<GiftCardSettingsError>;
  GiftCardSettingsErrorCode: GiftCardSettingsErrorCode;
  GiftCardSettingsExpiryTypeEnum: GiftCardSettingsExpiryTypeEnum;
  GiftCardSettingsUpdate: ResolverTypeWrapper<GiftCardSettingsUpdate>;
  GiftCardSettingsUpdateInput: GiftCardSettingsUpdateInput;
  GiftCardSortField: GiftCardSortField;
  GiftCardSortingInput: GiftCardSortingInput;
  GiftCardStatusChanged: ResolverTypeWrapper<GiftCardStatusChanged>;
  GiftCardTag: ResolverTypeWrapper<GiftCardTag>;
  GiftCardTagCountableConnection: ResolverTypeWrapper<GiftCardTagCountableConnection>;
  GiftCardTagCountableEdge: ResolverTypeWrapper<GiftCardTagCountableEdge>;
  GiftCardTagFilterInput: GiftCardTagFilterInput;
  GiftCardUpdate: ResolverTypeWrapper<GiftCardUpdate>;
  GiftCardUpdateInput: GiftCardUpdateInput;
  GiftCardUpdated: ResolverTypeWrapper<GiftCardUpdated>;
  Group: ResolverTypeWrapper<Group>;
  GroupCountableConnection: ResolverTypeWrapper<GroupCountableConnection>;
  GroupCountableEdge: ResolverTypeWrapper<GroupCountableEdge>;
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Image: ResolverTypeWrapper<Image>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  IntRangeInput: IntRangeInput;
  Invoice: ResolverTypeWrapper<Invoice>;
  InvoiceCreate: ResolverTypeWrapper<InvoiceCreate>;
  InvoiceCreateInput: InvoiceCreateInput;
  InvoiceDelete: ResolverTypeWrapper<InvoiceDelete>;
  InvoiceDeleted: ResolverTypeWrapper<InvoiceDeleted>;
  InvoiceError: ResolverTypeWrapper<InvoiceError>;
  InvoiceErrorCode: InvoiceErrorCode;
  InvoiceRequest: ResolverTypeWrapper<InvoiceRequest>;
  InvoiceRequestDelete: ResolverTypeWrapper<InvoiceRequestDelete>;
  InvoiceRequested: ResolverTypeWrapper<InvoiceRequested>;
  InvoiceSendNotification: ResolverTypeWrapper<InvoiceSendNotification>;
  InvoiceSent: ResolverTypeWrapper<InvoiceSent>;
  InvoiceUpdate: ResolverTypeWrapper<InvoiceUpdate>;
  JSONString: ResolverTypeWrapper<Scalars['JSONString']>;
  Job: ResolversTypes['AppInstallation'] | ResolversTypes['ExportFile'] | ResolversTypes['Invoice'];
  JobStatusEnum: JobStatusEnum;
  LanguageCodeEnum: LanguageCodeEnum;
  LanguageDisplay: ResolverTypeWrapper<LanguageDisplay>;
  LimitInfo: ResolverTypeWrapper<LimitInfo>;
  Limits: ResolverTypeWrapper<Limits>;
  Manifest: ResolverTypeWrapper<Manifest>;
  Margin: ResolverTypeWrapper<Margin>;
  MeasurementUnitsEnum: MeasurementUnitsEnum;
  Menu: ResolverTypeWrapper<Menu>;
  MenuBulkDelete: ResolverTypeWrapper<MenuBulkDelete>;
  MenuCountableConnection: ResolverTypeWrapper<MenuCountableConnection>;
  MenuCountableEdge: ResolverTypeWrapper<MenuCountableEdge>;
  MenuCreate: ResolverTypeWrapper<MenuCreate>;
  MenuCreateInput: MenuCreateInput;
  MenuDelete: ResolverTypeWrapper<MenuDelete>;
  MenuError: ResolverTypeWrapper<MenuError>;
  MenuErrorCode: MenuErrorCode;
  MenuFilterInput: MenuFilterInput;
  MenuInput: MenuInput;
  MenuItem: ResolverTypeWrapper<MenuItem>;
  MenuItemBulkDelete: ResolverTypeWrapper<MenuItemBulkDelete>;
  MenuItemCountableConnection: ResolverTypeWrapper<MenuItemCountableConnection>;
  MenuItemCountableEdge: ResolverTypeWrapper<MenuItemCountableEdge>;
  MenuItemCreate: ResolverTypeWrapper<MenuItemCreate>;
  MenuItemCreateInput: MenuItemCreateInput;
  MenuItemDelete: ResolverTypeWrapper<MenuItemDelete>;
  MenuItemFilterInput: MenuItemFilterInput;
  MenuItemInput: MenuItemInput;
  MenuItemMove: ResolverTypeWrapper<MenuItemMove>;
  MenuItemMoveInput: MenuItemMoveInput;
  MenuItemSortingInput: MenuItemSortingInput;
  MenuItemTranslatableContent: ResolverTypeWrapper<MenuItemTranslatableContent>;
  MenuItemTranslate: ResolverTypeWrapper<MenuItemTranslate>;
  MenuItemTranslation: ResolverTypeWrapper<MenuItemTranslation>;
  MenuItemUpdate: ResolverTypeWrapper<MenuItemUpdate>;
  MenuItemsSortField: MenuItemsSortField;
  MenuSortField: MenuSortField;
  MenuSortingInput: MenuSortingInput;
  MenuUpdate: ResolverTypeWrapper<MenuUpdate>;
  Metadata: ResolverTypeWrapper<Scalars['Metadata']>;
  MetadataError: ResolverTypeWrapper<MetadataError>;
  MetadataErrorCode: MetadataErrorCode;
  MetadataFilter: MetadataFilter;
  MetadataInput: MetadataInput;
  MetadataItem: ResolverTypeWrapper<MetadataItem>;
  Money: ResolverTypeWrapper<Money>;
  MoneyInput: MoneyInput;
  MoneyRange: ResolverTypeWrapper<MoneyRange>;
  MoveProductInput: MoveProductInput;
  Mutation: ResolverTypeWrapper<{}>;
  NameTranslationInput: NameTranslationInput;
  NavigationType: NavigationType;
  Node: ResolversTypes['Address'] | ResolversTypes['Allocation'] | ResolversTypes['App'] | ResolversTypes['AppExtension'] | ResolversTypes['AppInstallation'] | ResolversTypes['AppToken'] | ResolversTypes['Attribute'] | ResolversTypes['AttributeTranslatableContent'] | ResolversTypes['AttributeTranslation'] | ResolversTypes['AttributeValue'] | ResolversTypes['AttributeValueTranslatableContent'] | ResolversTypes['AttributeValueTranslation'] | ResolversTypes['Category'] | ResolversTypes['CategoryTranslatableContent'] | ResolversTypes['CategoryTranslation'] | ResolversTypes['Channel'] | ResolversTypes['Checkout'] | ResolversTypes['CheckoutLine'] | ResolversTypes['Collection'] | ResolversTypes['CollectionChannelListing'] | ResolversTypes['CollectionTranslatableContent'] | ResolversTypes['CollectionTranslation'] | ResolversTypes['CustomerEvent'] | ResolversTypes['DigitalContent'] | ResolversTypes['DigitalContentUrl'] | ResolversTypes['EventDelivery'] | ResolversTypes['EventDeliveryAttempt'] | ResolversTypes['ExportEvent'] | ResolversTypes['ExportFile'] | ResolversTypes['Fulfillment'] | ResolversTypes['FulfillmentLine'] | ResolversTypes['GiftCard'] | ResolversTypes['GiftCardEvent'] | ResolversTypes['GiftCardTag'] | ResolversTypes['Group'] | ResolversTypes['Invoice'] | ResolversTypes['Menu'] | ResolversTypes['MenuItem'] | ResolversTypes['MenuItemTranslatableContent'] | ResolversTypes['MenuItemTranslation'] | ResolversTypes['Order'] | ResolversTypes['OrderDiscount'] | ResolversTypes['OrderEvent'] | ResolversTypes['OrderLine'] | ResolversTypes['Page'] | ResolversTypes['PageTranslatableContent'] | ResolversTypes['PageTranslation'] | ResolversTypes['PageType'] | ResolversTypes['Payment'] | ResolversTypes['Product'] | ResolversTypes['ProductChannelListing'] | ResolversTypes['ProductMedia'] | ResolversTypes['ProductTranslatableContent'] | ResolversTypes['ProductTranslation'] | ResolversTypes['ProductType'] | ResolversTypes['ProductVariant'] | ResolversTypes['ProductVariantChannelListing'] | ResolversTypes['ProductVariantTranslatableContent'] | ResolversTypes['ProductVariantTranslation'] | ResolversTypes['Sale'] | ResolversTypes['SaleChannelListing'] | ResolversTypes['SaleTranslatableContent'] | ResolversTypes['SaleTranslation'] | ResolversTypes['ShippingMethod'] | ResolversTypes['ShippingMethodChannelListing'] | ResolversTypes['ShippingMethodPostalCodeRule'] | ResolversTypes['ShippingMethodTranslatableContent'] | ResolversTypes['ShippingMethodTranslation'] | ResolversTypes['ShippingMethodType'] | ResolversTypes['ShippingZone'] | ResolversTypes['ShopTranslation'] | ResolversTypes['StaffNotificationRecipient'] | ResolversTypes['Stock'] | ResolversTypes['Transaction'] | ResolversTypes['User'] | ResolversTypes['Voucher'] | ResolversTypes['VoucherChannelListing'] | ResolversTypes['VoucherTranslatableContent'] | ResolversTypes['VoucherTranslation'] | ResolversTypes['Warehouse'] | ResolversTypes['Webhook'];
  ObjectWithMetadata: ResolversTypes['App'] | ResolversTypes['Attribute'] | ResolversTypes['Category'] | ResolversTypes['Checkout'] | ResolversTypes['Collection'] | ResolversTypes['DigitalContent'] | ResolversTypes['Fulfillment'] | ResolversTypes['GiftCard'] | ResolversTypes['Invoice'] | ResolversTypes['Menu'] | ResolversTypes['MenuItem'] | ResolversTypes['Order'] | ResolversTypes['Page'] | ResolversTypes['PageType'] | ResolversTypes['Payment'] | ResolversTypes['Product'] | ResolversTypes['ProductType'] | ResolversTypes['ProductVariant'] | ResolversTypes['Sale'] | ResolversTypes['ShippingMethod'] | ResolversTypes['ShippingMethodType'] | ResolversTypes['ShippingZone'] | ResolversTypes['User'] | ResolversTypes['Voucher'] | ResolversTypes['Warehouse'];
  Order: ResolverTypeWrapper<Omit<Order, 'deliveryMethod'> & { deliveryMethod?: Maybe<ResolversTypes['DeliveryMethod']> }>;
  OrderAction: OrderAction;
  OrderAddNote: ResolverTypeWrapper<OrderAddNote>;
  OrderAddNoteInput: OrderAddNoteInput;
  OrderBulkCancel: ResolverTypeWrapper<OrderBulkCancel>;
  OrderCancel: ResolverTypeWrapper<OrderCancel>;
  OrderCancelled: ResolverTypeWrapper<OrderCancelled>;
  OrderCapture: ResolverTypeWrapper<OrderCapture>;
  OrderConfirm: ResolverTypeWrapper<OrderConfirm>;
  OrderConfirmed: ResolverTypeWrapper<OrderConfirmed>;
  OrderCountableConnection: ResolverTypeWrapper<OrderCountableConnection>;
  OrderCountableEdge: ResolverTypeWrapper<OrderCountableEdge>;
  OrderCreateFromCheckout: ResolverTypeWrapper<OrderCreateFromCheckout>;
  OrderCreateFromCheckoutError: ResolverTypeWrapper<OrderCreateFromCheckoutError>;
  OrderCreateFromCheckoutErrorCode: OrderCreateFromCheckoutErrorCode;
  OrderCreated: ResolverTypeWrapper<OrderCreated>;
  OrderDirection: OrderDirection;
  OrderDiscount: ResolverTypeWrapper<OrderDiscount>;
  OrderDiscountAdd: ResolverTypeWrapper<OrderDiscountAdd>;
  OrderDiscountCommonInput: OrderDiscountCommonInput;
  OrderDiscountDelete: ResolverTypeWrapper<OrderDiscountDelete>;
  OrderDiscountType: OrderDiscountType;
  OrderDiscountUpdate: ResolverTypeWrapper<OrderDiscountUpdate>;
  OrderDraftFilterInput: OrderDraftFilterInput;
  OrderError: ResolverTypeWrapper<OrderError>;
  OrderErrorCode: OrderErrorCode;
  OrderEvent: ResolverTypeWrapper<OrderEvent>;
  OrderEventCountableConnection: ResolverTypeWrapper<OrderEventCountableConnection>;
  OrderEventCountableEdge: ResolverTypeWrapper<OrderEventCountableEdge>;
  OrderEventDiscountObject: ResolverTypeWrapper<OrderEventDiscountObject>;
  OrderEventOrderLineObject: ResolverTypeWrapper<OrderEventOrderLineObject>;
  OrderEventsEmailsEnum: OrderEventsEmailsEnum;
  OrderEventsEnum: OrderEventsEnum;
  OrderFilterInput: OrderFilterInput;
  OrderFulfill: ResolverTypeWrapper<OrderFulfill>;
  OrderFulfillInput: OrderFulfillInput;
  OrderFulfillLineInput: OrderFulfillLineInput;
  OrderFulfillStockInput: OrderFulfillStockInput;
  OrderFulfilled: ResolverTypeWrapper<OrderFulfilled>;
  OrderFullyPaid: ResolverTypeWrapper<OrderFullyPaid>;
  OrderLine: ResolverTypeWrapper<OrderLine>;
  OrderLineCreateInput: OrderLineCreateInput;
  OrderLineDelete: ResolverTypeWrapper<OrderLineDelete>;
  OrderLineDiscountRemove: ResolverTypeWrapper<OrderLineDiscountRemove>;
  OrderLineDiscountUpdate: ResolverTypeWrapper<OrderLineDiscountUpdate>;
  OrderLineInput: OrderLineInput;
  OrderLineUpdate: ResolverTypeWrapper<OrderLineUpdate>;
  OrderLinesCreate: ResolverTypeWrapper<OrderLinesCreate>;
  OrderMarkAsPaid: ResolverTypeWrapper<OrderMarkAsPaid>;
  OrderOriginEnum: OrderOriginEnum;
  OrderRefund: ResolverTypeWrapper<OrderRefund>;
  OrderRefundFulfillmentLineInput: OrderRefundFulfillmentLineInput;
  OrderRefundLineInput: OrderRefundLineInput;
  OrderRefundProductsInput: OrderRefundProductsInput;
  OrderReturnFulfillmentLineInput: OrderReturnFulfillmentLineInput;
  OrderReturnLineInput: OrderReturnLineInput;
  OrderReturnProductsInput: OrderReturnProductsInput;
  OrderSettings: ResolverTypeWrapper<OrderSettings>;
  OrderSettingsError: ResolverTypeWrapper<OrderSettingsError>;
  OrderSettingsErrorCode: OrderSettingsErrorCode;
  OrderSettingsUpdate: ResolverTypeWrapper<OrderSettingsUpdate>;
  OrderSettingsUpdateInput: OrderSettingsUpdateInput;
  OrderSortField: OrderSortField;
  OrderSortingInput: OrderSortingInput;
  OrderStatus: OrderStatus;
  OrderStatusFilter: OrderStatusFilter;
  OrderUpdate: ResolverTypeWrapper<OrderUpdate>;
  OrderUpdateInput: OrderUpdateInput;
  OrderUpdateShipping: ResolverTypeWrapper<OrderUpdateShipping>;
  OrderUpdateShippingInput: OrderUpdateShippingInput;
  OrderUpdated: ResolverTypeWrapper<OrderUpdated>;
  OrderVoid: ResolverTypeWrapper<OrderVoid>;
  Page: ResolverTypeWrapper<Page>;
  PageAttributeAssign: ResolverTypeWrapper<PageAttributeAssign>;
  PageAttributeUnassign: ResolverTypeWrapper<PageAttributeUnassign>;
  PageBulkDelete: ResolverTypeWrapper<PageBulkDelete>;
  PageBulkPublish: ResolverTypeWrapper<PageBulkPublish>;
  PageCountableConnection: ResolverTypeWrapper<PageCountableConnection>;
  PageCountableEdge: ResolverTypeWrapper<PageCountableEdge>;
  PageCreate: ResolverTypeWrapper<PageCreate>;
  PageCreateInput: PageCreateInput;
  PageCreated: ResolverTypeWrapper<PageCreated>;
  PageDelete: ResolverTypeWrapper<PageDelete>;
  PageDeleted: ResolverTypeWrapper<PageDeleted>;
  PageError: ResolverTypeWrapper<PageError>;
  PageErrorCode: PageErrorCode;
  PageFilterInput: PageFilterInput;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PageInput: PageInput;
  PageReorderAttributeValues: ResolverTypeWrapper<PageReorderAttributeValues>;
  PageSortField: PageSortField;
  PageSortingInput: PageSortingInput;
  PageTranslatableContent: ResolverTypeWrapper<PageTranslatableContent>;
  PageTranslate: ResolverTypeWrapper<PageTranslate>;
  PageTranslation: ResolverTypeWrapper<PageTranslation>;
  PageTranslationInput: PageTranslationInput;
  PageType: ResolverTypeWrapper<PageType>;
  PageTypeBulkDelete: ResolverTypeWrapper<PageTypeBulkDelete>;
  PageTypeCountableConnection: ResolverTypeWrapper<PageTypeCountableConnection>;
  PageTypeCountableEdge: ResolverTypeWrapper<PageTypeCountableEdge>;
  PageTypeCreate: ResolverTypeWrapper<PageTypeCreate>;
  PageTypeCreateInput: PageTypeCreateInput;
  PageTypeDelete: ResolverTypeWrapper<PageTypeDelete>;
  PageTypeFilterInput: PageTypeFilterInput;
  PageTypeReorderAttributes: ResolverTypeWrapper<PageTypeReorderAttributes>;
  PageTypeSortField: PageTypeSortField;
  PageTypeSortingInput: PageTypeSortingInput;
  PageTypeUpdate: ResolverTypeWrapper<PageTypeUpdate>;
  PageTypeUpdateInput: PageTypeUpdateInput;
  PageUpdate: ResolverTypeWrapper<PageUpdate>;
  PageUpdated: ResolverTypeWrapper<PageUpdated>;
  PasswordChange: ResolverTypeWrapper<PasswordChange>;
  Payment: ResolverTypeWrapper<Payment>;
  PaymentCapture: ResolverTypeWrapper<PaymentCapture>;
  PaymentChargeStatusEnum: PaymentChargeStatusEnum;
  PaymentCheckBalance: ResolverTypeWrapper<PaymentCheckBalance>;
  PaymentCheckBalanceInput: PaymentCheckBalanceInput;
  PaymentCountableConnection: ResolverTypeWrapper<PaymentCountableConnection>;
  PaymentCountableEdge: ResolverTypeWrapper<PaymentCountableEdge>;
  PaymentError: ResolverTypeWrapper<PaymentError>;
  PaymentErrorCode: PaymentErrorCode;
  PaymentFilterInput: PaymentFilterInput;
  PaymentGateway: ResolverTypeWrapper<PaymentGateway>;
  PaymentInitialize: ResolverTypeWrapper<PaymentInitialize>;
  PaymentInitialized: ResolverTypeWrapper<PaymentInitialized>;
  PaymentInput: PaymentInput;
  PaymentRefund: ResolverTypeWrapper<PaymentRefund>;
  PaymentSource: ResolverTypeWrapper<PaymentSource>;
  PaymentVoid: ResolverTypeWrapper<PaymentVoid>;
  Permission: ResolverTypeWrapper<Permission>;
  PermissionEnum: PermissionEnum;
  PermissionGroupCreate: ResolverTypeWrapper<PermissionGroupCreate>;
  PermissionGroupCreateInput: PermissionGroupCreateInput;
  PermissionGroupDelete: ResolverTypeWrapper<PermissionGroupDelete>;
  PermissionGroupError: ResolverTypeWrapper<PermissionGroupError>;
  PermissionGroupErrorCode: PermissionGroupErrorCode;
  PermissionGroupFilterInput: PermissionGroupFilterInput;
  PermissionGroupSortField: PermissionGroupSortField;
  PermissionGroupSortingInput: PermissionGroupSortingInput;
  PermissionGroupUpdate: ResolverTypeWrapper<PermissionGroupUpdate>;
  PermissionGroupUpdateInput: PermissionGroupUpdateInput;
  Plugin: ResolverTypeWrapper<Plugin>;
  PluginConfiguration: ResolverTypeWrapper<PluginConfiguration>;
  PluginConfigurationType: PluginConfigurationType;
  PluginCountableConnection: ResolverTypeWrapper<PluginCountableConnection>;
  PluginCountableEdge: ResolverTypeWrapper<PluginCountableEdge>;
  PluginError: ResolverTypeWrapper<PluginError>;
  PluginErrorCode: PluginErrorCode;
  PluginFilterInput: PluginFilterInput;
  PluginSortField: PluginSortField;
  PluginSortingInput: PluginSortingInput;
  PluginStatusInChannelsInput: PluginStatusInChannelsInput;
  PluginUpdate: ResolverTypeWrapper<PluginUpdate>;
  PluginUpdateInput: PluginUpdateInput;
  PositiveDecimal: ResolverTypeWrapper<Scalars['PositiveDecimal']>;
  PostalCodeRuleInclusionTypeEnum: PostalCodeRuleInclusionTypeEnum;
  PreorderData: ResolverTypeWrapper<PreorderData>;
  PreorderSettingsInput: PreorderSettingsInput;
  PreorderThreshold: ResolverTypeWrapper<PreorderThreshold>;
  PriceInput: PriceInput;
  PriceRangeInput: PriceRangeInput;
  Product: ResolverTypeWrapper<Product>;
  ProductAttributeAssign: ResolverTypeWrapper<ProductAttributeAssign>;
  ProductAttributeAssignInput: ProductAttributeAssignInput;
  ProductAttributeAssignmentUpdate: ResolverTypeWrapper<ProductAttributeAssignmentUpdate>;
  ProductAttributeAssignmentUpdateInput: ProductAttributeAssignmentUpdateInput;
  ProductAttributeType: ProductAttributeType;
  ProductAttributeUnassign: ResolverTypeWrapper<ProductAttributeUnassign>;
  ProductBulkDelete: ResolverTypeWrapper<ProductBulkDelete>;
  ProductChannelListing: ResolverTypeWrapper<ProductChannelListing>;
  ProductChannelListingAddInput: ProductChannelListingAddInput;
  ProductChannelListingError: ResolverTypeWrapper<ProductChannelListingError>;
  ProductChannelListingUpdate: ResolverTypeWrapper<ProductChannelListingUpdate>;
  ProductChannelListingUpdateInput: ProductChannelListingUpdateInput;
  ProductCountableConnection: ResolverTypeWrapper<ProductCountableConnection>;
  ProductCountableEdge: ResolverTypeWrapper<ProductCountableEdge>;
  ProductCreate: ResolverTypeWrapper<ProductCreate>;
  ProductCreateInput: ProductCreateInput;
  ProductCreated: ResolverTypeWrapper<ProductCreated>;
  ProductDelete: ResolverTypeWrapper<ProductDelete>;
  ProductDeleted: ResolverTypeWrapper<ProductDeleted>;
  ProductError: ResolverTypeWrapper<ProductError>;
  ProductErrorCode: ProductErrorCode;
  ProductFieldEnum: ProductFieldEnum;
  ProductFilterInput: ProductFilterInput;
  ProductImage: ResolverTypeWrapper<ProductImage>;
  ProductInput: ProductInput;
  ProductMedia: ResolverTypeWrapper<ProductMedia>;
  ProductMediaBulkDelete: ResolverTypeWrapper<ProductMediaBulkDelete>;
  ProductMediaCreate: ResolverTypeWrapper<ProductMediaCreate>;
  ProductMediaCreateInput: ProductMediaCreateInput;
  ProductMediaDelete: ResolverTypeWrapper<ProductMediaDelete>;
  ProductMediaReorder: ResolverTypeWrapper<ProductMediaReorder>;
  ProductMediaType: ProductMediaType;
  ProductMediaUpdate: ResolverTypeWrapper<ProductMediaUpdate>;
  ProductMediaUpdateInput: ProductMediaUpdateInput;
  ProductOrder: ProductOrder;
  ProductOrderField: ProductOrderField;
  ProductPricingInfo: ResolverTypeWrapper<ProductPricingInfo>;
  ProductReorderAttributeValues: ResolverTypeWrapper<ProductReorderAttributeValues>;
  ProductStockFilterInput: ProductStockFilterInput;
  ProductTranslatableContent: ResolverTypeWrapper<ProductTranslatableContent>;
  ProductTranslate: ResolverTypeWrapper<ProductTranslate>;
  ProductTranslation: ResolverTypeWrapper<ProductTranslation>;
  ProductType: ResolverTypeWrapper<ProductType>;
  ProductTypeBulkDelete: ResolverTypeWrapper<ProductTypeBulkDelete>;
  ProductTypeConfigurable: ProductTypeConfigurable;
  ProductTypeCountableConnection: ResolverTypeWrapper<ProductTypeCountableConnection>;
  ProductTypeCountableEdge: ResolverTypeWrapper<ProductTypeCountableEdge>;
  ProductTypeCreate: ResolverTypeWrapper<ProductTypeCreate>;
  ProductTypeDelete: ResolverTypeWrapper<ProductTypeDelete>;
  ProductTypeEnum: ProductTypeEnum;
  ProductTypeFilterInput: ProductTypeFilterInput;
  ProductTypeInput: ProductTypeInput;
  ProductTypeKindEnum: ProductTypeKindEnum;
  ProductTypeReorderAttributes: ResolverTypeWrapper<ProductTypeReorderAttributes>;
  ProductTypeSortField: ProductTypeSortField;
  ProductTypeSortingInput: ProductTypeSortingInput;
  ProductTypeUpdate: ResolverTypeWrapper<ProductTypeUpdate>;
  ProductUpdate: ResolverTypeWrapper<ProductUpdate>;
  ProductUpdated: ResolverTypeWrapper<ProductUpdated>;
  ProductVariant: ResolverTypeWrapper<ProductVariant>;
  ProductVariantBackInStock: ResolverTypeWrapper<ProductVariantBackInStock>;
  ProductVariantBulkCreate: ResolverTypeWrapper<ProductVariantBulkCreate>;
  ProductVariantBulkCreateInput: ProductVariantBulkCreateInput;
  ProductVariantBulkDelete: ResolverTypeWrapper<ProductVariantBulkDelete>;
  ProductVariantChannelListing: ResolverTypeWrapper<ProductVariantChannelListing>;
  ProductVariantChannelListingAddInput: ProductVariantChannelListingAddInput;
  ProductVariantChannelListingUpdate: ResolverTypeWrapper<ProductVariantChannelListingUpdate>;
  ProductVariantCountableConnection: ResolverTypeWrapper<ProductVariantCountableConnection>;
  ProductVariantCountableEdge: ResolverTypeWrapper<ProductVariantCountableEdge>;
  ProductVariantCreate: ResolverTypeWrapper<ProductVariantCreate>;
  ProductVariantCreateInput: ProductVariantCreateInput;
  ProductVariantCreated: ResolverTypeWrapper<ProductVariantCreated>;
  ProductVariantDelete: ResolverTypeWrapper<ProductVariantDelete>;
  ProductVariantDeleted: ResolverTypeWrapper<ProductVariantDeleted>;
  ProductVariantFilterInput: ProductVariantFilterInput;
  ProductVariantInput: ProductVariantInput;
  ProductVariantOutOfStock: ResolverTypeWrapper<ProductVariantOutOfStock>;
  ProductVariantPreorderDeactivate: ResolverTypeWrapper<ProductVariantPreorderDeactivate>;
  ProductVariantReorder: ResolverTypeWrapper<ProductVariantReorder>;
  ProductVariantReorderAttributeValues: ResolverTypeWrapper<ProductVariantReorderAttributeValues>;
  ProductVariantSetDefault: ResolverTypeWrapper<ProductVariantSetDefault>;
  ProductVariantSortField: ProductVariantSortField;
  ProductVariantSortingInput: ProductVariantSortingInput;
  ProductVariantStocksCreate: ResolverTypeWrapper<ProductVariantStocksCreate>;
  ProductVariantStocksDelete: ResolverTypeWrapper<ProductVariantStocksDelete>;
  ProductVariantStocksUpdate: ResolverTypeWrapper<ProductVariantStocksUpdate>;
  ProductVariantTranslatableContent: ResolverTypeWrapper<ProductVariantTranslatableContent>;
  ProductVariantTranslate: ResolverTypeWrapper<ProductVariantTranslate>;
  ProductVariantTranslation: ResolverTypeWrapper<ProductVariantTranslation>;
  ProductVariantUpdate: ResolverTypeWrapper<ProductVariantUpdate>;
  ProductVariantUpdated: ResolverTypeWrapper<ProductVariantUpdated>;
  PublishableChannelListingInput: PublishableChannelListingInput;
  Query: ResolverTypeWrapper<{}>;
  ReducedRate: ResolverTypeWrapper<ReducedRate>;
  RefreshToken: ResolverTypeWrapper<RefreshToken>;
  ReorderInput: ReorderInput;
  ReportingPeriod: ReportingPeriod;
  RequestEmailChange: ResolverTypeWrapper<RequestEmailChange>;
  RequestPasswordReset: ResolverTypeWrapper<RequestPasswordReset>;
  Sale: ResolverTypeWrapper<Sale>;
  SaleAddCatalogues: ResolverTypeWrapper<SaleAddCatalogues>;
  SaleBulkDelete: ResolverTypeWrapper<SaleBulkDelete>;
  SaleChannelListing: ResolverTypeWrapper<SaleChannelListing>;
  SaleChannelListingAddInput: SaleChannelListingAddInput;
  SaleChannelListingInput: SaleChannelListingInput;
  SaleChannelListingUpdate: ResolverTypeWrapper<SaleChannelListingUpdate>;
  SaleCountableConnection: ResolverTypeWrapper<SaleCountableConnection>;
  SaleCountableEdge: ResolverTypeWrapper<SaleCountableEdge>;
  SaleCreate: ResolverTypeWrapper<SaleCreate>;
  SaleCreated: ResolverTypeWrapper<SaleCreated>;
  SaleDelete: ResolverTypeWrapper<SaleDelete>;
  SaleDeleted: ResolverTypeWrapper<SaleDeleted>;
  SaleFilterInput: SaleFilterInput;
  SaleInput: SaleInput;
  SaleRemoveCatalogues: ResolverTypeWrapper<SaleRemoveCatalogues>;
  SaleSortField: SaleSortField;
  SaleSortingInput: SaleSortingInput;
  SaleTranslatableContent: ResolverTypeWrapper<SaleTranslatableContent>;
  SaleTranslate: ResolverTypeWrapper<SaleTranslate>;
  SaleTranslation: ResolverTypeWrapper<SaleTranslation>;
  SaleType: SaleType;
  SaleUpdate: ResolverTypeWrapper<SaleUpdate>;
  SaleUpdated: ResolverTypeWrapper<SaleUpdated>;
  SelectedAttribute: ResolverTypeWrapper<SelectedAttribute>;
  SeoInput: SeoInput;
  SetPassword: ResolverTypeWrapper<SetPassword>;
  ShippingError: ResolverTypeWrapper<ShippingError>;
  ShippingErrorCode: ShippingErrorCode;
  ShippingMethod: ResolverTypeWrapper<ShippingMethod>;
  ShippingMethodChannelListing: ResolverTypeWrapper<ShippingMethodChannelListing>;
  ShippingMethodChannelListingAddInput: ShippingMethodChannelListingAddInput;
  ShippingMethodChannelListingInput: ShippingMethodChannelListingInput;
  ShippingMethodChannelListingUpdate: ResolverTypeWrapper<ShippingMethodChannelListingUpdate>;
  ShippingMethodPostalCodeRule: ResolverTypeWrapper<ShippingMethodPostalCodeRule>;
  ShippingMethodTranslatableContent: ResolverTypeWrapper<ShippingMethodTranslatableContent>;
  ShippingMethodTranslation: ResolverTypeWrapper<ShippingMethodTranslation>;
  ShippingMethodType: ResolverTypeWrapper<ShippingMethodType>;
  ShippingMethodTypeEnum: ShippingMethodTypeEnum;
  ShippingPostalCodeRulesCreateInputRange: ShippingPostalCodeRulesCreateInputRange;
  ShippingPriceBulkDelete: ResolverTypeWrapper<ShippingPriceBulkDelete>;
  ShippingPriceCreate: ResolverTypeWrapper<ShippingPriceCreate>;
  ShippingPriceCreated: ResolverTypeWrapper<ShippingPriceCreated>;
  ShippingPriceDelete: ResolverTypeWrapper<ShippingPriceDelete>;
  ShippingPriceDeleted: ResolverTypeWrapper<ShippingPriceDeleted>;
  ShippingPriceExcludeProducts: ResolverTypeWrapper<ShippingPriceExcludeProducts>;
  ShippingPriceExcludeProductsInput: ShippingPriceExcludeProductsInput;
  ShippingPriceInput: ShippingPriceInput;
  ShippingPriceRemoveProductFromExclude: ResolverTypeWrapper<ShippingPriceRemoveProductFromExclude>;
  ShippingPriceTranslate: ResolverTypeWrapper<ShippingPriceTranslate>;
  ShippingPriceTranslationInput: ShippingPriceTranslationInput;
  ShippingPriceUpdate: ResolverTypeWrapper<ShippingPriceUpdate>;
  ShippingPriceUpdated: ResolverTypeWrapper<ShippingPriceUpdated>;
  ShippingZone: ResolverTypeWrapper<ShippingZone>;
  ShippingZoneBulkDelete: ResolverTypeWrapper<ShippingZoneBulkDelete>;
  ShippingZoneCountableConnection: ResolverTypeWrapper<ShippingZoneCountableConnection>;
  ShippingZoneCountableEdge: ResolverTypeWrapper<ShippingZoneCountableEdge>;
  ShippingZoneCreate: ResolverTypeWrapper<ShippingZoneCreate>;
  ShippingZoneCreateInput: ShippingZoneCreateInput;
  ShippingZoneCreated: ResolverTypeWrapper<ShippingZoneCreated>;
  ShippingZoneDelete: ResolverTypeWrapper<ShippingZoneDelete>;
  ShippingZoneDeleted: ResolverTypeWrapper<ShippingZoneDeleted>;
  ShippingZoneFilterInput: ShippingZoneFilterInput;
  ShippingZoneUpdate: ResolverTypeWrapper<ShippingZoneUpdate>;
  ShippingZoneUpdateInput: ShippingZoneUpdateInput;
  ShippingZoneUpdated: ResolverTypeWrapper<ShippingZoneUpdated>;
  Shop: ResolverTypeWrapper<Shop>;
  ShopAddressUpdate: ResolverTypeWrapper<ShopAddressUpdate>;
  ShopDomainUpdate: ResolverTypeWrapper<ShopDomainUpdate>;
  ShopError: ResolverTypeWrapper<ShopError>;
  ShopErrorCode: ShopErrorCode;
  ShopFetchTaxRates: ResolverTypeWrapper<ShopFetchTaxRates>;
  ShopSettingsInput: ShopSettingsInput;
  ShopSettingsTranslate: ResolverTypeWrapper<ShopSettingsTranslate>;
  ShopSettingsTranslationInput: ShopSettingsTranslationInput;
  ShopSettingsUpdate: ResolverTypeWrapper<ShopSettingsUpdate>;
  ShopTranslation: ResolverTypeWrapper<ShopTranslation>;
  SiteDomainInput: SiteDomainInput;
  StaffBulkDelete: ResolverTypeWrapper<StaffBulkDelete>;
  StaffCreate: ResolverTypeWrapper<StaffCreate>;
  StaffCreateInput: StaffCreateInput;
  StaffDelete: ResolverTypeWrapper<StaffDelete>;
  StaffError: ResolverTypeWrapper<StaffError>;
  StaffMemberStatus: StaffMemberStatus;
  StaffNotificationRecipient: ResolverTypeWrapper<StaffNotificationRecipient>;
  StaffNotificationRecipientCreate: ResolverTypeWrapper<StaffNotificationRecipientCreate>;
  StaffNotificationRecipientDelete: ResolverTypeWrapper<StaffNotificationRecipientDelete>;
  StaffNotificationRecipientInput: StaffNotificationRecipientInput;
  StaffNotificationRecipientUpdate: ResolverTypeWrapper<StaffNotificationRecipientUpdate>;
  StaffUpdate: ResolverTypeWrapper<StaffUpdate>;
  StaffUpdateInput: StaffUpdateInput;
  StaffUserInput: StaffUserInput;
  Stock: ResolverTypeWrapper<Stock>;
  StockAvailability: StockAvailability;
  StockCountableConnection: ResolverTypeWrapper<StockCountableConnection>;
  StockCountableEdge: ResolverTypeWrapper<StockCountableEdge>;
  StockError: ResolverTypeWrapper<StockError>;
  StockErrorCode: StockErrorCode;
  StockFilterInput: StockFilterInput;
  StockInput: StockInput;
  StorePaymentMethodEnum: StorePaymentMethodEnum;
  String: ResolverTypeWrapper<Scalars['String']>;
  Subscription: ResolverTypeWrapper<{}>;
  TaxType: ResolverTypeWrapper<TaxType>;
  TaxedMoney: ResolverTypeWrapper<TaxedMoney>;
  TaxedMoneyRange: ResolverTypeWrapper<TaxedMoneyRange>;
  TimePeriod: ResolverTypeWrapper<TimePeriod>;
  TimePeriodInputType: TimePeriodInputType;
  TimePeriodTypeEnum: TimePeriodTypeEnum;
  Transaction: ResolverTypeWrapper<Transaction>;
  TransactionKind: TransactionKind;
  TranslatableItem: ResolversTypes['AttributeTranslatableContent'] | ResolversTypes['AttributeValueTranslatableContent'] | ResolversTypes['CategoryTranslatableContent'] | ResolversTypes['CollectionTranslatableContent'] | ResolversTypes['MenuItemTranslatableContent'] | ResolversTypes['PageTranslatableContent'] | ResolversTypes['ProductTranslatableContent'] | ResolversTypes['ProductVariantTranslatableContent'] | ResolversTypes['SaleTranslatableContent'] | ResolversTypes['ShippingMethodTranslatableContent'] | ResolversTypes['VoucherTranslatableContent'];
  TranslatableItemConnection: ResolverTypeWrapper<TranslatableItemConnection>;
  TranslatableItemEdge: ResolverTypeWrapper<Omit<TranslatableItemEdge, 'node'> & { node: ResolversTypes['TranslatableItem'] }>;
  TranslatableKinds: TranslatableKinds;
  TranslationCreated: ResolverTypeWrapper<Omit<TranslationCreated, 'translation'> & { translation?: Maybe<ResolversTypes['TranslationTypes']> }>;
  TranslationError: ResolverTypeWrapper<TranslationError>;
  TranslationErrorCode: TranslationErrorCode;
  TranslationInput: TranslationInput;
  TranslationTypes: ResolversTypes['AttributeTranslation'] | ResolversTypes['AttributeValueTranslation'] | ResolversTypes['CategoryTranslation'] | ResolversTypes['CollectionTranslation'] | ResolversTypes['MenuItemTranslation'] | ResolversTypes['PageTranslation'] | ResolversTypes['ProductTranslation'] | ResolversTypes['ProductVariantTranslation'] | ResolversTypes['SaleTranslation'] | ResolversTypes['ShippingMethodTranslation'] | ResolversTypes['VoucherTranslation'];
  TranslationUpdated: ResolverTypeWrapper<Omit<TranslationUpdated, 'translation'> & { translation?: Maybe<ResolversTypes['TranslationTypes']> }>;
  UUID: ResolverTypeWrapper<Scalars['UUID']>;
  UpdateInvoiceInput: UpdateInvoiceInput;
  UpdateMetadata: ResolverTypeWrapper<UpdateMetadata>;
  UpdatePrivateMetadata: ResolverTypeWrapper<UpdatePrivateMetadata>;
  Upload: ResolverTypeWrapper<Scalars['Upload']>;
  UploadError: ResolverTypeWrapper<UploadError>;
  UploadErrorCode: UploadErrorCode;
  User: ResolverTypeWrapper<User>;
  UserAvatarDelete: ResolverTypeWrapper<UserAvatarDelete>;
  UserAvatarUpdate: ResolverTypeWrapper<UserAvatarUpdate>;
  UserBulkSetActive: ResolverTypeWrapper<UserBulkSetActive>;
  UserCountableConnection: ResolverTypeWrapper<UserCountableConnection>;
  UserCountableEdge: ResolverTypeWrapper<UserCountableEdge>;
  UserCreateInput: UserCreateInput;
  UserPermission: ResolverTypeWrapper<UserPermission>;
  UserSortField: UserSortField;
  UserSortingInput: UserSortingInput;
  VAT: ResolverTypeWrapper<Vat>;
  VariantAttributeScope: VariantAttributeScope;
  VariantMediaAssign: ResolverTypeWrapper<VariantMediaAssign>;
  VariantMediaUnassign: ResolverTypeWrapper<VariantMediaUnassign>;
  VariantPricingInfo: ResolverTypeWrapper<VariantPricingInfo>;
  VerifyToken: ResolverTypeWrapper<VerifyToken>;
  VolumeUnitsEnum: VolumeUnitsEnum;
  Voucher: ResolverTypeWrapper<Voucher>;
  VoucherAddCatalogues: ResolverTypeWrapper<VoucherAddCatalogues>;
  VoucherBulkDelete: ResolverTypeWrapper<VoucherBulkDelete>;
  VoucherChannelListing: ResolverTypeWrapper<VoucherChannelListing>;
  VoucherChannelListingAddInput: VoucherChannelListingAddInput;
  VoucherChannelListingInput: VoucherChannelListingInput;
  VoucherChannelListingUpdate: ResolverTypeWrapper<VoucherChannelListingUpdate>;
  VoucherCountableConnection: ResolverTypeWrapper<VoucherCountableConnection>;
  VoucherCountableEdge: ResolverTypeWrapper<VoucherCountableEdge>;
  VoucherCreate: ResolverTypeWrapper<VoucherCreate>;
  VoucherDelete: ResolverTypeWrapper<VoucherDelete>;
  VoucherDiscountType: VoucherDiscountType;
  VoucherFilterInput: VoucherFilterInput;
  VoucherInput: VoucherInput;
  VoucherRemoveCatalogues: ResolverTypeWrapper<VoucherRemoveCatalogues>;
  VoucherSortField: VoucherSortField;
  VoucherSortingInput: VoucherSortingInput;
  VoucherTranslatableContent: ResolverTypeWrapper<VoucherTranslatableContent>;
  VoucherTranslate: ResolverTypeWrapper<VoucherTranslate>;
  VoucherTranslation: ResolverTypeWrapper<VoucherTranslation>;
  VoucherTypeEnum: VoucherTypeEnum;
  VoucherUpdate: ResolverTypeWrapper<VoucherUpdate>;
  Warehouse: ResolverTypeWrapper<Warehouse>;
  WarehouseClickAndCollectOptionEnum: WarehouseClickAndCollectOptionEnum;
  WarehouseCountableConnection: ResolverTypeWrapper<WarehouseCountableConnection>;
  WarehouseCountableEdge: ResolverTypeWrapper<WarehouseCountableEdge>;
  WarehouseCreate: ResolverTypeWrapper<WarehouseCreate>;
  WarehouseCreateInput: WarehouseCreateInput;
  WarehouseDelete: ResolverTypeWrapper<WarehouseDelete>;
  WarehouseError: ResolverTypeWrapper<WarehouseError>;
  WarehouseErrorCode: WarehouseErrorCode;
  WarehouseFilterInput: WarehouseFilterInput;
  WarehouseShippingZoneAssign: ResolverTypeWrapper<WarehouseShippingZoneAssign>;
  WarehouseShippingZoneUnassign: ResolverTypeWrapper<WarehouseShippingZoneUnassign>;
  WarehouseSortField: WarehouseSortField;
  WarehouseSortingInput: WarehouseSortingInput;
  WarehouseUpdate: ResolverTypeWrapper<WarehouseUpdate>;
  WarehouseUpdateInput: WarehouseUpdateInput;
  Webhook: ResolverTypeWrapper<Webhook>;
  WebhookCreate: ResolverTypeWrapper<WebhookCreate>;
  WebhookCreateInput: WebhookCreateInput;
  WebhookDelete: ResolverTypeWrapper<WebhookDelete>;
  WebhookError: ResolverTypeWrapper<WebhookError>;
  WebhookErrorCode: WebhookErrorCode;
  WebhookEvent: ResolverTypeWrapper<WebhookEvent>;
  WebhookEventAsync: ResolverTypeWrapper<WebhookEventAsync>;
  WebhookEventSync: ResolverTypeWrapper<WebhookEventSync>;
  WebhookEventTypeAsyncEnum: WebhookEventTypeAsyncEnum;
  WebhookEventTypeEnum: WebhookEventTypeEnum;
  WebhookEventTypeSyncEnum: WebhookEventTypeSyncEnum;
  WebhookSampleEventTypeEnum: WebhookSampleEventTypeEnum;
  WebhookUpdate: ResolverTypeWrapper<WebhookUpdate>;
  WebhookUpdateInput: WebhookUpdateInput;
  Weight: ResolverTypeWrapper<Weight>;
  WeightScalar: ResolverTypeWrapper<Scalars['WeightScalar']>;
  WeightUnitsEnum: WeightUnitsEnum;
  _Any: ResolverTypeWrapper<Scalars['_Any']>;
  _Entity: ResolversTypes['Address'] | ResolversTypes['App'] | ResolversTypes['Category'] | ResolversTypes['Collection'] | ResolversTypes['Group'] | ResolversTypes['PageType'] | ResolversTypes['Product'] | ResolversTypes['ProductMedia'] | ResolversTypes['ProductType'] | ResolversTypes['ProductVariant'] | ResolversTypes['User'];
  _Service: ResolverTypeWrapper<_Service>;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  AccountAddressCreate: AccountAddressCreate;
  AccountAddressDelete: AccountAddressDelete;
  AccountAddressUpdate: AccountAddressUpdate;
  AccountDelete: AccountDelete;
  AccountError: AccountError;
  AccountInput: AccountInput;
  AccountRegister: AccountRegister;
  AccountRegisterInput: AccountRegisterInput;
  AccountRequestDeletion: AccountRequestDeletion;
  AccountSetDefaultAddress: AccountSetDefaultAddress;
  AccountUpdate: AccountUpdate;
  Address: Address;
  AddressCreate: AddressCreate;
  AddressDelete: AddressDelete;
  AddressInput: AddressInput;
  AddressSetDefault: AddressSetDefault;
  AddressUpdate: AddressUpdate;
  AddressValidationData: AddressValidationData;
  Allocation: Allocation;
  App: App;
  AppActivate: AppActivate;
  AppCountableConnection: AppCountableConnection;
  AppCountableEdge: AppCountableEdge;
  AppCreate: AppCreate;
  AppDeactivate: AppDeactivate;
  AppDelete: AppDelete;
  AppDeleteFailedInstallation: AppDeleteFailedInstallation;
  AppError: AppError;
  AppExtension: AppExtension;
  AppExtensionCountableConnection: AppExtensionCountableConnection;
  AppExtensionCountableEdge: AppExtensionCountableEdge;
  AppExtensionFilterInput: AppExtensionFilterInput;
  AppFetchManifest: AppFetchManifest;
  AppFilterInput: AppFilterInput;
  AppInput: AppInput;
  AppInstall: AppInstall;
  AppInstallInput: AppInstallInput;
  AppInstallation: AppInstallation;
  AppManifestExtension: AppManifestExtension;
  AppRetryInstall: AppRetryInstall;
  AppSortingInput: AppSortingInput;
  AppToken: AppToken;
  AppTokenCreate: AppTokenCreate;
  AppTokenDelete: AppTokenDelete;
  AppTokenInput: AppTokenInput;
  AppTokenVerify: AppTokenVerify;
  AppUpdate: AppUpdate;
  AssignNavigation: AssignNavigation;
  AssignedVariantAttribute: AssignedVariantAttribute;
  Attribute: Attribute;
  AttributeBulkDelete: AttributeBulkDelete;
  AttributeChoicesSortingInput: AttributeChoicesSortingInput;
  AttributeCountableConnection: AttributeCountableConnection;
  AttributeCountableEdge: AttributeCountableEdge;
  AttributeCreate: AttributeCreate;
  AttributeCreateInput: AttributeCreateInput;
  AttributeDelete: AttributeDelete;
  AttributeError: AttributeError;
  AttributeFilterInput: AttributeFilterInput;
  AttributeInput: AttributeInput;
  AttributeReorderValues: AttributeReorderValues;
  AttributeSortingInput: AttributeSortingInput;
  AttributeTranslatableContent: AttributeTranslatableContent;
  AttributeTranslate: AttributeTranslate;
  AttributeTranslation: AttributeTranslation;
  AttributeUpdate: AttributeUpdate;
  AttributeUpdateInput: AttributeUpdateInput;
  AttributeValue: AttributeValue;
  AttributeValueBulkDelete: AttributeValueBulkDelete;
  AttributeValueCountableConnection: AttributeValueCountableConnection;
  AttributeValueCountableEdge: AttributeValueCountableEdge;
  AttributeValueCreate: AttributeValueCreate;
  AttributeValueCreateInput: AttributeValueCreateInput;
  AttributeValueDelete: AttributeValueDelete;
  AttributeValueFilterInput: AttributeValueFilterInput;
  AttributeValueInput: AttributeValueInput;
  AttributeValueTranslatableContent: AttributeValueTranslatableContent;
  AttributeValueTranslate: AttributeValueTranslate;
  AttributeValueTranslation: AttributeValueTranslation;
  AttributeValueTranslationInput: AttributeValueTranslationInput;
  AttributeValueUpdate: AttributeValueUpdate;
  AttributeValueUpdateInput: AttributeValueUpdateInput;
  Boolean: Scalars['Boolean'];
  BulkAttributeValueInput: BulkAttributeValueInput;
  BulkProductError: BulkProductError;
  BulkStockError: BulkStockError;
  CardInput: CardInput;
  CatalogueInput: CatalogueInput;
  Category: Category;
  CategoryBulkDelete: CategoryBulkDelete;
  CategoryCountableConnection: CategoryCountableConnection;
  CategoryCountableEdge: CategoryCountableEdge;
  CategoryCreate: CategoryCreate;
  CategoryCreated: CategoryCreated;
  CategoryDelete: CategoryDelete;
  CategoryDeleted: CategoryDeleted;
  CategoryFilterInput: CategoryFilterInput;
  CategoryInput: CategoryInput;
  CategorySortingInput: CategorySortingInput;
  CategoryTranslatableContent: CategoryTranslatableContent;
  CategoryTranslate: CategoryTranslate;
  CategoryTranslation: CategoryTranslation;
  CategoryUpdate: CategoryUpdate;
  CategoryUpdated: CategoryUpdated;
  Channel: Channel;
  ChannelActivate: ChannelActivate;
  ChannelCreate: ChannelCreate;
  ChannelCreateInput: ChannelCreateInput;
  ChannelCreated: ChannelCreated;
  ChannelDeactivate: ChannelDeactivate;
  ChannelDelete: ChannelDelete;
  ChannelDeleteInput: ChannelDeleteInput;
  ChannelDeleted: ChannelDeleted;
  ChannelError: ChannelError;
  ChannelStatusChanged: ChannelStatusChanged;
  ChannelUpdate: ChannelUpdate;
  ChannelUpdateInput: ChannelUpdateInput;
  ChannelUpdated: ChannelUpdated;
  Checkout: Omit<Checkout, 'deliveryMethod'> & { deliveryMethod?: Maybe<ResolversParentTypes['DeliveryMethod']> };
  CheckoutAddPromoCode: CheckoutAddPromoCode;
  CheckoutBillingAddressUpdate: CheckoutBillingAddressUpdate;
  CheckoutComplete: CheckoutComplete;
  CheckoutCountableConnection: CheckoutCountableConnection;
  CheckoutCountableEdge: CheckoutCountableEdge;
  CheckoutCreate: CheckoutCreate;
  CheckoutCreateInput: CheckoutCreateInput;
  CheckoutCreated: CheckoutCreated;
  CheckoutCustomerAttach: CheckoutCustomerAttach;
  CheckoutCustomerDetach: CheckoutCustomerDetach;
  CheckoutDeliveryMethodUpdate: CheckoutDeliveryMethodUpdate;
  CheckoutEmailUpdate: CheckoutEmailUpdate;
  CheckoutError: CheckoutError;
  CheckoutFilterInput: CheckoutFilterInput;
  CheckoutLanguageCodeUpdate: CheckoutLanguageCodeUpdate;
  CheckoutLine: CheckoutLine;
  CheckoutLineCountableConnection: CheckoutLineCountableConnection;
  CheckoutLineCountableEdge: CheckoutLineCountableEdge;
  CheckoutLineDelete: CheckoutLineDelete;
  CheckoutLineInput: CheckoutLineInput;
  CheckoutLineUpdateInput: CheckoutLineUpdateInput;
  CheckoutLinesAdd: CheckoutLinesAdd;
  CheckoutLinesDelete: CheckoutLinesDelete;
  CheckoutLinesUpdate: CheckoutLinesUpdate;
  CheckoutPaymentCreate: CheckoutPaymentCreate;
  CheckoutRemovePromoCode: CheckoutRemovePromoCode;
  CheckoutShippingAddressUpdate: CheckoutShippingAddressUpdate;
  CheckoutShippingMethodUpdate: CheckoutShippingMethodUpdate;
  CheckoutSortingInput: CheckoutSortingInput;
  CheckoutUpdated: CheckoutUpdated;
  ChoiceValue: ChoiceValue;
  Collection: Collection;
  CollectionAddProducts: CollectionAddProducts;
  CollectionBulkDelete: CollectionBulkDelete;
  CollectionChannelListing: CollectionChannelListing;
  CollectionChannelListingError: CollectionChannelListingError;
  CollectionChannelListingUpdate: CollectionChannelListingUpdate;
  CollectionChannelListingUpdateInput: CollectionChannelListingUpdateInput;
  CollectionCountableConnection: CollectionCountableConnection;
  CollectionCountableEdge: CollectionCountableEdge;
  CollectionCreate: CollectionCreate;
  CollectionCreateInput: CollectionCreateInput;
  CollectionCreated: CollectionCreated;
  CollectionDelete: CollectionDelete;
  CollectionDeleted: CollectionDeleted;
  CollectionError: CollectionError;
  CollectionFilterInput: CollectionFilterInput;
  CollectionInput: CollectionInput;
  CollectionRemoveProducts: CollectionRemoveProducts;
  CollectionReorderProducts: CollectionReorderProducts;
  CollectionSortingInput: CollectionSortingInput;
  CollectionTranslatableContent: CollectionTranslatableContent;
  CollectionTranslate: CollectionTranslate;
  CollectionTranslation: CollectionTranslation;
  CollectionUpdate: CollectionUpdate;
  CollectionUpdated: CollectionUpdated;
  ConfigurationItem: ConfigurationItem;
  ConfigurationItemInput: ConfigurationItemInput;
  ConfirmAccount: ConfirmAccount;
  ConfirmEmailChange: ConfirmEmailChange;
  CountryDisplay: CountryDisplay;
  CountryFilterInput: CountryFilterInput;
  CreateToken: CreateToken;
  CreditCard: CreditCard;
  CustomerBulkDelete: CustomerBulkDelete;
  CustomerCreate: CustomerCreate;
  CustomerCreated: CustomerCreated;
  CustomerDelete: CustomerDelete;
  CustomerEvent: CustomerEvent;
  CustomerFilterInput: CustomerFilterInput;
  CustomerInput: CustomerInput;
  CustomerUpdate: CustomerUpdate;
  CustomerUpdated: CustomerUpdated;
  Date: Scalars['Date'];
  DateRangeInput: DateRangeInput;
  DateTime: Scalars['DateTime'];
  DateTimeRangeInput: DateTimeRangeInput;
  DeactivateAllUserTokens: DeactivateAllUserTokens;
  DeleteMetadata: DeleteMetadata;
  DeletePrivateMetadata: DeletePrivateMetadata;
  DeliveryMethod: ResolversParentTypes['ShippingMethod'] | ResolversParentTypes['Warehouse'];
  DigitalContent: DigitalContent;
  DigitalContentCountableConnection: DigitalContentCountableConnection;
  DigitalContentCountableEdge: DigitalContentCountableEdge;
  DigitalContentCreate: DigitalContentCreate;
  DigitalContentDelete: DigitalContentDelete;
  DigitalContentInput: DigitalContentInput;
  DigitalContentUpdate: DigitalContentUpdate;
  DigitalContentUploadInput: DigitalContentUploadInput;
  DigitalContentUrl: DigitalContentUrl;
  DigitalContentUrlCreate: DigitalContentUrlCreate;
  DigitalContentUrlCreateInput: DigitalContentUrlCreateInput;
  DiscountError: DiscountError;
  Domain: Domain;
  DraftOrderBulkDelete: DraftOrderBulkDelete;
  DraftOrderComplete: DraftOrderComplete;
  DraftOrderCreate: DraftOrderCreate;
  DraftOrderCreateInput: DraftOrderCreateInput;
  DraftOrderCreated: DraftOrderCreated;
  DraftOrderDelete: DraftOrderDelete;
  DraftOrderDeleted: DraftOrderDeleted;
  DraftOrderInput: DraftOrderInput;
  DraftOrderLinesBulkDelete: DraftOrderLinesBulkDelete;
  DraftOrderUpdate: DraftOrderUpdate;
  DraftOrderUpdated: DraftOrderUpdated;
  Event: ResolversParentTypes['CategoryCreated'] | ResolversParentTypes['CategoryDeleted'] | ResolversParentTypes['CategoryUpdated'] | ResolversParentTypes['ChannelCreated'] | ResolversParentTypes['ChannelDeleted'] | ResolversParentTypes['ChannelStatusChanged'] | ResolversParentTypes['ChannelUpdated'] | ResolversParentTypes['CheckoutCreated'] | ResolversParentTypes['CheckoutUpdated'] | ResolversParentTypes['CollectionCreated'] | ResolversParentTypes['CollectionDeleted'] | ResolversParentTypes['CollectionUpdated'] | ResolversParentTypes['CustomerCreated'] | ResolversParentTypes['CustomerUpdated'] | ResolversParentTypes['DraftOrderCreated'] | ResolversParentTypes['DraftOrderDeleted'] | ResolversParentTypes['DraftOrderUpdated'] | ResolversParentTypes['FulfillmentCanceled'] | ResolversParentTypes['FulfillmentCreated'] | ResolversParentTypes['GiftCardCreated'] | ResolversParentTypes['GiftCardDeleted'] | ResolversParentTypes['GiftCardStatusChanged'] | ResolversParentTypes['GiftCardUpdated'] | ResolversParentTypes['InvoiceDeleted'] | ResolversParentTypes['InvoiceRequested'] | ResolversParentTypes['InvoiceSent'] | ResolversParentTypes['OrderCancelled'] | ResolversParentTypes['OrderConfirmed'] | ResolversParentTypes['OrderCreated'] | ResolversParentTypes['OrderFulfilled'] | ResolversParentTypes['OrderFullyPaid'] | ResolversParentTypes['OrderUpdated'] | ResolversParentTypes['PageCreated'] | ResolversParentTypes['PageDeleted'] | ResolversParentTypes['PageUpdated'] | ResolversParentTypes['ProductCreated'] | ResolversParentTypes['ProductDeleted'] | ResolversParentTypes['ProductUpdated'] | ResolversParentTypes['ProductVariantBackInStock'] | ResolversParentTypes['ProductVariantCreated'] | ResolversParentTypes['ProductVariantDeleted'] | ResolversParentTypes['ProductVariantOutOfStock'] | ResolversParentTypes['ProductVariantUpdated'] | ResolversParentTypes['SaleCreated'] | ResolversParentTypes['SaleDeleted'] | ResolversParentTypes['SaleUpdated'] | ResolversParentTypes['ShippingPriceCreated'] | ResolversParentTypes['ShippingPriceDeleted'] | ResolversParentTypes['ShippingPriceUpdated'] | ResolversParentTypes['ShippingZoneCreated'] | ResolversParentTypes['ShippingZoneDeleted'] | ResolversParentTypes['ShippingZoneUpdated'] | ResolversParentTypes['TranslationCreated'] | ResolversParentTypes['TranslationUpdated'];
  EventDelivery: EventDelivery;
  EventDeliveryAttempt: EventDeliveryAttempt;
  EventDeliveryAttemptCountableConnection: EventDeliveryAttemptCountableConnection;
  EventDeliveryAttemptCountableEdge: EventDeliveryAttemptCountableEdge;
  EventDeliveryAttemptSortingInput: EventDeliveryAttemptSortingInput;
  EventDeliveryCountableConnection: EventDeliveryCountableConnection;
  EventDeliveryCountableEdge: EventDeliveryCountableEdge;
  EventDeliveryFilterInput: EventDeliveryFilterInput;
  EventDeliveryRetry: EventDeliveryRetry;
  EventDeliverySortingInput: EventDeliverySortingInput;
  ExportError: ExportError;
  ExportEvent: ExportEvent;
  ExportFile: ExportFile;
  ExportFileCountableConnection: ExportFileCountableConnection;
  ExportFileCountableEdge: ExportFileCountableEdge;
  ExportFileFilterInput: ExportFileFilterInput;
  ExportFileSortingInput: ExportFileSortingInput;
  ExportGiftCards: ExportGiftCards;
  ExportGiftCardsInput: ExportGiftCardsInput;
  ExportInfoInput: ExportInfoInput;
  ExportProducts: ExportProducts;
  ExportProductsInput: ExportProductsInput;
  ExternalAuthentication: ExternalAuthentication;
  ExternalAuthenticationUrl: ExternalAuthenticationUrl;
  ExternalLogout: ExternalLogout;
  ExternalNotificationError: ExternalNotificationError;
  ExternalNotificationTrigger: ExternalNotificationTrigger;
  ExternalNotificationTriggerInput: ExternalNotificationTriggerInput;
  ExternalObtainAccessTokens: ExternalObtainAccessTokens;
  ExternalRefresh: ExternalRefresh;
  ExternalVerify: ExternalVerify;
  File: File;
  FileUpload: FileUpload;
  Float: Scalars['Float'];
  Fulfillment: Fulfillment;
  FulfillmentApprove: FulfillmentApprove;
  FulfillmentCancel: FulfillmentCancel;
  FulfillmentCancelInput: FulfillmentCancelInput;
  FulfillmentCanceled: FulfillmentCanceled;
  FulfillmentCreated: FulfillmentCreated;
  FulfillmentLine: FulfillmentLine;
  FulfillmentRefundProducts: FulfillmentRefundProducts;
  FulfillmentReturnProducts: FulfillmentReturnProducts;
  FulfillmentUpdateTracking: FulfillmentUpdateTracking;
  FulfillmentUpdateTrackingInput: FulfillmentUpdateTrackingInput;
  GatewayConfigLine: GatewayConfigLine;
  GenericScalar: Scalars['GenericScalar'];
  GiftCard: GiftCard;
  GiftCardActivate: GiftCardActivate;
  GiftCardAddNote: GiftCardAddNote;
  GiftCardAddNoteInput: GiftCardAddNoteInput;
  GiftCardBulkActivate: GiftCardBulkActivate;
  GiftCardBulkCreate: GiftCardBulkCreate;
  GiftCardBulkCreateInput: GiftCardBulkCreateInput;
  GiftCardBulkDeactivate: GiftCardBulkDeactivate;
  GiftCardBulkDelete: GiftCardBulkDelete;
  GiftCardCountableConnection: GiftCardCountableConnection;
  GiftCardCountableEdge: GiftCardCountableEdge;
  GiftCardCreate: GiftCardCreate;
  GiftCardCreateInput: GiftCardCreateInput;
  GiftCardCreated: GiftCardCreated;
  GiftCardDeactivate: GiftCardDeactivate;
  GiftCardDelete: GiftCardDelete;
  GiftCardDeleted: GiftCardDeleted;
  GiftCardError: GiftCardError;
  GiftCardEvent: GiftCardEvent;
  GiftCardEventBalance: GiftCardEventBalance;
  GiftCardEventFilterInput: GiftCardEventFilterInput;
  GiftCardFilterInput: GiftCardFilterInput;
  GiftCardResend: GiftCardResend;
  GiftCardResendInput: GiftCardResendInput;
  GiftCardSettings: GiftCardSettings;
  GiftCardSettingsError: GiftCardSettingsError;
  GiftCardSettingsUpdate: GiftCardSettingsUpdate;
  GiftCardSettingsUpdateInput: GiftCardSettingsUpdateInput;
  GiftCardSortingInput: GiftCardSortingInput;
  GiftCardStatusChanged: GiftCardStatusChanged;
  GiftCardTag: GiftCardTag;
  GiftCardTagCountableConnection: GiftCardTagCountableConnection;
  GiftCardTagCountableEdge: GiftCardTagCountableEdge;
  GiftCardTagFilterInput: GiftCardTagFilterInput;
  GiftCardUpdate: GiftCardUpdate;
  GiftCardUpdateInput: GiftCardUpdateInput;
  GiftCardUpdated: GiftCardUpdated;
  Group: Group;
  GroupCountableConnection: GroupCountableConnection;
  GroupCountableEdge: GroupCountableEdge;
  ID: Scalars['ID'];
  Image: Image;
  Int: Scalars['Int'];
  IntRangeInput: IntRangeInput;
  Invoice: Invoice;
  InvoiceCreate: InvoiceCreate;
  InvoiceCreateInput: InvoiceCreateInput;
  InvoiceDelete: InvoiceDelete;
  InvoiceDeleted: InvoiceDeleted;
  InvoiceError: InvoiceError;
  InvoiceRequest: InvoiceRequest;
  InvoiceRequestDelete: InvoiceRequestDelete;
  InvoiceRequested: InvoiceRequested;
  InvoiceSendNotification: InvoiceSendNotification;
  InvoiceSent: InvoiceSent;
  InvoiceUpdate: InvoiceUpdate;
  JSONString: Scalars['JSONString'];
  Job: ResolversParentTypes['AppInstallation'] | ResolversParentTypes['ExportFile'] | ResolversParentTypes['Invoice'];
  LanguageDisplay: LanguageDisplay;
  LimitInfo: LimitInfo;
  Limits: Limits;
  Manifest: Manifest;
  Margin: Margin;
  Menu: Menu;
  MenuBulkDelete: MenuBulkDelete;
  MenuCountableConnection: MenuCountableConnection;
  MenuCountableEdge: MenuCountableEdge;
  MenuCreate: MenuCreate;
  MenuCreateInput: MenuCreateInput;
  MenuDelete: MenuDelete;
  MenuError: MenuError;
  MenuFilterInput: MenuFilterInput;
  MenuInput: MenuInput;
  MenuItem: MenuItem;
  MenuItemBulkDelete: MenuItemBulkDelete;
  MenuItemCountableConnection: MenuItemCountableConnection;
  MenuItemCountableEdge: MenuItemCountableEdge;
  MenuItemCreate: MenuItemCreate;
  MenuItemCreateInput: MenuItemCreateInput;
  MenuItemDelete: MenuItemDelete;
  MenuItemFilterInput: MenuItemFilterInput;
  MenuItemInput: MenuItemInput;
  MenuItemMove: MenuItemMove;
  MenuItemMoveInput: MenuItemMoveInput;
  MenuItemSortingInput: MenuItemSortingInput;
  MenuItemTranslatableContent: MenuItemTranslatableContent;
  MenuItemTranslate: MenuItemTranslate;
  MenuItemTranslation: MenuItemTranslation;
  MenuItemUpdate: MenuItemUpdate;
  MenuSortingInput: MenuSortingInput;
  MenuUpdate: MenuUpdate;
  Metadata: Scalars['Metadata'];
  MetadataError: MetadataError;
  MetadataFilter: MetadataFilter;
  MetadataInput: MetadataInput;
  MetadataItem: MetadataItem;
  Money: Money;
  MoneyInput: MoneyInput;
  MoneyRange: MoneyRange;
  MoveProductInput: MoveProductInput;
  Mutation: {};
  NameTranslationInput: NameTranslationInput;
  Node: ResolversParentTypes['Address'] | ResolversParentTypes['Allocation'] | ResolversParentTypes['App'] | ResolversParentTypes['AppExtension'] | ResolversParentTypes['AppInstallation'] | ResolversParentTypes['AppToken'] | ResolversParentTypes['Attribute'] | ResolversParentTypes['AttributeTranslatableContent'] | ResolversParentTypes['AttributeTranslation'] | ResolversParentTypes['AttributeValue'] | ResolversParentTypes['AttributeValueTranslatableContent'] | ResolversParentTypes['AttributeValueTranslation'] | ResolversParentTypes['Category'] | ResolversParentTypes['CategoryTranslatableContent'] | ResolversParentTypes['CategoryTranslation'] | ResolversParentTypes['Channel'] | ResolversParentTypes['Checkout'] | ResolversParentTypes['CheckoutLine'] | ResolversParentTypes['Collection'] | ResolversParentTypes['CollectionChannelListing'] | ResolversParentTypes['CollectionTranslatableContent'] | ResolversParentTypes['CollectionTranslation'] | ResolversParentTypes['CustomerEvent'] | ResolversParentTypes['DigitalContent'] | ResolversParentTypes['DigitalContentUrl'] | ResolversParentTypes['EventDelivery'] | ResolversParentTypes['EventDeliveryAttempt'] | ResolversParentTypes['ExportEvent'] | ResolversParentTypes['ExportFile'] | ResolversParentTypes['Fulfillment'] | ResolversParentTypes['FulfillmentLine'] | ResolversParentTypes['GiftCard'] | ResolversParentTypes['GiftCardEvent'] | ResolversParentTypes['GiftCardTag'] | ResolversParentTypes['Group'] | ResolversParentTypes['Invoice'] | ResolversParentTypes['Menu'] | ResolversParentTypes['MenuItem'] | ResolversParentTypes['MenuItemTranslatableContent'] | ResolversParentTypes['MenuItemTranslation'] | ResolversParentTypes['Order'] | ResolversParentTypes['OrderDiscount'] | ResolversParentTypes['OrderEvent'] | ResolversParentTypes['OrderLine'] | ResolversParentTypes['Page'] | ResolversParentTypes['PageTranslatableContent'] | ResolversParentTypes['PageTranslation'] | ResolversParentTypes['PageType'] | ResolversParentTypes['Payment'] | ResolversParentTypes['Product'] | ResolversParentTypes['ProductChannelListing'] | ResolversParentTypes['ProductMedia'] | ResolversParentTypes['ProductTranslatableContent'] | ResolversParentTypes['ProductTranslation'] | ResolversParentTypes['ProductType'] | ResolversParentTypes['ProductVariant'] | ResolversParentTypes['ProductVariantChannelListing'] | ResolversParentTypes['ProductVariantTranslatableContent'] | ResolversParentTypes['ProductVariantTranslation'] | ResolversParentTypes['Sale'] | ResolversParentTypes['SaleChannelListing'] | ResolversParentTypes['SaleTranslatableContent'] | ResolversParentTypes['SaleTranslation'] | ResolversParentTypes['ShippingMethod'] | ResolversParentTypes['ShippingMethodChannelListing'] | ResolversParentTypes['ShippingMethodPostalCodeRule'] | ResolversParentTypes['ShippingMethodTranslatableContent'] | ResolversParentTypes['ShippingMethodTranslation'] | ResolversParentTypes['ShippingMethodType'] | ResolversParentTypes['ShippingZone'] | ResolversParentTypes['ShopTranslation'] | ResolversParentTypes['StaffNotificationRecipient'] | ResolversParentTypes['Stock'] | ResolversParentTypes['Transaction'] | ResolversParentTypes['User'] | ResolversParentTypes['Voucher'] | ResolversParentTypes['VoucherChannelListing'] | ResolversParentTypes['VoucherTranslatableContent'] | ResolversParentTypes['VoucherTranslation'] | ResolversParentTypes['Warehouse'] | ResolversParentTypes['Webhook'];
  ObjectWithMetadata: ResolversParentTypes['App'] | ResolversParentTypes['Attribute'] | ResolversParentTypes['Category'] | ResolversParentTypes['Checkout'] | ResolversParentTypes['Collection'] | ResolversParentTypes['DigitalContent'] | ResolversParentTypes['Fulfillment'] | ResolversParentTypes['GiftCard'] | ResolversParentTypes['Invoice'] | ResolversParentTypes['Menu'] | ResolversParentTypes['MenuItem'] | ResolversParentTypes['Order'] | ResolversParentTypes['Page'] | ResolversParentTypes['PageType'] | ResolversParentTypes['Payment'] | ResolversParentTypes['Product'] | ResolversParentTypes['ProductType'] | ResolversParentTypes['ProductVariant'] | ResolversParentTypes['Sale'] | ResolversParentTypes['ShippingMethod'] | ResolversParentTypes['ShippingMethodType'] | ResolversParentTypes['ShippingZone'] | ResolversParentTypes['User'] | ResolversParentTypes['Voucher'] | ResolversParentTypes['Warehouse'];
  Order: Omit<Order, 'deliveryMethod'> & { deliveryMethod?: Maybe<ResolversParentTypes['DeliveryMethod']> };
  OrderAddNote: OrderAddNote;
  OrderAddNoteInput: OrderAddNoteInput;
  OrderBulkCancel: OrderBulkCancel;
  OrderCancel: OrderCancel;
  OrderCancelled: OrderCancelled;
  OrderCapture: OrderCapture;
  OrderConfirm: OrderConfirm;
  OrderConfirmed: OrderConfirmed;
  OrderCountableConnection: OrderCountableConnection;
  OrderCountableEdge: OrderCountableEdge;
  OrderCreateFromCheckout: OrderCreateFromCheckout;
  OrderCreateFromCheckoutError: OrderCreateFromCheckoutError;
  OrderCreated: OrderCreated;
  OrderDiscount: OrderDiscount;
  OrderDiscountAdd: OrderDiscountAdd;
  OrderDiscountCommonInput: OrderDiscountCommonInput;
  OrderDiscountDelete: OrderDiscountDelete;
  OrderDiscountUpdate: OrderDiscountUpdate;
  OrderDraftFilterInput: OrderDraftFilterInput;
  OrderError: OrderError;
  OrderEvent: OrderEvent;
  OrderEventCountableConnection: OrderEventCountableConnection;
  OrderEventCountableEdge: OrderEventCountableEdge;
  OrderEventDiscountObject: OrderEventDiscountObject;
  OrderEventOrderLineObject: OrderEventOrderLineObject;
  OrderFilterInput: OrderFilterInput;
  OrderFulfill: OrderFulfill;
  OrderFulfillInput: OrderFulfillInput;
  OrderFulfillLineInput: OrderFulfillLineInput;
  OrderFulfillStockInput: OrderFulfillStockInput;
  OrderFulfilled: OrderFulfilled;
  OrderFullyPaid: OrderFullyPaid;
  OrderLine: OrderLine;
  OrderLineCreateInput: OrderLineCreateInput;
  OrderLineDelete: OrderLineDelete;
  OrderLineDiscountRemove: OrderLineDiscountRemove;
  OrderLineDiscountUpdate: OrderLineDiscountUpdate;
  OrderLineInput: OrderLineInput;
  OrderLineUpdate: OrderLineUpdate;
  OrderLinesCreate: OrderLinesCreate;
  OrderMarkAsPaid: OrderMarkAsPaid;
  OrderRefund: OrderRefund;
  OrderRefundFulfillmentLineInput: OrderRefundFulfillmentLineInput;
  OrderRefundLineInput: OrderRefundLineInput;
  OrderRefundProductsInput: OrderRefundProductsInput;
  OrderReturnFulfillmentLineInput: OrderReturnFulfillmentLineInput;
  OrderReturnLineInput: OrderReturnLineInput;
  OrderReturnProductsInput: OrderReturnProductsInput;
  OrderSettings: OrderSettings;
  OrderSettingsError: OrderSettingsError;
  OrderSettingsUpdate: OrderSettingsUpdate;
  OrderSettingsUpdateInput: OrderSettingsUpdateInput;
  OrderSortingInput: OrderSortingInput;
  OrderUpdate: OrderUpdate;
  OrderUpdateInput: OrderUpdateInput;
  OrderUpdateShipping: OrderUpdateShipping;
  OrderUpdateShippingInput: OrderUpdateShippingInput;
  OrderUpdated: OrderUpdated;
  OrderVoid: OrderVoid;
  Page: Page;
  PageAttributeAssign: PageAttributeAssign;
  PageAttributeUnassign: PageAttributeUnassign;
  PageBulkDelete: PageBulkDelete;
  PageBulkPublish: PageBulkPublish;
  PageCountableConnection: PageCountableConnection;
  PageCountableEdge: PageCountableEdge;
  PageCreate: PageCreate;
  PageCreateInput: PageCreateInput;
  PageCreated: PageCreated;
  PageDelete: PageDelete;
  PageDeleted: PageDeleted;
  PageError: PageError;
  PageFilterInput: PageFilterInput;
  PageInfo: PageInfo;
  PageInput: PageInput;
  PageReorderAttributeValues: PageReorderAttributeValues;
  PageSortingInput: PageSortingInput;
  PageTranslatableContent: PageTranslatableContent;
  PageTranslate: PageTranslate;
  PageTranslation: PageTranslation;
  PageTranslationInput: PageTranslationInput;
  PageType: PageType;
  PageTypeBulkDelete: PageTypeBulkDelete;
  PageTypeCountableConnection: PageTypeCountableConnection;
  PageTypeCountableEdge: PageTypeCountableEdge;
  PageTypeCreate: PageTypeCreate;
  PageTypeCreateInput: PageTypeCreateInput;
  PageTypeDelete: PageTypeDelete;
  PageTypeFilterInput: PageTypeFilterInput;
  PageTypeReorderAttributes: PageTypeReorderAttributes;
  PageTypeSortingInput: PageTypeSortingInput;
  PageTypeUpdate: PageTypeUpdate;
  PageTypeUpdateInput: PageTypeUpdateInput;
  PageUpdate: PageUpdate;
  PageUpdated: PageUpdated;
  PasswordChange: PasswordChange;
  Payment: Payment;
  PaymentCapture: PaymentCapture;
  PaymentCheckBalance: PaymentCheckBalance;
  PaymentCheckBalanceInput: PaymentCheckBalanceInput;
  PaymentCountableConnection: PaymentCountableConnection;
  PaymentCountableEdge: PaymentCountableEdge;
  PaymentError: PaymentError;
  PaymentFilterInput: PaymentFilterInput;
  PaymentGateway: PaymentGateway;
  PaymentInitialize: PaymentInitialize;
  PaymentInitialized: PaymentInitialized;
  PaymentInput: PaymentInput;
  PaymentRefund: PaymentRefund;
  PaymentSource: PaymentSource;
  PaymentVoid: PaymentVoid;
  Permission: Permission;
  PermissionGroupCreate: PermissionGroupCreate;
  PermissionGroupCreateInput: PermissionGroupCreateInput;
  PermissionGroupDelete: PermissionGroupDelete;
  PermissionGroupError: PermissionGroupError;
  PermissionGroupFilterInput: PermissionGroupFilterInput;
  PermissionGroupSortingInput: PermissionGroupSortingInput;
  PermissionGroupUpdate: PermissionGroupUpdate;
  PermissionGroupUpdateInput: PermissionGroupUpdateInput;
  Plugin: Plugin;
  PluginConfiguration: PluginConfiguration;
  PluginCountableConnection: PluginCountableConnection;
  PluginCountableEdge: PluginCountableEdge;
  PluginError: PluginError;
  PluginFilterInput: PluginFilterInput;
  PluginSortingInput: PluginSortingInput;
  PluginStatusInChannelsInput: PluginStatusInChannelsInput;
  PluginUpdate: PluginUpdate;
  PluginUpdateInput: PluginUpdateInput;
  PositiveDecimal: Scalars['PositiveDecimal'];
  PreorderData: PreorderData;
  PreorderSettingsInput: PreorderSettingsInput;
  PreorderThreshold: PreorderThreshold;
  PriceInput: PriceInput;
  PriceRangeInput: PriceRangeInput;
  Product: Product;
  ProductAttributeAssign: ProductAttributeAssign;
  ProductAttributeAssignInput: ProductAttributeAssignInput;
  ProductAttributeAssignmentUpdate: ProductAttributeAssignmentUpdate;
  ProductAttributeAssignmentUpdateInput: ProductAttributeAssignmentUpdateInput;
  ProductAttributeUnassign: ProductAttributeUnassign;
  ProductBulkDelete: ProductBulkDelete;
  ProductChannelListing: ProductChannelListing;
  ProductChannelListingAddInput: ProductChannelListingAddInput;
  ProductChannelListingError: ProductChannelListingError;
  ProductChannelListingUpdate: ProductChannelListingUpdate;
  ProductChannelListingUpdateInput: ProductChannelListingUpdateInput;
  ProductCountableConnection: ProductCountableConnection;
  ProductCountableEdge: ProductCountableEdge;
  ProductCreate: ProductCreate;
  ProductCreateInput: ProductCreateInput;
  ProductCreated: ProductCreated;
  ProductDelete: ProductDelete;
  ProductDeleted: ProductDeleted;
  ProductError: ProductError;
  ProductFilterInput: ProductFilterInput;
  ProductImage: ProductImage;
  ProductInput: ProductInput;
  ProductMedia: ProductMedia;
  ProductMediaBulkDelete: ProductMediaBulkDelete;
  ProductMediaCreate: ProductMediaCreate;
  ProductMediaCreateInput: ProductMediaCreateInput;
  ProductMediaDelete: ProductMediaDelete;
  ProductMediaReorder: ProductMediaReorder;
  ProductMediaUpdate: ProductMediaUpdate;
  ProductMediaUpdateInput: ProductMediaUpdateInput;
  ProductOrder: ProductOrder;
  ProductPricingInfo: ProductPricingInfo;
  ProductReorderAttributeValues: ProductReorderAttributeValues;
  ProductStockFilterInput: ProductStockFilterInput;
  ProductTranslatableContent: ProductTranslatableContent;
  ProductTranslate: ProductTranslate;
  ProductTranslation: ProductTranslation;
  ProductType: ProductType;
  ProductTypeBulkDelete: ProductTypeBulkDelete;
  ProductTypeCountableConnection: ProductTypeCountableConnection;
  ProductTypeCountableEdge: ProductTypeCountableEdge;
  ProductTypeCreate: ProductTypeCreate;
  ProductTypeDelete: ProductTypeDelete;
  ProductTypeFilterInput: ProductTypeFilterInput;
  ProductTypeInput: ProductTypeInput;
  ProductTypeReorderAttributes: ProductTypeReorderAttributes;
  ProductTypeSortingInput: ProductTypeSortingInput;
  ProductTypeUpdate: ProductTypeUpdate;
  ProductUpdate: ProductUpdate;
  ProductUpdated: ProductUpdated;
  ProductVariant: ProductVariant;
  ProductVariantBackInStock: ProductVariantBackInStock;
  ProductVariantBulkCreate: ProductVariantBulkCreate;
  ProductVariantBulkCreateInput: ProductVariantBulkCreateInput;
  ProductVariantBulkDelete: ProductVariantBulkDelete;
  ProductVariantChannelListing: ProductVariantChannelListing;
  ProductVariantChannelListingAddInput: ProductVariantChannelListingAddInput;
  ProductVariantChannelListingUpdate: ProductVariantChannelListingUpdate;
  ProductVariantCountableConnection: ProductVariantCountableConnection;
  ProductVariantCountableEdge: ProductVariantCountableEdge;
  ProductVariantCreate: ProductVariantCreate;
  ProductVariantCreateInput: ProductVariantCreateInput;
  ProductVariantCreated: ProductVariantCreated;
  ProductVariantDelete: ProductVariantDelete;
  ProductVariantDeleted: ProductVariantDeleted;
  ProductVariantFilterInput: ProductVariantFilterInput;
  ProductVariantInput: ProductVariantInput;
  ProductVariantOutOfStock: ProductVariantOutOfStock;
  ProductVariantPreorderDeactivate: ProductVariantPreorderDeactivate;
  ProductVariantReorder: ProductVariantReorder;
  ProductVariantReorderAttributeValues: ProductVariantReorderAttributeValues;
  ProductVariantSetDefault: ProductVariantSetDefault;
  ProductVariantSortingInput: ProductVariantSortingInput;
  ProductVariantStocksCreate: ProductVariantStocksCreate;
  ProductVariantStocksDelete: ProductVariantStocksDelete;
  ProductVariantStocksUpdate: ProductVariantStocksUpdate;
  ProductVariantTranslatableContent: ProductVariantTranslatableContent;
  ProductVariantTranslate: ProductVariantTranslate;
  ProductVariantTranslation: ProductVariantTranslation;
  ProductVariantUpdate: ProductVariantUpdate;
  ProductVariantUpdated: ProductVariantUpdated;
  PublishableChannelListingInput: PublishableChannelListingInput;
  Query: {};
  ReducedRate: ReducedRate;
  RefreshToken: RefreshToken;
  ReorderInput: ReorderInput;
  RequestEmailChange: RequestEmailChange;
  RequestPasswordReset: RequestPasswordReset;
  Sale: Sale;
  SaleAddCatalogues: SaleAddCatalogues;
  SaleBulkDelete: SaleBulkDelete;
  SaleChannelListing: SaleChannelListing;
  SaleChannelListingAddInput: SaleChannelListingAddInput;
  SaleChannelListingInput: SaleChannelListingInput;
  SaleChannelListingUpdate: SaleChannelListingUpdate;
  SaleCountableConnection: SaleCountableConnection;
  SaleCountableEdge: SaleCountableEdge;
  SaleCreate: SaleCreate;
  SaleCreated: SaleCreated;
  SaleDelete: SaleDelete;
  SaleDeleted: SaleDeleted;
  SaleFilterInput: SaleFilterInput;
  SaleInput: SaleInput;
  SaleRemoveCatalogues: SaleRemoveCatalogues;
  SaleSortingInput: SaleSortingInput;
  SaleTranslatableContent: SaleTranslatableContent;
  SaleTranslate: SaleTranslate;
  SaleTranslation: SaleTranslation;
  SaleUpdate: SaleUpdate;
  SaleUpdated: SaleUpdated;
  SelectedAttribute: SelectedAttribute;
  SeoInput: SeoInput;
  SetPassword: SetPassword;
  ShippingError: ShippingError;
  ShippingMethod: ShippingMethod;
  ShippingMethodChannelListing: ShippingMethodChannelListing;
  ShippingMethodChannelListingAddInput: ShippingMethodChannelListingAddInput;
  ShippingMethodChannelListingInput: ShippingMethodChannelListingInput;
  ShippingMethodChannelListingUpdate: ShippingMethodChannelListingUpdate;
  ShippingMethodPostalCodeRule: ShippingMethodPostalCodeRule;
  ShippingMethodTranslatableContent: ShippingMethodTranslatableContent;
  ShippingMethodTranslation: ShippingMethodTranslation;
  ShippingMethodType: ShippingMethodType;
  ShippingPostalCodeRulesCreateInputRange: ShippingPostalCodeRulesCreateInputRange;
  ShippingPriceBulkDelete: ShippingPriceBulkDelete;
  ShippingPriceCreate: ShippingPriceCreate;
  ShippingPriceCreated: ShippingPriceCreated;
  ShippingPriceDelete: ShippingPriceDelete;
  ShippingPriceDeleted: ShippingPriceDeleted;
  ShippingPriceExcludeProducts: ShippingPriceExcludeProducts;
  ShippingPriceExcludeProductsInput: ShippingPriceExcludeProductsInput;
  ShippingPriceInput: ShippingPriceInput;
  ShippingPriceRemoveProductFromExclude: ShippingPriceRemoveProductFromExclude;
  ShippingPriceTranslate: ShippingPriceTranslate;
  ShippingPriceTranslationInput: ShippingPriceTranslationInput;
  ShippingPriceUpdate: ShippingPriceUpdate;
  ShippingPriceUpdated: ShippingPriceUpdated;
  ShippingZone: ShippingZone;
  ShippingZoneBulkDelete: ShippingZoneBulkDelete;
  ShippingZoneCountableConnection: ShippingZoneCountableConnection;
  ShippingZoneCountableEdge: ShippingZoneCountableEdge;
  ShippingZoneCreate: ShippingZoneCreate;
  ShippingZoneCreateInput: ShippingZoneCreateInput;
  ShippingZoneCreated: ShippingZoneCreated;
  ShippingZoneDelete: ShippingZoneDelete;
  ShippingZoneDeleted: ShippingZoneDeleted;
  ShippingZoneFilterInput: ShippingZoneFilterInput;
  ShippingZoneUpdate: ShippingZoneUpdate;
  ShippingZoneUpdateInput: ShippingZoneUpdateInput;
  ShippingZoneUpdated: ShippingZoneUpdated;
  Shop: Shop;
  ShopAddressUpdate: ShopAddressUpdate;
  ShopDomainUpdate: ShopDomainUpdate;
  ShopError: ShopError;
  ShopFetchTaxRates: ShopFetchTaxRates;
  ShopSettingsInput: ShopSettingsInput;
  ShopSettingsTranslate: ShopSettingsTranslate;
  ShopSettingsTranslationInput: ShopSettingsTranslationInput;
  ShopSettingsUpdate: ShopSettingsUpdate;
  ShopTranslation: ShopTranslation;
  SiteDomainInput: SiteDomainInput;
  StaffBulkDelete: StaffBulkDelete;
  StaffCreate: StaffCreate;
  StaffCreateInput: StaffCreateInput;
  StaffDelete: StaffDelete;
  StaffError: StaffError;
  StaffNotificationRecipient: StaffNotificationRecipient;
  StaffNotificationRecipientCreate: StaffNotificationRecipientCreate;
  StaffNotificationRecipientDelete: StaffNotificationRecipientDelete;
  StaffNotificationRecipientInput: StaffNotificationRecipientInput;
  StaffNotificationRecipientUpdate: StaffNotificationRecipientUpdate;
  StaffUpdate: StaffUpdate;
  StaffUpdateInput: StaffUpdateInput;
  StaffUserInput: StaffUserInput;
  Stock: Stock;
  StockCountableConnection: StockCountableConnection;
  StockCountableEdge: StockCountableEdge;
  StockError: StockError;
  StockFilterInput: StockFilterInput;
  StockInput: StockInput;
  String: Scalars['String'];
  Subscription: {};
  TaxType: TaxType;
  TaxedMoney: TaxedMoney;
  TaxedMoneyRange: TaxedMoneyRange;
  TimePeriod: TimePeriod;
  TimePeriodInputType: TimePeriodInputType;
  Transaction: Transaction;
  TranslatableItem: ResolversParentTypes['AttributeTranslatableContent'] | ResolversParentTypes['AttributeValueTranslatableContent'] | ResolversParentTypes['CategoryTranslatableContent'] | ResolversParentTypes['CollectionTranslatableContent'] | ResolversParentTypes['MenuItemTranslatableContent'] | ResolversParentTypes['PageTranslatableContent'] | ResolversParentTypes['ProductTranslatableContent'] | ResolversParentTypes['ProductVariantTranslatableContent'] | ResolversParentTypes['SaleTranslatableContent'] | ResolversParentTypes['ShippingMethodTranslatableContent'] | ResolversParentTypes['VoucherTranslatableContent'];
  TranslatableItemConnection: TranslatableItemConnection;
  TranslatableItemEdge: Omit<TranslatableItemEdge, 'node'> & { node: ResolversParentTypes['TranslatableItem'] };
  TranslationCreated: Omit<TranslationCreated, 'translation'> & { translation?: Maybe<ResolversParentTypes['TranslationTypes']> };
  TranslationError: TranslationError;
  TranslationInput: TranslationInput;
  TranslationTypes: ResolversParentTypes['AttributeTranslation'] | ResolversParentTypes['AttributeValueTranslation'] | ResolversParentTypes['CategoryTranslation'] | ResolversParentTypes['CollectionTranslation'] | ResolversParentTypes['MenuItemTranslation'] | ResolversParentTypes['PageTranslation'] | ResolversParentTypes['ProductTranslation'] | ResolversParentTypes['ProductVariantTranslation'] | ResolversParentTypes['SaleTranslation'] | ResolversParentTypes['ShippingMethodTranslation'] | ResolversParentTypes['VoucherTranslation'];
  TranslationUpdated: Omit<TranslationUpdated, 'translation'> & { translation?: Maybe<ResolversParentTypes['TranslationTypes']> };
  UUID: Scalars['UUID'];
  UpdateInvoiceInput: UpdateInvoiceInput;
  UpdateMetadata: UpdateMetadata;
  UpdatePrivateMetadata: UpdatePrivateMetadata;
  Upload: Scalars['Upload'];
  UploadError: UploadError;
  User: User;
  UserAvatarDelete: UserAvatarDelete;
  UserAvatarUpdate: UserAvatarUpdate;
  UserBulkSetActive: UserBulkSetActive;
  UserCountableConnection: UserCountableConnection;
  UserCountableEdge: UserCountableEdge;
  UserCreateInput: UserCreateInput;
  UserPermission: UserPermission;
  UserSortingInput: UserSortingInput;
  VAT: Vat;
  VariantMediaAssign: VariantMediaAssign;
  VariantMediaUnassign: VariantMediaUnassign;
  VariantPricingInfo: VariantPricingInfo;
  VerifyToken: VerifyToken;
  Voucher: Voucher;
  VoucherAddCatalogues: VoucherAddCatalogues;
  VoucherBulkDelete: VoucherBulkDelete;
  VoucherChannelListing: VoucherChannelListing;
  VoucherChannelListingAddInput: VoucherChannelListingAddInput;
  VoucherChannelListingInput: VoucherChannelListingInput;
  VoucherChannelListingUpdate: VoucherChannelListingUpdate;
  VoucherCountableConnection: VoucherCountableConnection;
  VoucherCountableEdge: VoucherCountableEdge;
  VoucherCreate: VoucherCreate;
  VoucherDelete: VoucherDelete;
  VoucherFilterInput: VoucherFilterInput;
  VoucherInput: VoucherInput;
  VoucherRemoveCatalogues: VoucherRemoveCatalogues;
  VoucherSortingInput: VoucherSortingInput;
  VoucherTranslatableContent: VoucherTranslatableContent;
  VoucherTranslate: VoucherTranslate;
  VoucherTranslation: VoucherTranslation;
  VoucherUpdate: VoucherUpdate;
  Warehouse: Warehouse;
  WarehouseCountableConnection: WarehouseCountableConnection;
  WarehouseCountableEdge: WarehouseCountableEdge;
  WarehouseCreate: WarehouseCreate;
  WarehouseCreateInput: WarehouseCreateInput;
  WarehouseDelete: WarehouseDelete;
  WarehouseError: WarehouseError;
  WarehouseFilterInput: WarehouseFilterInput;
  WarehouseShippingZoneAssign: WarehouseShippingZoneAssign;
  WarehouseShippingZoneUnassign: WarehouseShippingZoneUnassign;
  WarehouseSortingInput: WarehouseSortingInput;
  WarehouseUpdate: WarehouseUpdate;
  WarehouseUpdateInput: WarehouseUpdateInput;
  Webhook: Webhook;
  WebhookCreate: WebhookCreate;
  WebhookCreateInput: WebhookCreateInput;
  WebhookDelete: WebhookDelete;
  WebhookError: WebhookError;
  WebhookEvent: WebhookEvent;
  WebhookEventAsync: WebhookEventAsync;
  WebhookEventSync: WebhookEventSync;
  WebhookUpdate: WebhookUpdate;
  WebhookUpdateInput: WebhookUpdateInput;
  Weight: Weight;
  WeightScalar: Scalars['WeightScalar'];
  _Any: Scalars['_Any'];
  _Entity: ResolversParentTypes['Address'] | ResolversParentTypes['App'] | ResolversParentTypes['Category'] | ResolversParentTypes['Collection'] | ResolversParentTypes['Group'] | ResolversParentTypes['PageType'] | ResolversParentTypes['Product'] | ResolversParentTypes['ProductMedia'] | ResolversParentTypes['ProductType'] | ResolversParentTypes['ProductVariant'] | ResolversParentTypes['User'];
  _Service: _Service;
};

export type AccountAddressCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountAddressCreate'] = ResolversParentTypes['AccountAddressCreate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountAddressDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountAddressDelete'] = ResolversParentTypes['AccountAddressDelete']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountAddressUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountAddressUpdate'] = ResolversParentTypes['AccountAddressUpdate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountDelete'] = ResolversParentTypes['AccountDelete']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountError'] = ResolversParentTypes['AccountError']> = {
  addressType?: Resolver<Maybe<ResolversTypes['AddressTypeEnum']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['AccountErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountRegisterResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountRegister'] = ResolversParentTypes['AccountRegister']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  requiresConfirmation?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountRequestDeletionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountRequestDeletion'] = ResolversParentTypes['AccountRequestDeletion']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountSetDefaultAddressResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountSetDefaultAddress'] = ResolversParentTypes['AccountSetDefaultAddress']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountUpdate'] = ResolversParentTypes['AccountUpdate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressResolvers<ContextType = any, ParentType extends ResolversParentTypes['Address'] = ResolversParentTypes['Address']> = {
  city?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  cityArea?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  companyName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  country?: Resolver<ResolversTypes['CountryDisplay'], ParentType, ContextType>;
  countryArea?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDefaultBillingAddress?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isDefaultShippingAddress?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  postalCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  streetAddress1?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  streetAddress2?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressCreate'] = ResolversParentTypes['AddressCreate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressDelete'] = ResolversParentTypes['AddressDelete']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressSetDefaultResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressSetDefault'] = ResolversParentTypes['AddressSetDefault']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressUpdate'] = ResolversParentTypes['AddressUpdate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AddressValidationDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['AddressValidationData'] = ResolversParentTypes['AddressValidationData']> = {
  addressFormat?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  addressLatinFormat?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  allowedFields?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  cityAreaChoices?: Resolver<Array<ResolversTypes['ChoiceValue']>, ParentType, ContextType>;
  cityAreaType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  cityChoices?: Resolver<Array<ResolversTypes['ChoiceValue']>, ParentType, ContextType>;
  cityType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  countryAreaChoices?: Resolver<Array<ResolversTypes['ChoiceValue']>, ParentType, ContextType>;
  countryAreaType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  countryCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  countryName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  postalCodeExamples?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  postalCodeMatchers?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  postalCodePrefix?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  postalCodeType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  requiredFields?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  upperFields?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllocationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Allocation'] = ResolversParentTypes['Allocation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  warehouse?: Resolver<ResolversTypes['Warehouse'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppResolvers<ContextType = any, ParentType extends ResolversParentTypes['App'] = ResolversParentTypes['App']> = {
  aboutApp?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  appUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  configurationUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  dataPrivacy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataPrivacyUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extensions?: Resolver<Array<ResolversTypes['AppExtension']>, ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AppMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<AppMetafieldsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['Permission']>>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AppPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<AppPrivateMetafieldsArgs>>;
  supportUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tokens?: Resolver<Maybe<Array<ResolversTypes['AppToken']>>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['AppTypeEnum']>, ParentType, ContextType>;
  version?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  webhooks?: Resolver<Maybe<Array<ResolversTypes['Webhook']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppActivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppActivate'] = ResolversParentTypes['AppActivate']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppCountableConnection'] = ResolversParentTypes['AppCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AppCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppCountableEdge'] = ResolversParentTypes['AppCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['App'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppCreate'] = ResolversParentTypes['AppCreate']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  authToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppDeactivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDeactivate'] = ResolversParentTypes['AppDeactivate']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDelete'] = ResolversParentTypes['AppDelete']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppDeleteFailedInstallationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppDeleteFailedInstallation'] = ResolversParentTypes['AppDeleteFailedInstallation']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  appInstallation?: Resolver<Maybe<ResolversTypes['AppInstallation']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppError'] = ResolversParentTypes['AppError']> = {
  code?: Resolver<ResolversTypes['AppErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['PermissionEnum']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppExtensionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppExtension'] = ResolversParentTypes['AppExtension']> = {
  accessToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  app?: Resolver<ResolversTypes['App'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mount?: Resolver<ResolversTypes['AppExtensionMountEnum'], ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['Permission']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['AppExtensionTargetEnum'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppExtensionCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppExtensionCountableConnection'] = ResolversParentTypes['AppExtensionCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AppExtensionCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppExtensionCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppExtensionCountableEdge'] = ResolversParentTypes['AppExtensionCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AppExtension'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppFetchManifestResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppFetchManifest'] = ResolversParentTypes['AppFetchManifest']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  manifest?: Resolver<Maybe<ResolversTypes['Manifest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppInstallResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppInstall'] = ResolversParentTypes['AppInstall']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  appInstallation?: Resolver<Maybe<ResolversTypes['AppInstallation']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppInstallationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppInstallation'] = ResolversParentTypes['AppInstallation']> = {
  appName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  manifestUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['JobStatusEnum'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppManifestExtensionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppManifestExtension'] = ResolversParentTypes['AppManifestExtension']> = {
  label?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  mount?: Resolver<ResolversTypes['AppExtensionMountEnum'], ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['Permission']>, ParentType, ContextType>;
  target?: Resolver<ResolversTypes['AppExtensionTargetEnum'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppRetryInstallResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppRetryInstall'] = ResolversParentTypes['AppRetryInstall']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  appInstallation?: Resolver<Maybe<ResolversTypes['AppInstallation']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppToken'] = ResolversParentTypes['AppToken']> = {
  authToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppTokenCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppTokenCreate'] = ResolversParentTypes['AppTokenCreate']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  appToken?: Resolver<Maybe<ResolversTypes['AppToken']>, ParentType, ContextType>;
  authToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppTokenDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppTokenDelete'] = ResolversParentTypes['AppTokenDelete']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  appToken?: Resolver<Maybe<ResolversTypes['AppToken']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppTokenVerifyResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppTokenVerify'] = ResolversParentTypes['AppTokenVerify']> = {
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  valid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AppUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AppUpdate'] = ResolversParentTypes['AppUpdate']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  appErrors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AppError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignNavigationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignNavigation'] = ResolversParentTypes['AssignNavigation']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menu?: Resolver<Maybe<ResolversTypes['Menu']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedVariantAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedVariantAttribute'] = ResolversParentTypes['AssignedVariantAttribute']> = {
  attribute?: Resolver<ResolversTypes['Attribute'], ParentType, ContextType>;
  variantSelection?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Attribute'] = ResolversParentTypes['Attribute']> = {
  availableInGrid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  choices?: Resolver<Maybe<ResolversTypes['AttributeValueCountableConnection']>, ParentType, ContextType, Partial<AttributeChoicesArgs>>;
  entityType?: Resolver<Maybe<ResolversTypes['AttributeEntityTypeEnum']>, ParentType, ContextType>;
  filterableInDashboard?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  filterableInStorefront?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  inputType?: Resolver<Maybe<ResolversTypes['AttributeInputTypeEnum']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AttributeMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<AttributeMetafieldsArgs>>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<AttributePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<AttributePrivateMetafieldsArgs>>;
  productTypes?: Resolver<ResolversTypes['ProductTypeCountableConnection'], ParentType, ContextType, Partial<AttributeProductTypesArgs>>;
  productVariantTypes?: Resolver<ResolversTypes['ProductTypeCountableConnection'], ParentType, ContextType, Partial<AttributeProductVariantTypesArgs>>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  storefrontSearchPosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['AttributeTranslation']>, ParentType, ContextType, RequireFields<AttributeTranslationArgs, 'languageCode'>>;
  type?: Resolver<Maybe<ResolversTypes['AttributeTypeEnum']>, ParentType, ContextType>;
  unit?: Resolver<Maybe<ResolversTypes['MeasurementUnitsEnum']>, ParentType, ContextType>;
  valueRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  visibleInStorefront?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  withChoices?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeBulkDelete'] = ResolversParentTypes['AttributeBulkDelete']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeCountableConnection'] = ResolversParentTypes['AttributeCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AttributeCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeCountableEdge'] = ResolversParentTypes['AttributeCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Attribute'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeCreate'] = ResolversParentTypes['AttributeCreate']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeDelete'] = ResolversParentTypes['AttributeDelete']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeError'] = ResolversParentTypes['AttributeError']> = {
  code?: Resolver<ResolversTypes['AttributeErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeReorderValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeReorderValues'] = ResolversParentTypes['AttributeReorderValues']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeTranslatableContent'] = ResolversParentTypes['AttributeTranslatableContent']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['AttributeTranslation']>, ParentType, ContextType, RequireFields<AttributeTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeTranslate'] = ResolversParentTypes['AttributeTranslate']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeTranslation'] = ResolversParentTypes['AttributeTranslation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeUpdate'] = ResolversParentTypes['AttributeUpdate']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValue'] = ResolversParentTypes['AttributeValue']> = {
  boolean?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  dateTime?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  inputType?: Resolver<Maybe<ResolversTypes['AttributeInputTypeEnum']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reference?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  richText?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  slug?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['AttributeValueTranslation']>, ParentType, ContextType, RequireFields<AttributeValueTranslationArgs, 'languageCode'>>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueBulkDelete'] = ResolversParentTypes['AttributeValueBulkDelete']> = {
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueCountableConnection'] = ResolversParentTypes['AttributeValueCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AttributeValueCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueCountableEdge'] = ResolversParentTypes['AttributeValueCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['AttributeValue'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueCreate'] = ResolversParentTypes['AttributeValueCreate']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  attributeValue?: Resolver<Maybe<ResolversTypes['AttributeValue']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueDelete'] = ResolversParentTypes['AttributeValueDelete']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  attributeValue?: Resolver<Maybe<ResolversTypes['AttributeValue']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueTranslatableContent'] = ResolversParentTypes['AttributeValueTranslatableContent']> = {
  attributeValue?: Resolver<Maybe<ResolversTypes['AttributeValue']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  richText?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['AttributeValueTranslation']>, ParentType, ContextType, RequireFields<AttributeValueTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueTranslate'] = ResolversParentTypes['AttributeValueTranslate']> = {
  attributeValue?: Resolver<Maybe<ResolversTypes['AttributeValue']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueTranslation'] = ResolversParentTypes['AttributeValueTranslation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  richText?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AttributeValueUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['AttributeValueUpdate'] = ResolversParentTypes['AttributeValueUpdate']> = {
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType>;
  attributeErrors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  attributeValue?: Resolver<Maybe<ResolversTypes['AttributeValue']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AttributeError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkProductErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkProductError'] = ResolversParentTypes['BulkProductError']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  channels?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['ProductErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  values?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  warehouses?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BulkStockErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['BulkStockError'] = ResolversParentTypes['BulkStockError']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['ProductErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  values?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Category'] = ResolversParentTypes['Category']> = {
  ancestors?: Resolver<Maybe<ResolversTypes['CategoryCountableConnection']>, ParentType, ContextType, Partial<CategoryAncestorsArgs>>;
  backgroundImage?: Resolver<Maybe<ResolversTypes['Image']>, ParentType, ContextType, Partial<CategoryBackgroundImageArgs>>;
  children?: Resolver<Maybe<ResolversTypes['CategoryCountableConnection']>, ParentType, ContextType, Partial<CategoryChildrenArgs>>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CategoryMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<CategoryMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CategoryPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<CategoryPrivateMetafieldsArgs>>;
  products?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<CategoryProductsArgs>>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['CategoryTranslation']>, ParentType, ContextType, RequireFields<CategoryTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryBulkDelete'] = ResolversParentTypes['CategoryBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCountableConnection'] = ResolversParentTypes['CategoryCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CategoryCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCountableEdge'] = ResolversParentTypes['CategoryCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Category'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCreate'] = ResolversParentTypes['CategoryCreate']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryCreated'] = ResolversParentTypes['CategoryCreated']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryDelete'] = ResolversParentTypes['CategoryDelete']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryDeleted'] = ResolversParentTypes['CategoryDeleted']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryTranslatableContent'] = ResolversParentTypes['CategoryTranslatableContent']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['CategoryTranslation']>, ParentType, ContextType, RequireFields<CategoryTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryTranslate'] = ResolversParentTypes['CategoryTranslate']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryTranslation'] = ResolversParentTypes['CategoryTranslation']> = {
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryUpdate'] = ResolversParentTypes['CategoryUpdate']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CategoryUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CategoryUpdated'] = ResolversParentTypes['CategoryUpdated']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelResolvers<ContextType = any, ParentType extends ResolversParentTypes['Channel'] = ResolversParentTypes['Channel']> = {
  currencyCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  defaultCountry?: Resolver<ResolversTypes['CountryDisplay'], ParentType, ContextType>;
  hasOrders?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelActivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelActivate'] = ResolversParentTypes['ChannelActivate']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelErrors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelCreate'] = ResolversParentTypes['ChannelCreate']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelErrors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelCreated'] = ResolversParentTypes['ChannelCreated']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelDeactivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelDeactivate'] = ResolversParentTypes['ChannelDeactivate']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelErrors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelDelete'] = ResolversParentTypes['ChannelDelete']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelErrors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelDeleted'] = ResolversParentTypes['ChannelDeleted']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelError'] = ResolversParentTypes['ChannelError']> = {
  code?: Resolver<ResolversTypes['ChannelErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingZones?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelStatusChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelStatusChanged'] = ResolversParentTypes['ChannelStatusChanged']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelUpdate'] = ResolversParentTypes['ChannelUpdate']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  channelErrors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ChannelError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChannelUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChannelUpdated'] = ResolversParentTypes['ChannelUpdated']> = {
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutResolvers<ContextType = any, ParentType extends ResolversParentTypes['Checkout'] = ResolversParentTypes['Checkout']> = {
  availableCollectionPoints?: Resolver<Array<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  availablePaymentGateways?: Resolver<Array<ResolversTypes['PaymentGateway']>, ParentType, ContextType>;
  availableShippingMethods?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  billingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  deliveryMethod?: Resolver<Maybe<ResolversTypes['DeliveryMethod']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  discountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  giftCards?: Resolver<Array<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isShippingRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  languageCode?: Resolver<ResolversTypes['LanguageCodeEnum'], ParentType, ContextType>;
  lastChange?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  lines?: Resolver<Array<ResolversTypes['CheckoutLine']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CheckoutMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<CheckoutMetafieldsArgs>>;
  note?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CheckoutPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<CheckoutPrivateMetafieldsArgs>>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  shippingMethods?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  shippingPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  stockReservationExpires?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  subtotalPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  translatedDiscountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  voucherCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutAddPromoCodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutAddPromoCode'] = ResolversParentTypes['CheckoutAddPromoCode']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutBillingAddressUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutBillingAddressUpdate'] = ResolversParentTypes['CheckoutBillingAddressUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCompleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutComplete'] = ResolversParentTypes['CheckoutComplete']> = {
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  confirmationData?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  confirmationNeeded?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutCountableConnection'] = ResolversParentTypes['CheckoutCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CheckoutCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutCountableEdge'] = ResolversParentTypes['CheckoutCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Checkout'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutCreate'] = ResolversParentTypes['CheckoutCreate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  created?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutCreated'] = ResolversParentTypes['CheckoutCreated']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCustomerAttachResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutCustomerAttach'] = ResolversParentTypes['CheckoutCustomerAttach']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutCustomerDetachResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutCustomerDetach'] = ResolversParentTypes['CheckoutCustomerDetach']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutDeliveryMethodUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutDeliveryMethodUpdate'] = ResolversParentTypes['CheckoutDeliveryMethodUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutEmailUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutEmailUpdate'] = ResolversParentTypes['CheckoutEmailUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutError'] = ResolversParentTypes['CheckoutError']> = {
  addressType?: Resolver<Maybe<ResolversTypes['AddressTypeEnum']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['CheckoutErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lines?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  variants?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLanguageCodeUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLanguageCodeUpdate'] = ResolversParentTypes['CheckoutLanguageCodeUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLineResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLine'] = ResolversParentTypes['CheckoutLine']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  requiresShipping?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  totalPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  variant?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLineCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLineCountableConnection'] = ResolversParentTypes['CheckoutLineCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CheckoutLineCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLineCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLineCountableEdge'] = ResolversParentTypes['CheckoutLineCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['CheckoutLine'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLineDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLineDelete'] = ResolversParentTypes['CheckoutLineDelete']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLinesAddResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLinesAdd'] = ResolversParentTypes['CheckoutLinesAdd']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLinesDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLinesDelete'] = ResolversParentTypes['CheckoutLinesDelete']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutLinesUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutLinesUpdate'] = ResolversParentTypes['CheckoutLinesUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutPaymentCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutPaymentCreate'] = ResolversParentTypes['CheckoutPaymentCreate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  paymentErrors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutRemovePromoCodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutRemovePromoCode'] = ResolversParentTypes['CheckoutRemovePromoCode']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutShippingAddressUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutShippingAddressUpdate'] = ResolversParentTypes['CheckoutShippingAddressUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutShippingMethodUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutShippingMethodUpdate'] = ResolversParentTypes['CheckoutShippingMethodUpdate']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutErrors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CheckoutError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CheckoutUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CheckoutUpdated'] = ResolversParentTypes['CheckoutUpdated']> = {
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ChoiceValueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ChoiceValue'] = ResolversParentTypes['ChoiceValue']> = {
  raw?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  verbose?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Collection'] = ResolversParentTypes['Collection']> = {
  backgroundImage?: Resolver<Maybe<ResolversTypes['Image']>, ParentType, ContextType, Partial<CollectionBackgroundImageArgs>>;
  channel?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channelListings?: Resolver<Maybe<Array<ResolversTypes['CollectionChannelListing']>>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CollectionMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<CollectionMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<CollectionPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<CollectionPrivateMetafieldsArgs>>;
  products?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<CollectionProductsArgs>>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['CollectionTranslation']>, ParentType, ContextType, RequireFields<CollectionTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionAddProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionAddProducts'] = ResolversParentTypes['CollectionAddProducts']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionBulkDelete'] = ResolversParentTypes['CollectionBulkDelete']> = {
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionChannelListingResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionChannelListing'] = ResolversParentTypes['CollectionChannelListing']> = {
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  publicationDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionChannelListingErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionChannelListingError'] = ResolversParentTypes['CollectionChannelListingError']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  channels?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['ProductErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  values?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionChannelListingUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionChannelListingUpdate'] = ResolversParentTypes['CollectionChannelListingUpdate']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionChannelListingErrors?: Resolver<Array<ResolversTypes['CollectionChannelListingError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionChannelListingError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionCountableConnection'] = ResolversParentTypes['CollectionCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CollectionCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionCountableEdge'] = ResolversParentTypes['CollectionCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Collection'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionCreate'] = ResolversParentTypes['CollectionCreate']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionCreated'] = ResolversParentTypes['CollectionCreated']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, Partial<CollectionCreatedCollectionArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionDelete'] = ResolversParentTypes['CollectionDelete']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionDeleted'] = ResolversParentTypes['CollectionDeleted']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, Partial<CollectionDeletedCollectionArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionError'] = ResolversParentTypes['CollectionError']> = {
  code?: Resolver<ResolversTypes['CollectionErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionRemoveProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionRemoveProducts'] = ResolversParentTypes['CollectionRemoveProducts']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionReorderProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionReorderProducts'] = ResolversParentTypes['CollectionReorderProducts']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionTranslatableContent'] = ResolversParentTypes['CollectionTranslatableContent']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['CollectionTranslation']>, ParentType, ContextType, RequireFields<CollectionTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionTranslate'] = ResolversParentTypes['CollectionTranslate']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionTranslation'] = ResolversParentTypes['CollectionTranslation']> = {
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionUpdate'] = ResolversParentTypes['CollectionUpdate']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  collectionErrors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['CollectionError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CollectionUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CollectionUpdated'] = ResolversParentTypes['CollectionUpdated']> = {
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, Partial<CollectionUpdatedCollectionArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfigurationItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConfigurationItem'] = ResolversParentTypes['ConfigurationItem']> = {
  helpText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  label?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['ConfigurationTypeFieldEnum']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfirmAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConfirmAccount'] = ResolversParentTypes['ConfirmAccount']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConfirmEmailChangeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConfirmEmailChange'] = ResolversParentTypes['ConfirmEmailChange']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountryDisplayResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountryDisplay'] = ResolversParentTypes['CountryDisplay']> = {
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  country?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  vat?: Resolver<Maybe<ResolversTypes['VAT']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateToken'] = ResolversParentTypes['CreateToken']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  csrfToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreditCardResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreditCard'] = ResolversParentTypes['CreditCard']> = {
  brand?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  expMonth?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  expYear?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  firstDigits?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastDigits?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerBulkDelete'] = ResolversParentTypes['CustomerBulkDelete']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerCreate'] = ResolversParentTypes['CustomerCreate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerCreated'] = ResolversParentTypes['CustomerCreated']> = {
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerDelete'] = ResolversParentTypes['CustomerDelete']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerEvent'] = ResolversParentTypes['CustomerEvent']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  count?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['CustomerEventsEnum']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerUpdate'] = ResolversParentTypes['CustomerUpdate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CustomerUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['CustomerUpdated'] = ResolversParentTypes['CustomerUpdated']> = {
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DateTimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DateTime'], any> {
  name: 'DateTime';
}

export type DeactivateAllUserTokensResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeactivateAllUserTokens'] = ResolversParentTypes['DeactivateAllUserTokens']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteMetadata'] = ResolversParentTypes['DeleteMetadata']> = {
  errors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ObjectWithMetadata']>, ParentType, ContextType>;
  metadataErrors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePrivateMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePrivateMetadata'] = ResolversParentTypes['DeletePrivateMetadata']> = {
  errors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ObjectWithMetadata']>, ParentType, ContextType>;
  metadataErrors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeliveryMethodResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeliveryMethod'] = ResolversParentTypes['DeliveryMethod']> = {
  __resolveType: TypeResolveFn<'ShippingMethod' | 'Warehouse', ParentType, ContextType>;
};

export type DigitalContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContent'] = ResolversParentTypes['DigitalContent']> = {
  automaticFulfillment?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  contentFile?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  maxDownloads?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<DigitalContentMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<DigitalContentMetafieldsArgs>>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<DigitalContentPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<DigitalContentPrivateMetafieldsArgs>>;
  productVariant?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  urlValidDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  urls?: Resolver<Maybe<Array<ResolversTypes['DigitalContentUrl']>>, ParentType, ContextType>;
  useDefaultSettings?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentCountableConnection'] = ResolversParentTypes['DigitalContentCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DigitalContentCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentCountableEdge'] = ResolversParentTypes['DigitalContentCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['DigitalContent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentCreate'] = ResolversParentTypes['DigitalContentCreate']> = {
  content?: Resolver<Maybe<ResolversTypes['DigitalContent']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentDelete'] = ResolversParentTypes['DigitalContentDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentUpdate'] = ResolversParentTypes['DigitalContentUpdate']> = {
  content?: Resolver<Maybe<ResolversTypes['DigitalContent']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentUrlResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentUrl'] = ResolversParentTypes['DigitalContentUrl']> = {
  content?: Resolver<ResolversTypes['DigitalContent'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  downloadNum?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['UUID'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DigitalContentUrlCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['DigitalContentUrlCreate'] = ResolversParentTypes['DigitalContentUrlCreate']> = {
  digitalContentUrl?: Resolver<Maybe<ResolversTypes['DigitalContentUrl']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DiscountErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['DiscountError'] = ResolversParentTypes['DiscountError']> = {
  channels?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['DiscountErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  products?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DomainResolvers<ContextType = any, ParentType extends ResolversParentTypes['Domain'] = ResolversParentTypes['Domain']> = {
  host?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sslEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderBulkDelete'] = ResolversParentTypes['DraftOrderBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderCompleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderComplete'] = ResolversParentTypes['DraftOrderComplete']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderCreate'] = ResolversParentTypes['DraftOrderCreate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderCreated'] = ResolversParentTypes['DraftOrderCreated']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderDelete'] = ResolversParentTypes['DraftOrderDelete']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderDeleted'] = ResolversParentTypes['DraftOrderDeleted']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderLinesBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderLinesBulkDelete'] = ResolversParentTypes['DraftOrderLinesBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderUpdate'] = ResolversParentTypes['DraftOrderUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DraftOrderUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DraftOrderUpdated'] = ResolversParentTypes['DraftOrderUpdated']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventResolvers<ContextType = any, ParentType extends ResolversParentTypes['Event'] = ResolversParentTypes['Event']> = {
  __resolveType: TypeResolveFn<'CategoryCreated' | 'CategoryDeleted' | 'CategoryUpdated' | 'ChannelCreated' | 'ChannelDeleted' | 'ChannelStatusChanged' | 'ChannelUpdated' | 'CheckoutCreated' | 'CheckoutUpdated' | 'CollectionCreated' | 'CollectionDeleted' | 'CollectionUpdated' | 'CustomerCreated' | 'CustomerUpdated' | 'DraftOrderCreated' | 'DraftOrderDeleted' | 'DraftOrderUpdated' | 'FulfillmentCanceled' | 'FulfillmentCreated' | 'GiftCardCreated' | 'GiftCardDeleted' | 'GiftCardStatusChanged' | 'GiftCardUpdated' | 'InvoiceDeleted' | 'InvoiceRequested' | 'InvoiceSent' | 'OrderCancelled' | 'OrderConfirmed' | 'OrderCreated' | 'OrderFulfilled' | 'OrderFullyPaid' | 'OrderUpdated' | 'PageCreated' | 'PageDeleted' | 'PageUpdated' | 'ProductCreated' | 'ProductDeleted' | 'ProductUpdated' | 'ProductVariantBackInStock' | 'ProductVariantCreated' | 'ProductVariantDeleted' | 'ProductVariantOutOfStock' | 'ProductVariantUpdated' | 'SaleCreated' | 'SaleDeleted' | 'SaleUpdated' | 'ShippingPriceCreated' | 'ShippingPriceDeleted' | 'ShippingPriceUpdated' | 'ShippingZoneCreated' | 'ShippingZoneDeleted' | 'ShippingZoneUpdated' | 'TranslationCreated' | 'TranslationUpdated', ParentType, ContextType>;
};

export type EventDeliveryResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDelivery'] = ResolversParentTypes['EventDelivery']> = {
  attempts?: Resolver<Maybe<ResolversTypes['EventDeliveryAttemptCountableConnection']>, ParentType, ContextType, Partial<EventDeliveryAttemptsArgs>>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  eventType?: Resolver<ResolversTypes['WebhookEventTypeEnum'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  payload?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['EventDeliveryStatusEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventDeliveryAttemptResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDeliveryAttempt'] = ResolversParentTypes['EventDeliveryAttempt']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  duration?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  requestHeaders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  response?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseHeaders?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  responseStatusCode?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['EventDeliveryStatusEnum'], ParentType, ContextType>;
  taskId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventDeliveryAttemptCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDeliveryAttemptCountableConnection'] = ResolversParentTypes['EventDeliveryAttemptCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['EventDeliveryAttemptCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventDeliveryAttemptCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDeliveryAttemptCountableEdge'] = ResolversParentTypes['EventDeliveryAttemptCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EventDeliveryAttempt'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventDeliveryCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDeliveryCountableConnection'] = ResolversParentTypes['EventDeliveryCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['EventDeliveryCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventDeliveryCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDeliveryCountableEdge'] = ResolversParentTypes['EventDeliveryCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['EventDelivery'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type EventDeliveryRetryResolvers<ContextType = any, ParentType extends ResolversParentTypes['EventDeliveryRetry'] = ResolversParentTypes['EventDeliveryRetry']> = {
  delivery?: Resolver<Maybe<ResolversTypes['EventDelivery']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportError'] = ResolversParentTypes['ExportError']> = {
  code?: Resolver<ResolversTypes['ExportErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportEvent'] = ResolversParentTypes['ExportEvent']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  date?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ExportEventsEnum'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportFileResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportFile'] = ResolversParentTypes['ExportFile']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  events?: Resolver<Maybe<Array<ResolversTypes['ExportEvent']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['JobStatusEnum'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportFileCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportFileCountableConnection'] = ResolversParentTypes['ExportFileCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ExportFileCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportFileCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportFileCountableEdge'] = ResolversParentTypes['ExportFileCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ExportFile'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportGiftCardsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportGiftCards'] = ResolversParentTypes['ExportGiftCards']> = {
  errors?: Resolver<Array<ResolversTypes['ExportError']>, ParentType, ContextType>;
  exportFile?: Resolver<Maybe<ResolversTypes['ExportFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExportProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExportProducts'] = ResolversParentTypes['ExportProducts']> = {
  errors?: Resolver<Array<ResolversTypes['ExportError']>, ParentType, ContextType>;
  exportErrors?: Resolver<Array<ResolversTypes['ExportError']>, ParentType, ContextType>;
  exportFile?: Resolver<Maybe<ResolversTypes['ExportFile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalAuthenticationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalAuthentication'] = ResolversParentTypes['ExternalAuthentication']> = {
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalAuthenticationUrlResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalAuthenticationUrl'] = ResolversParentTypes['ExternalAuthenticationUrl']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  authenticationData?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalLogoutResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalLogout'] = ResolversParentTypes['ExternalLogout']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  logoutData?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalNotificationErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalNotificationError'] = ResolversParentTypes['ExternalNotificationError']> = {
  code?: Resolver<ResolversTypes['ExternalNotificationErrorCodes'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalNotificationTriggerResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalNotificationTrigger'] = ResolversParentTypes['ExternalNotificationTrigger']> = {
  errors?: Resolver<Array<ResolversTypes['ExternalNotificationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalObtainAccessTokensResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalObtainAccessTokens'] = ResolversParentTypes['ExternalObtainAccessTokens']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  csrfToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalRefreshResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalRefresh'] = ResolversParentTypes['ExternalRefresh']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  csrfToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ExternalVerifyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ExternalVerify'] = ResolversParentTypes['ExternalVerify']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  verifyData?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileResolvers<ContextType = any, ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']> = {
  contentType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileUploadResolvers<ContextType = any, ParentType extends ResolversParentTypes['FileUpload'] = ResolversParentTypes['FileUpload']> = {
  errors?: Resolver<Array<ResolversTypes['UploadError']>, ParentType, ContextType>;
  uploadErrors?: Resolver<Array<ResolversTypes['UploadError']>, ParentType, ContextType>;
  uploadedFile?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Fulfillment'] = ResolversParentTypes['Fulfillment']> = {
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  fulfillmentOrder?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lines?: Resolver<Maybe<Array<ResolversTypes['FulfillmentLine']>>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FulfillmentMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<FulfillmentMetafieldsArgs>>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<FulfillmentPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<FulfillmentPrivateMetafieldsArgs>>;
  status?: Resolver<ResolversTypes['FulfillmentStatus'], ParentType, ContextType>;
  statusDisplay?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trackingNumber?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentApproveResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentApprove'] = ResolversParentTypes['FulfillmentApprove']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  fulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentCancelResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentCancel'] = ResolversParentTypes['FulfillmentCancel']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  fulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentCanceledResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentCanceled'] = ResolversParentTypes['FulfillmentCanceled']> = {
  fulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentCreated'] = ResolversParentTypes['FulfillmentCreated']> = {
  fulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentLineResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentLine'] = ResolversParentTypes['FulfillmentLine']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentRefundProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentRefundProducts'] = ResolversParentTypes['FulfillmentRefundProducts']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  fulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentReturnProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentReturnProducts'] = ResolversParentTypes['FulfillmentReturnProducts']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  replaceFulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  replaceOrder?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  returnFulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FulfillmentUpdateTrackingResolvers<ContextType = any, ParentType extends ResolversParentTypes['FulfillmentUpdateTracking'] = ResolversParentTypes['FulfillmentUpdateTracking']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  fulfillment?: Resolver<Maybe<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GatewayConfigLineResolvers<ContextType = any, ParentType extends ResolversParentTypes['GatewayConfigLine'] = ResolversParentTypes['GatewayConfigLine']> = {
  field?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface GenericScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['GenericScalar'], any> {
  name: 'GenericScalar';
}

export type GiftCardResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCard'] = ResolversParentTypes['GiftCard']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  boughtInChannel?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  createdBy?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  createdByEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  currentBalance?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  displayCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  events?: Resolver<Array<ResolversTypes['GiftCardEvent']>, ParentType, ContextType, Partial<GiftCardEventsArgs>>;
  expiryDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  last4CodeChars?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lastUsedOn?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<GiftCardMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<GiftCardMetafieldsArgs>>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<GiftCardPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<GiftCardPrivateMetafieldsArgs>>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  startDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  tags?: Resolver<Array<ResolversTypes['GiftCardTag']>, ParentType, ContextType>;
  usedBy?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  usedByEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardActivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardActivate'] = ResolversParentTypes['GiftCardActivate']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  giftCardErrors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardAddNoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardAddNote'] = ResolversParentTypes['GiftCardAddNote']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['GiftCardEvent']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardBulkActivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardBulkActivate'] = ResolversParentTypes['GiftCardBulkActivate']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardBulkCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardBulkCreate'] = ResolversParentTypes['GiftCardBulkCreate']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCards?: Resolver<Array<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardBulkDeactivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardBulkDeactivate'] = ResolversParentTypes['GiftCardBulkDeactivate']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardBulkDelete'] = ResolversParentTypes['GiftCardBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardCountableConnection'] = ResolversParentTypes['GiftCardCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['GiftCardCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardCountableEdge'] = ResolversParentTypes['GiftCardCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['GiftCard'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardCreate'] = ResolversParentTypes['GiftCardCreate']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  giftCardErrors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardCreated'] = ResolversParentTypes['GiftCardCreated']> = {
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardDeactivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardDeactivate'] = ResolversParentTypes['GiftCardDeactivate']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  giftCardErrors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardDelete'] = ResolversParentTypes['GiftCardDelete']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  giftCardErrors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardDeleted'] = ResolversParentTypes['GiftCardDeleted']> = {
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardError'] = ResolversParentTypes['GiftCardError']> = {
  code?: Resolver<ResolversTypes['GiftCardErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardEvent'] = ResolversParentTypes['GiftCardEvent']> = {
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  balance?: Resolver<Maybe<ResolversTypes['GiftCardEventBalance']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiryDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oldExpiryDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  oldTags?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  orderId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  orderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tags?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['GiftCardEventsEnum']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardEventBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardEventBalance'] = ResolversParentTypes['GiftCardEventBalance']> = {
  currentBalance?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  initialBalance?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  oldCurrentBalance?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  oldInitialBalance?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardResendResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardResend'] = ResolversParentTypes['GiftCardResend']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardSettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardSettings'] = ResolversParentTypes['GiftCardSettings']> = {
  expiryPeriod?: Resolver<Maybe<ResolversTypes['TimePeriod']>, ParentType, ContextType>;
  expiryType?: Resolver<ResolversTypes['GiftCardSettingsExpiryTypeEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardSettingsErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardSettingsError'] = ResolversParentTypes['GiftCardSettingsError']> = {
  code?: Resolver<ResolversTypes['GiftCardSettingsErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardSettingsUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardSettingsUpdate'] = ResolversParentTypes['GiftCardSettingsUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardSettingsError']>, ParentType, ContextType>;
  giftCardSettings?: Resolver<Maybe<ResolversTypes['GiftCardSettings']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardStatusChangedResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardStatusChanged'] = ResolversParentTypes['GiftCardStatusChanged']> = {
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardTagResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardTag'] = ResolversParentTypes['GiftCardTag']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardTagCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardTagCountableConnection'] = ResolversParentTypes['GiftCardTagCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['GiftCardTagCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardTagCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardTagCountableEdge'] = ResolversParentTypes['GiftCardTagCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['GiftCardTag'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardUpdate'] = ResolversParentTypes['GiftCardUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  giftCardErrors?: Resolver<Array<ResolversTypes['GiftCardError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GiftCardUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['GiftCardUpdated'] = ResolversParentTypes['GiftCardUpdated']> = {
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['Group'] = ResolversParentTypes['Group']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['Permission']>>, ParentType, ContextType>;
  userCanManage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  users?: Resolver<Maybe<Array<ResolversTypes['User']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupCountableConnection'] = ResolversParentTypes['GroupCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['GroupCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GroupCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GroupCountableEdge'] = ResolversParentTypes['GroupCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Group'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Image'] = ResolversParentTypes['Image']> = {
  alt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Invoice'] = ResolversParentTypes['Invoice']> = {
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  externalUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<InvoiceMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<InvoiceMetafieldsArgs>>;
  number?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<InvoicePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<InvoicePrivateMetafieldsArgs>>;
  status?: Resolver<ResolversTypes['JobStatusEnum'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceCreate'] = ResolversParentTypes['InvoiceCreate']> = {
  errors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  invoiceErrors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceDelete'] = ResolversParentTypes['InvoiceDelete']> = {
  errors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  invoiceErrors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceDeleted'] = ResolversParentTypes['InvoiceDeleted']> = {
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceError'] = ResolversParentTypes['InvoiceError']> = {
  code?: Resolver<ResolversTypes['InvoiceErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceRequestResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceRequest'] = ResolversParentTypes['InvoiceRequest']> = {
  errors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  invoiceErrors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceRequestDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceRequestDelete'] = ResolversParentTypes['InvoiceRequestDelete']> = {
  errors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  invoiceErrors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceRequestedResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceRequested'] = ResolversParentTypes['InvoiceRequested']> = {
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceSendNotificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceSendNotification'] = ResolversParentTypes['InvoiceSendNotification']> = {
  errors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  invoiceErrors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceSentResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceSent'] = ResolversParentTypes['InvoiceSent']> = {
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceUpdate'] = ResolversParentTypes['InvoiceUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['Invoice']>, ParentType, ContextType>;
  invoiceErrors?: Resolver<Array<ResolversTypes['InvoiceError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonStringScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSONString'], any> {
  name: 'JSONString';
}

export type JobResolvers<ContextType = any, ParentType extends ResolversParentTypes['Job'] = ResolversParentTypes['Job']> = {
  __resolveType: TypeResolveFn<'AppInstallation' | 'ExportFile' | 'Invoice', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['JobStatusEnum'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
};

export type LanguageDisplayResolvers<ContextType = any, ParentType extends ResolversParentTypes['LanguageDisplay'] = ResolversParentTypes['LanguageDisplay']> = {
  code?: Resolver<ResolversTypes['LanguageCodeEnum'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LimitInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['LimitInfo'] = ResolversParentTypes['LimitInfo']> = {
  allowedUsage?: Resolver<ResolversTypes['Limits'], ParentType, ContextType>;
  currentUsage?: Resolver<ResolversTypes['Limits'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LimitsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Limits'] = ResolversParentTypes['Limits']> = {
  channels?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  productVariants?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  staffUsers?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  warehouses?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ManifestResolvers<ContextType = any, ParentType extends ResolversParentTypes['Manifest'] = ResolversParentTypes['Manifest']> = {
  about?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  appUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  configurationUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataPrivacy?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataPrivacyUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  extensions?: Resolver<Array<ResolversTypes['AppManifestExtension']>, ParentType, ContextType>;
  homepageUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['Permission']>>, ParentType, ContextType>;
  supportUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tokenTargetUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MarginResolvers<ContextType = any, ParentType extends ResolversParentTypes['Margin'] = ResolversParentTypes['Margin']> = {
  start?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stop?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuResolvers<ContextType = any, ParentType extends ResolversParentTypes['Menu'] = ResolversParentTypes['Menu']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  items?: Resolver<Maybe<Array<ResolversTypes['MenuItem']>>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MenuMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<MenuMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MenuPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<MenuPrivateMetafieldsArgs>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuBulkDelete'] = ResolversParentTypes['MenuBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuCountableConnection'] = ResolversParentTypes['MenuCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['MenuCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuCountableEdge'] = ResolversParentTypes['MenuCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Menu'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuCreate'] = ResolversParentTypes['MenuCreate']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menu?: Resolver<Maybe<ResolversTypes['Menu']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuDelete'] = ResolversParentTypes['MenuDelete']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menu?: Resolver<Maybe<ResolversTypes['Menu']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuError'] = ResolversParentTypes['MenuError']> = {
  code?: Resolver<ResolversTypes['MenuErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItem'] = ResolversParentTypes['MenuItem']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  children?: Resolver<Maybe<Array<ResolversTypes['MenuItem']>>, ParentType, ContextType>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  level?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  menu?: Resolver<ResolversTypes['Menu'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MenuItemMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<MenuItemMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  parent?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MenuItemPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<MenuItemPrivateMetafieldsArgs>>;
  translation?: Resolver<Maybe<ResolversTypes['MenuItemTranslation']>, ParentType, ContextType, RequireFields<MenuItemTranslationArgs, 'languageCode'>>;
  url?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemBulkDelete'] = ResolversParentTypes['MenuItemBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemCountableConnection'] = ResolversParentTypes['MenuItemCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['MenuItemCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemCountableEdge'] = ResolversParentTypes['MenuItemCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['MenuItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemCreate'] = ResolversParentTypes['MenuItemCreate']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuItem?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemDelete'] = ResolversParentTypes['MenuItemDelete']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuItem?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemMoveResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemMove'] = ResolversParentTypes['MenuItemMove']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menu?: Resolver<Maybe<ResolversTypes['Menu']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemTranslatableContent'] = ResolversParentTypes['MenuItemTranslatableContent']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  menuItem?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['MenuItemTranslation']>, ParentType, ContextType, RequireFields<MenuItemTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemTranslate'] = ResolversParentTypes['MenuItemTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  menuItem?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemTranslation'] = ResolversParentTypes['MenuItemTranslation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuItemUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuItemUpdate'] = ResolversParentTypes['MenuItemUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menuItem?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MenuUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['MenuUpdate'] = ResolversParentTypes['MenuUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  menu?: Resolver<Maybe<ResolversTypes['Menu']>, ParentType, ContextType>;
  menuErrors?: Resolver<Array<ResolversTypes['MenuError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface MetadataScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Metadata'], any> {
  name: 'Metadata';
}

export type MetadataErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['MetadataError'] = ResolversParentTypes['MetadataError']> = {
  code?: Resolver<ResolversTypes['MetadataErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MetadataItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['MetadataItem'] = ResolversParentTypes['MetadataItem']> = {
  key?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Money'] = ResolversParentTypes['Money']> = {
  amount?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MoneyRangeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MoneyRange'] = ResolversParentTypes['MoneyRange']> = {
  start?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  stop?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  accountAddressCreate?: Resolver<Maybe<ResolversTypes['AccountAddressCreate']>, ParentType, ContextType, RequireFields<MutationAccountAddressCreateArgs, 'input'>>;
  accountAddressDelete?: Resolver<Maybe<ResolversTypes['AccountAddressDelete']>, ParentType, ContextType, RequireFields<MutationAccountAddressDeleteArgs, 'id'>>;
  accountAddressUpdate?: Resolver<Maybe<ResolversTypes['AccountAddressUpdate']>, ParentType, ContextType, RequireFields<MutationAccountAddressUpdateArgs, 'id' | 'input'>>;
  accountDelete?: Resolver<Maybe<ResolversTypes['AccountDelete']>, ParentType, ContextType, RequireFields<MutationAccountDeleteArgs, 'token'>>;
  accountRegister?: Resolver<Maybe<ResolversTypes['AccountRegister']>, ParentType, ContextType, RequireFields<MutationAccountRegisterArgs, 'input'>>;
  accountRequestDeletion?: Resolver<Maybe<ResolversTypes['AccountRequestDeletion']>, ParentType, ContextType, RequireFields<MutationAccountRequestDeletionArgs, 'redirectUrl'>>;
  accountSetDefaultAddress?: Resolver<Maybe<ResolversTypes['AccountSetDefaultAddress']>, ParentType, ContextType, RequireFields<MutationAccountSetDefaultAddressArgs, 'id' | 'type'>>;
  accountUpdate?: Resolver<Maybe<ResolversTypes['AccountUpdate']>, ParentType, ContextType, RequireFields<MutationAccountUpdateArgs, 'input'>>;
  addressCreate?: Resolver<Maybe<ResolversTypes['AddressCreate']>, ParentType, ContextType, RequireFields<MutationAddressCreateArgs, 'input' | 'userId'>>;
  addressDelete?: Resolver<Maybe<ResolversTypes['AddressDelete']>, ParentType, ContextType, RequireFields<MutationAddressDeleteArgs, 'id'>>;
  addressSetDefault?: Resolver<Maybe<ResolversTypes['AddressSetDefault']>, ParentType, ContextType, RequireFields<MutationAddressSetDefaultArgs, 'addressId' | 'type' | 'userId'>>;
  addressUpdate?: Resolver<Maybe<ResolversTypes['AddressUpdate']>, ParentType, ContextType, RequireFields<MutationAddressUpdateArgs, 'id' | 'input'>>;
  appActivate?: Resolver<Maybe<ResolversTypes['AppActivate']>, ParentType, ContextType, RequireFields<MutationAppActivateArgs, 'id'>>;
  appCreate?: Resolver<Maybe<ResolversTypes['AppCreate']>, ParentType, ContextType, RequireFields<MutationAppCreateArgs, 'input'>>;
  appDeactivate?: Resolver<Maybe<ResolversTypes['AppDeactivate']>, ParentType, ContextType, RequireFields<MutationAppDeactivateArgs, 'id'>>;
  appDelete?: Resolver<Maybe<ResolversTypes['AppDelete']>, ParentType, ContextType, RequireFields<MutationAppDeleteArgs, 'id'>>;
  appDeleteFailedInstallation?: Resolver<Maybe<ResolversTypes['AppDeleteFailedInstallation']>, ParentType, ContextType, RequireFields<MutationAppDeleteFailedInstallationArgs, 'id'>>;
  appFetchManifest?: Resolver<Maybe<ResolversTypes['AppFetchManifest']>, ParentType, ContextType, RequireFields<MutationAppFetchManifestArgs, 'manifestUrl'>>;
  appInstall?: Resolver<Maybe<ResolversTypes['AppInstall']>, ParentType, ContextType, RequireFields<MutationAppInstallArgs, 'input'>>;
  appRetryInstall?: Resolver<Maybe<ResolversTypes['AppRetryInstall']>, ParentType, ContextType, RequireFields<MutationAppRetryInstallArgs, 'activateAfterInstallation' | 'id'>>;
  appTokenCreate?: Resolver<Maybe<ResolversTypes['AppTokenCreate']>, ParentType, ContextType, RequireFields<MutationAppTokenCreateArgs, 'input'>>;
  appTokenDelete?: Resolver<Maybe<ResolversTypes['AppTokenDelete']>, ParentType, ContextType, RequireFields<MutationAppTokenDeleteArgs, 'id'>>;
  appTokenVerify?: Resolver<Maybe<ResolversTypes['AppTokenVerify']>, ParentType, ContextType, RequireFields<MutationAppTokenVerifyArgs, 'token'>>;
  appUpdate?: Resolver<Maybe<ResolversTypes['AppUpdate']>, ParentType, ContextType, RequireFields<MutationAppUpdateArgs, 'id' | 'input'>>;
  assignNavigation?: Resolver<Maybe<ResolversTypes['AssignNavigation']>, ParentType, ContextType, RequireFields<MutationAssignNavigationArgs, 'navigationType'>>;
  assignWarehouseShippingZone?: Resolver<Maybe<ResolversTypes['WarehouseShippingZoneAssign']>, ParentType, ContextType, RequireFields<MutationAssignWarehouseShippingZoneArgs, 'id' | 'shippingZoneIds'>>;
  attributeBulkDelete?: Resolver<Maybe<ResolversTypes['AttributeBulkDelete']>, ParentType, ContextType, RequireFields<MutationAttributeBulkDeleteArgs, 'ids'>>;
  attributeCreate?: Resolver<Maybe<ResolversTypes['AttributeCreate']>, ParentType, ContextType, RequireFields<MutationAttributeCreateArgs, 'input'>>;
  attributeDelete?: Resolver<Maybe<ResolversTypes['AttributeDelete']>, ParentType, ContextType, RequireFields<MutationAttributeDeleteArgs, 'id'>>;
  attributeReorderValues?: Resolver<Maybe<ResolversTypes['AttributeReorderValues']>, ParentType, ContextType, RequireFields<MutationAttributeReorderValuesArgs, 'attributeId' | 'moves'>>;
  attributeTranslate?: Resolver<Maybe<ResolversTypes['AttributeTranslate']>, ParentType, ContextType, RequireFields<MutationAttributeTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  attributeUpdate?: Resolver<Maybe<ResolversTypes['AttributeUpdate']>, ParentType, ContextType, RequireFields<MutationAttributeUpdateArgs, 'id' | 'input'>>;
  attributeValueBulkDelete?: Resolver<Maybe<ResolversTypes['AttributeValueBulkDelete']>, ParentType, ContextType, RequireFields<MutationAttributeValueBulkDeleteArgs, 'ids'>>;
  attributeValueCreate?: Resolver<Maybe<ResolversTypes['AttributeValueCreate']>, ParentType, ContextType, RequireFields<MutationAttributeValueCreateArgs, 'attribute' | 'input'>>;
  attributeValueDelete?: Resolver<Maybe<ResolversTypes['AttributeValueDelete']>, ParentType, ContextType, RequireFields<MutationAttributeValueDeleteArgs, 'id'>>;
  attributeValueTranslate?: Resolver<Maybe<ResolversTypes['AttributeValueTranslate']>, ParentType, ContextType, RequireFields<MutationAttributeValueTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  attributeValueUpdate?: Resolver<Maybe<ResolversTypes['AttributeValueUpdate']>, ParentType, ContextType, RequireFields<MutationAttributeValueUpdateArgs, 'id' | 'input'>>;
  categoryBulkDelete?: Resolver<Maybe<ResolversTypes['CategoryBulkDelete']>, ParentType, ContextType, RequireFields<MutationCategoryBulkDeleteArgs, 'ids'>>;
  categoryCreate?: Resolver<Maybe<ResolversTypes['CategoryCreate']>, ParentType, ContextType, RequireFields<MutationCategoryCreateArgs, 'input'>>;
  categoryDelete?: Resolver<Maybe<ResolversTypes['CategoryDelete']>, ParentType, ContextType, RequireFields<MutationCategoryDeleteArgs, 'id'>>;
  categoryTranslate?: Resolver<Maybe<ResolversTypes['CategoryTranslate']>, ParentType, ContextType, RequireFields<MutationCategoryTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  categoryUpdate?: Resolver<Maybe<ResolversTypes['CategoryUpdate']>, ParentType, ContextType, RequireFields<MutationCategoryUpdateArgs, 'id' | 'input'>>;
  channelActivate?: Resolver<Maybe<ResolversTypes['ChannelActivate']>, ParentType, ContextType, RequireFields<MutationChannelActivateArgs, 'id'>>;
  channelCreate?: Resolver<Maybe<ResolversTypes['ChannelCreate']>, ParentType, ContextType, RequireFields<MutationChannelCreateArgs, 'input'>>;
  channelDeactivate?: Resolver<Maybe<ResolversTypes['ChannelDeactivate']>, ParentType, ContextType, RequireFields<MutationChannelDeactivateArgs, 'id'>>;
  channelDelete?: Resolver<Maybe<ResolversTypes['ChannelDelete']>, ParentType, ContextType, RequireFields<MutationChannelDeleteArgs, 'id'>>;
  channelUpdate?: Resolver<Maybe<ResolversTypes['ChannelUpdate']>, ParentType, ContextType, RequireFields<MutationChannelUpdateArgs, 'id' | 'input'>>;
  checkoutAddPromoCode?: Resolver<Maybe<ResolversTypes['CheckoutAddPromoCode']>, ParentType, ContextType, RequireFields<MutationCheckoutAddPromoCodeArgs, 'promoCode'>>;
  checkoutBillingAddressUpdate?: Resolver<Maybe<ResolversTypes['CheckoutBillingAddressUpdate']>, ParentType, ContextType, RequireFields<MutationCheckoutBillingAddressUpdateArgs, 'billingAddress'>>;
  checkoutComplete?: Resolver<Maybe<ResolversTypes['CheckoutComplete']>, ParentType, ContextType, RequireFields<MutationCheckoutCompleteArgs, 'storeSource'>>;
  checkoutCreate?: Resolver<Maybe<ResolversTypes['CheckoutCreate']>, ParentType, ContextType, RequireFields<MutationCheckoutCreateArgs, 'input'>>;
  checkoutCustomerAttach?: Resolver<Maybe<ResolversTypes['CheckoutCustomerAttach']>, ParentType, ContextType, Partial<MutationCheckoutCustomerAttachArgs>>;
  checkoutCustomerDetach?: Resolver<Maybe<ResolversTypes['CheckoutCustomerDetach']>, ParentType, ContextType, Partial<MutationCheckoutCustomerDetachArgs>>;
  checkoutDeliveryMethodUpdate?: Resolver<Maybe<ResolversTypes['CheckoutDeliveryMethodUpdate']>, ParentType, ContextType, Partial<MutationCheckoutDeliveryMethodUpdateArgs>>;
  checkoutEmailUpdate?: Resolver<Maybe<ResolversTypes['CheckoutEmailUpdate']>, ParentType, ContextType, RequireFields<MutationCheckoutEmailUpdateArgs, 'email'>>;
  checkoutLanguageCodeUpdate?: Resolver<Maybe<ResolversTypes['CheckoutLanguageCodeUpdate']>, ParentType, ContextType, RequireFields<MutationCheckoutLanguageCodeUpdateArgs, 'languageCode'>>;
  checkoutLineDelete?: Resolver<Maybe<ResolversTypes['CheckoutLineDelete']>, ParentType, ContextType, Partial<MutationCheckoutLineDeleteArgs>>;
  checkoutLinesAdd?: Resolver<Maybe<ResolversTypes['CheckoutLinesAdd']>, ParentType, ContextType, RequireFields<MutationCheckoutLinesAddArgs, 'lines'>>;
  checkoutLinesDelete?: Resolver<Maybe<ResolversTypes['CheckoutLinesDelete']>, ParentType, ContextType, RequireFields<MutationCheckoutLinesDeleteArgs, 'linesIds' | 'token'>>;
  checkoutLinesUpdate?: Resolver<Maybe<ResolversTypes['CheckoutLinesUpdate']>, ParentType, ContextType, RequireFields<MutationCheckoutLinesUpdateArgs, 'lines'>>;
  checkoutPaymentCreate?: Resolver<Maybe<ResolversTypes['CheckoutPaymentCreate']>, ParentType, ContextType, RequireFields<MutationCheckoutPaymentCreateArgs, 'input'>>;
  checkoutRemovePromoCode?: Resolver<Maybe<ResolversTypes['CheckoutRemovePromoCode']>, ParentType, ContextType, Partial<MutationCheckoutRemovePromoCodeArgs>>;
  checkoutShippingAddressUpdate?: Resolver<Maybe<ResolversTypes['CheckoutShippingAddressUpdate']>, ParentType, ContextType, RequireFields<MutationCheckoutShippingAddressUpdateArgs, 'shippingAddress'>>;
  checkoutShippingMethodUpdate?: Resolver<Maybe<ResolversTypes['CheckoutShippingMethodUpdate']>, ParentType, ContextType, RequireFields<MutationCheckoutShippingMethodUpdateArgs, 'shippingMethodId'>>;
  collectionAddProducts?: Resolver<Maybe<ResolversTypes['CollectionAddProducts']>, ParentType, ContextType, RequireFields<MutationCollectionAddProductsArgs, 'collectionId' | 'products'>>;
  collectionBulkDelete?: Resolver<Maybe<ResolversTypes['CollectionBulkDelete']>, ParentType, ContextType, RequireFields<MutationCollectionBulkDeleteArgs, 'ids'>>;
  collectionChannelListingUpdate?: Resolver<Maybe<ResolversTypes['CollectionChannelListingUpdate']>, ParentType, ContextType, RequireFields<MutationCollectionChannelListingUpdateArgs, 'id' | 'input'>>;
  collectionCreate?: Resolver<Maybe<ResolversTypes['CollectionCreate']>, ParentType, ContextType, RequireFields<MutationCollectionCreateArgs, 'input'>>;
  collectionDelete?: Resolver<Maybe<ResolversTypes['CollectionDelete']>, ParentType, ContextType, RequireFields<MutationCollectionDeleteArgs, 'id'>>;
  collectionRemoveProducts?: Resolver<Maybe<ResolversTypes['CollectionRemoveProducts']>, ParentType, ContextType, RequireFields<MutationCollectionRemoveProductsArgs, 'collectionId' | 'products'>>;
  collectionReorderProducts?: Resolver<Maybe<ResolversTypes['CollectionReorderProducts']>, ParentType, ContextType, RequireFields<MutationCollectionReorderProductsArgs, 'collectionId' | 'moves'>>;
  collectionTranslate?: Resolver<Maybe<ResolversTypes['CollectionTranslate']>, ParentType, ContextType, RequireFields<MutationCollectionTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  collectionUpdate?: Resolver<Maybe<ResolversTypes['CollectionUpdate']>, ParentType, ContextType, RequireFields<MutationCollectionUpdateArgs, 'id' | 'input'>>;
  confirmAccount?: Resolver<Maybe<ResolversTypes['ConfirmAccount']>, ParentType, ContextType, RequireFields<MutationConfirmAccountArgs, 'email' | 'token'>>;
  confirmEmailChange?: Resolver<Maybe<ResolversTypes['ConfirmEmailChange']>, ParentType, ContextType, RequireFields<MutationConfirmEmailChangeArgs, 'token'>>;
  createWarehouse?: Resolver<Maybe<ResolversTypes['WarehouseCreate']>, ParentType, ContextType, RequireFields<MutationCreateWarehouseArgs, 'input'>>;
  customerBulkDelete?: Resolver<Maybe<ResolversTypes['CustomerBulkDelete']>, ParentType, ContextType, RequireFields<MutationCustomerBulkDeleteArgs, 'ids'>>;
  customerCreate?: Resolver<Maybe<ResolversTypes['CustomerCreate']>, ParentType, ContextType, RequireFields<MutationCustomerCreateArgs, 'input'>>;
  customerDelete?: Resolver<Maybe<ResolversTypes['CustomerDelete']>, ParentType, ContextType, RequireFields<MutationCustomerDeleteArgs, 'id'>>;
  customerUpdate?: Resolver<Maybe<ResolversTypes['CustomerUpdate']>, ParentType, ContextType, RequireFields<MutationCustomerUpdateArgs, 'id' | 'input'>>;
  deleteMetadata?: Resolver<Maybe<ResolversTypes['DeleteMetadata']>, ParentType, ContextType, RequireFields<MutationDeleteMetadataArgs, 'id' | 'keys'>>;
  deletePrivateMetadata?: Resolver<Maybe<ResolversTypes['DeletePrivateMetadata']>, ParentType, ContextType, RequireFields<MutationDeletePrivateMetadataArgs, 'id' | 'keys'>>;
  deleteWarehouse?: Resolver<Maybe<ResolversTypes['WarehouseDelete']>, ParentType, ContextType, RequireFields<MutationDeleteWarehouseArgs, 'id'>>;
  digitalContentCreate?: Resolver<Maybe<ResolversTypes['DigitalContentCreate']>, ParentType, ContextType, RequireFields<MutationDigitalContentCreateArgs, 'input' | 'variantId'>>;
  digitalContentDelete?: Resolver<Maybe<ResolversTypes['DigitalContentDelete']>, ParentType, ContextType, RequireFields<MutationDigitalContentDeleteArgs, 'variantId'>>;
  digitalContentUpdate?: Resolver<Maybe<ResolversTypes['DigitalContentUpdate']>, ParentType, ContextType, RequireFields<MutationDigitalContentUpdateArgs, 'input' | 'variantId'>>;
  digitalContentUrlCreate?: Resolver<Maybe<ResolversTypes['DigitalContentUrlCreate']>, ParentType, ContextType, RequireFields<MutationDigitalContentUrlCreateArgs, 'input'>>;
  draftOrderBulkDelete?: Resolver<Maybe<ResolversTypes['DraftOrderBulkDelete']>, ParentType, ContextType, RequireFields<MutationDraftOrderBulkDeleteArgs, 'ids'>>;
  draftOrderComplete?: Resolver<Maybe<ResolversTypes['DraftOrderComplete']>, ParentType, ContextType, RequireFields<MutationDraftOrderCompleteArgs, 'id'>>;
  draftOrderCreate?: Resolver<Maybe<ResolversTypes['DraftOrderCreate']>, ParentType, ContextType, RequireFields<MutationDraftOrderCreateArgs, 'input'>>;
  draftOrderDelete?: Resolver<Maybe<ResolversTypes['DraftOrderDelete']>, ParentType, ContextType, RequireFields<MutationDraftOrderDeleteArgs, 'id'>>;
  draftOrderLinesBulkDelete?: Resolver<Maybe<ResolversTypes['DraftOrderLinesBulkDelete']>, ParentType, ContextType, RequireFields<MutationDraftOrderLinesBulkDeleteArgs, 'ids'>>;
  draftOrderUpdate?: Resolver<Maybe<ResolversTypes['DraftOrderUpdate']>, ParentType, ContextType, RequireFields<MutationDraftOrderUpdateArgs, 'id' | 'input'>>;
  eventDeliveryRetry?: Resolver<Maybe<ResolversTypes['EventDeliveryRetry']>, ParentType, ContextType, RequireFields<MutationEventDeliveryRetryArgs, 'id'>>;
  exportGiftCards?: Resolver<Maybe<ResolversTypes['ExportGiftCards']>, ParentType, ContextType, RequireFields<MutationExportGiftCardsArgs, 'input'>>;
  exportProducts?: Resolver<Maybe<ResolversTypes['ExportProducts']>, ParentType, ContextType, RequireFields<MutationExportProductsArgs, 'input'>>;
  externalAuthenticationUrl?: Resolver<Maybe<ResolversTypes['ExternalAuthenticationUrl']>, ParentType, ContextType, RequireFields<MutationExternalAuthenticationUrlArgs, 'input' | 'pluginId'>>;
  externalLogout?: Resolver<Maybe<ResolversTypes['ExternalLogout']>, ParentType, ContextType, RequireFields<MutationExternalLogoutArgs, 'input' | 'pluginId'>>;
  externalNotificationTrigger?: Resolver<Maybe<ResolversTypes['ExternalNotificationTrigger']>, ParentType, ContextType, RequireFields<MutationExternalNotificationTriggerArgs, 'channel' | 'input'>>;
  externalObtainAccessTokens?: Resolver<Maybe<ResolversTypes['ExternalObtainAccessTokens']>, ParentType, ContextType, RequireFields<MutationExternalObtainAccessTokensArgs, 'input' | 'pluginId'>>;
  externalRefresh?: Resolver<Maybe<ResolversTypes['ExternalRefresh']>, ParentType, ContextType, RequireFields<MutationExternalRefreshArgs, 'input' | 'pluginId'>>;
  externalVerify?: Resolver<Maybe<ResolversTypes['ExternalVerify']>, ParentType, ContextType, RequireFields<MutationExternalVerifyArgs, 'input' | 'pluginId'>>;
  fileUpload?: Resolver<Maybe<ResolversTypes['FileUpload']>, ParentType, ContextType, RequireFields<MutationFileUploadArgs, 'file'>>;
  giftCardActivate?: Resolver<Maybe<ResolversTypes['GiftCardActivate']>, ParentType, ContextType, RequireFields<MutationGiftCardActivateArgs, 'id'>>;
  giftCardAddNote?: Resolver<Maybe<ResolversTypes['GiftCardAddNote']>, ParentType, ContextType, RequireFields<MutationGiftCardAddNoteArgs, 'id' | 'input'>>;
  giftCardBulkActivate?: Resolver<Maybe<ResolversTypes['GiftCardBulkActivate']>, ParentType, ContextType, RequireFields<MutationGiftCardBulkActivateArgs, 'ids'>>;
  giftCardBulkCreate?: Resolver<Maybe<ResolversTypes['GiftCardBulkCreate']>, ParentType, ContextType, RequireFields<MutationGiftCardBulkCreateArgs, 'input'>>;
  giftCardBulkDeactivate?: Resolver<Maybe<ResolversTypes['GiftCardBulkDeactivate']>, ParentType, ContextType, RequireFields<MutationGiftCardBulkDeactivateArgs, 'ids'>>;
  giftCardBulkDelete?: Resolver<Maybe<ResolversTypes['GiftCardBulkDelete']>, ParentType, ContextType, RequireFields<MutationGiftCardBulkDeleteArgs, 'ids'>>;
  giftCardCreate?: Resolver<Maybe<ResolversTypes['GiftCardCreate']>, ParentType, ContextType, RequireFields<MutationGiftCardCreateArgs, 'input'>>;
  giftCardDeactivate?: Resolver<Maybe<ResolversTypes['GiftCardDeactivate']>, ParentType, ContextType, RequireFields<MutationGiftCardDeactivateArgs, 'id'>>;
  giftCardDelete?: Resolver<Maybe<ResolversTypes['GiftCardDelete']>, ParentType, ContextType, RequireFields<MutationGiftCardDeleteArgs, 'id'>>;
  giftCardResend?: Resolver<Maybe<ResolversTypes['GiftCardResend']>, ParentType, ContextType, RequireFields<MutationGiftCardResendArgs, 'input'>>;
  giftCardSettingsUpdate?: Resolver<Maybe<ResolversTypes['GiftCardSettingsUpdate']>, ParentType, ContextType, RequireFields<MutationGiftCardSettingsUpdateArgs, 'input'>>;
  giftCardUpdate?: Resolver<Maybe<ResolversTypes['GiftCardUpdate']>, ParentType, ContextType, RequireFields<MutationGiftCardUpdateArgs, 'id' | 'input'>>;
  invoiceCreate?: Resolver<Maybe<ResolversTypes['InvoiceCreate']>, ParentType, ContextType, RequireFields<MutationInvoiceCreateArgs, 'input' | 'orderId'>>;
  invoiceDelete?: Resolver<Maybe<ResolversTypes['InvoiceDelete']>, ParentType, ContextType, RequireFields<MutationInvoiceDeleteArgs, 'id'>>;
  invoiceRequest?: Resolver<Maybe<ResolversTypes['InvoiceRequest']>, ParentType, ContextType, RequireFields<MutationInvoiceRequestArgs, 'orderId'>>;
  invoiceRequestDelete?: Resolver<Maybe<ResolversTypes['InvoiceRequestDelete']>, ParentType, ContextType, RequireFields<MutationInvoiceRequestDeleteArgs, 'id'>>;
  invoiceSendNotification?: Resolver<Maybe<ResolversTypes['InvoiceSendNotification']>, ParentType, ContextType, RequireFields<MutationInvoiceSendNotificationArgs, 'id'>>;
  invoiceUpdate?: Resolver<Maybe<ResolversTypes['InvoiceUpdate']>, ParentType, ContextType, RequireFields<MutationInvoiceUpdateArgs, 'id' | 'input'>>;
  menuBulkDelete?: Resolver<Maybe<ResolversTypes['MenuBulkDelete']>, ParentType, ContextType, RequireFields<MutationMenuBulkDeleteArgs, 'ids'>>;
  menuCreate?: Resolver<Maybe<ResolversTypes['MenuCreate']>, ParentType, ContextType, RequireFields<MutationMenuCreateArgs, 'input'>>;
  menuDelete?: Resolver<Maybe<ResolversTypes['MenuDelete']>, ParentType, ContextType, RequireFields<MutationMenuDeleteArgs, 'id'>>;
  menuItemBulkDelete?: Resolver<Maybe<ResolversTypes['MenuItemBulkDelete']>, ParentType, ContextType, RequireFields<MutationMenuItemBulkDeleteArgs, 'ids'>>;
  menuItemCreate?: Resolver<Maybe<ResolversTypes['MenuItemCreate']>, ParentType, ContextType, RequireFields<MutationMenuItemCreateArgs, 'input'>>;
  menuItemDelete?: Resolver<Maybe<ResolversTypes['MenuItemDelete']>, ParentType, ContextType, RequireFields<MutationMenuItemDeleteArgs, 'id'>>;
  menuItemMove?: Resolver<Maybe<ResolversTypes['MenuItemMove']>, ParentType, ContextType, RequireFields<MutationMenuItemMoveArgs, 'menu' | 'moves'>>;
  menuItemTranslate?: Resolver<Maybe<ResolversTypes['MenuItemTranslate']>, ParentType, ContextType, RequireFields<MutationMenuItemTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  menuItemUpdate?: Resolver<Maybe<ResolversTypes['MenuItemUpdate']>, ParentType, ContextType, RequireFields<MutationMenuItemUpdateArgs, 'id' | 'input'>>;
  menuUpdate?: Resolver<Maybe<ResolversTypes['MenuUpdate']>, ParentType, ContextType, RequireFields<MutationMenuUpdateArgs, 'id' | 'input'>>;
  orderAddNote?: Resolver<Maybe<ResolversTypes['OrderAddNote']>, ParentType, ContextType, RequireFields<MutationOrderAddNoteArgs, 'input' | 'order'>>;
  orderBulkCancel?: Resolver<Maybe<ResolversTypes['OrderBulkCancel']>, ParentType, ContextType, RequireFields<MutationOrderBulkCancelArgs, 'ids'>>;
  orderCancel?: Resolver<Maybe<ResolversTypes['OrderCancel']>, ParentType, ContextType, RequireFields<MutationOrderCancelArgs, 'id'>>;
  orderCapture?: Resolver<Maybe<ResolversTypes['OrderCapture']>, ParentType, ContextType, RequireFields<MutationOrderCaptureArgs, 'amount' | 'id'>>;
  orderConfirm?: Resolver<Maybe<ResolversTypes['OrderConfirm']>, ParentType, ContextType, RequireFields<MutationOrderConfirmArgs, 'id'>>;
  orderCreateFromCheckout?: Resolver<Maybe<ResolversTypes['OrderCreateFromCheckout']>, ParentType, ContextType, RequireFields<MutationOrderCreateFromCheckoutArgs, 'id' | 'removeCheckout'>>;
  orderDiscountAdd?: Resolver<Maybe<ResolversTypes['OrderDiscountAdd']>, ParentType, ContextType, RequireFields<MutationOrderDiscountAddArgs, 'input' | 'orderId'>>;
  orderDiscountDelete?: Resolver<Maybe<ResolversTypes['OrderDiscountDelete']>, ParentType, ContextType, RequireFields<MutationOrderDiscountDeleteArgs, 'discountId'>>;
  orderDiscountUpdate?: Resolver<Maybe<ResolversTypes['OrderDiscountUpdate']>, ParentType, ContextType, RequireFields<MutationOrderDiscountUpdateArgs, 'discountId' | 'input'>>;
  orderFulfill?: Resolver<Maybe<ResolversTypes['OrderFulfill']>, ParentType, ContextType, RequireFields<MutationOrderFulfillArgs, 'input'>>;
  orderFulfillmentApprove?: Resolver<Maybe<ResolversTypes['FulfillmentApprove']>, ParentType, ContextType, RequireFields<MutationOrderFulfillmentApproveArgs, 'allowStockToBeExceeded' | 'id' | 'notifyCustomer'>>;
  orderFulfillmentCancel?: Resolver<Maybe<ResolversTypes['FulfillmentCancel']>, ParentType, ContextType, RequireFields<MutationOrderFulfillmentCancelArgs, 'id'>>;
  orderFulfillmentRefundProducts?: Resolver<Maybe<ResolversTypes['FulfillmentRefundProducts']>, ParentType, ContextType, RequireFields<MutationOrderFulfillmentRefundProductsArgs, 'input' | 'order'>>;
  orderFulfillmentReturnProducts?: Resolver<Maybe<ResolversTypes['FulfillmentReturnProducts']>, ParentType, ContextType, RequireFields<MutationOrderFulfillmentReturnProductsArgs, 'input' | 'order'>>;
  orderFulfillmentUpdateTracking?: Resolver<Maybe<ResolversTypes['FulfillmentUpdateTracking']>, ParentType, ContextType, RequireFields<MutationOrderFulfillmentUpdateTrackingArgs, 'id' | 'input'>>;
  orderLineDelete?: Resolver<Maybe<ResolversTypes['OrderLineDelete']>, ParentType, ContextType, RequireFields<MutationOrderLineDeleteArgs, 'id'>>;
  orderLineDiscountRemove?: Resolver<Maybe<ResolversTypes['OrderLineDiscountRemove']>, ParentType, ContextType, RequireFields<MutationOrderLineDiscountRemoveArgs, 'orderLineId'>>;
  orderLineDiscountUpdate?: Resolver<Maybe<ResolversTypes['OrderLineDiscountUpdate']>, ParentType, ContextType, RequireFields<MutationOrderLineDiscountUpdateArgs, 'input' | 'orderLineId'>>;
  orderLineUpdate?: Resolver<Maybe<ResolversTypes['OrderLineUpdate']>, ParentType, ContextType, RequireFields<MutationOrderLineUpdateArgs, 'id' | 'input'>>;
  orderLinesCreate?: Resolver<Maybe<ResolversTypes['OrderLinesCreate']>, ParentType, ContextType, RequireFields<MutationOrderLinesCreateArgs, 'id' | 'input'>>;
  orderMarkAsPaid?: Resolver<Maybe<ResolversTypes['OrderMarkAsPaid']>, ParentType, ContextType, RequireFields<MutationOrderMarkAsPaidArgs, 'id'>>;
  orderRefund?: Resolver<Maybe<ResolversTypes['OrderRefund']>, ParentType, ContextType, RequireFields<MutationOrderRefundArgs, 'amount' | 'id'>>;
  orderSettingsUpdate?: Resolver<Maybe<ResolversTypes['OrderSettingsUpdate']>, ParentType, ContextType, RequireFields<MutationOrderSettingsUpdateArgs, 'input'>>;
  orderUpdate?: Resolver<Maybe<ResolversTypes['OrderUpdate']>, ParentType, ContextType, RequireFields<MutationOrderUpdateArgs, 'id' | 'input'>>;
  orderUpdateShipping?: Resolver<Maybe<ResolversTypes['OrderUpdateShipping']>, ParentType, ContextType, RequireFields<MutationOrderUpdateShippingArgs, 'input' | 'order'>>;
  orderVoid?: Resolver<Maybe<ResolversTypes['OrderVoid']>, ParentType, ContextType, RequireFields<MutationOrderVoidArgs, 'id'>>;
  pageAttributeAssign?: Resolver<Maybe<ResolversTypes['PageAttributeAssign']>, ParentType, ContextType, RequireFields<MutationPageAttributeAssignArgs, 'attributeIds' | 'pageTypeId'>>;
  pageAttributeUnassign?: Resolver<Maybe<ResolversTypes['PageAttributeUnassign']>, ParentType, ContextType, RequireFields<MutationPageAttributeUnassignArgs, 'attributeIds' | 'pageTypeId'>>;
  pageBulkDelete?: Resolver<Maybe<ResolversTypes['PageBulkDelete']>, ParentType, ContextType, RequireFields<MutationPageBulkDeleteArgs, 'ids'>>;
  pageBulkPublish?: Resolver<Maybe<ResolversTypes['PageBulkPublish']>, ParentType, ContextType, RequireFields<MutationPageBulkPublishArgs, 'ids' | 'isPublished'>>;
  pageCreate?: Resolver<Maybe<ResolversTypes['PageCreate']>, ParentType, ContextType, RequireFields<MutationPageCreateArgs, 'input'>>;
  pageDelete?: Resolver<Maybe<ResolversTypes['PageDelete']>, ParentType, ContextType, RequireFields<MutationPageDeleteArgs, 'id'>>;
  pageReorderAttributeValues?: Resolver<Maybe<ResolversTypes['PageReorderAttributeValues']>, ParentType, ContextType, RequireFields<MutationPageReorderAttributeValuesArgs, 'attributeId' | 'moves' | 'pageId'>>;
  pageTranslate?: Resolver<Maybe<ResolversTypes['PageTranslate']>, ParentType, ContextType, RequireFields<MutationPageTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  pageTypeBulkDelete?: Resolver<Maybe<ResolversTypes['PageTypeBulkDelete']>, ParentType, ContextType, RequireFields<MutationPageTypeBulkDeleteArgs, 'ids'>>;
  pageTypeCreate?: Resolver<Maybe<ResolversTypes['PageTypeCreate']>, ParentType, ContextType, RequireFields<MutationPageTypeCreateArgs, 'input'>>;
  pageTypeDelete?: Resolver<Maybe<ResolversTypes['PageTypeDelete']>, ParentType, ContextType, RequireFields<MutationPageTypeDeleteArgs, 'id'>>;
  pageTypeReorderAttributes?: Resolver<Maybe<ResolversTypes['PageTypeReorderAttributes']>, ParentType, ContextType, RequireFields<MutationPageTypeReorderAttributesArgs, 'moves' | 'pageTypeId'>>;
  pageTypeUpdate?: Resolver<Maybe<ResolversTypes['PageTypeUpdate']>, ParentType, ContextType, RequireFields<MutationPageTypeUpdateArgs, 'input'>>;
  pageUpdate?: Resolver<Maybe<ResolversTypes['PageUpdate']>, ParentType, ContextType, RequireFields<MutationPageUpdateArgs, 'id' | 'input'>>;
  passwordChange?: Resolver<Maybe<ResolversTypes['PasswordChange']>, ParentType, ContextType, RequireFields<MutationPasswordChangeArgs, 'newPassword' | 'oldPassword'>>;
  paymentCapture?: Resolver<Maybe<ResolversTypes['PaymentCapture']>, ParentType, ContextType, RequireFields<MutationPaymentCaptureArgs, 'paymentId'>>;
  paymentCheckBalance?: Resolver<Maybe<ResolversTypes['PaymentCheckBalance']>, ParentType, ContextType, RequireFields<MutationPaymentCheckBalanceArgs, 'input'>>;
  paymentInitialize?: Resolver<Maybe<ResolversTypes['PaymentInitialize']>, ParentType, ContextType, RequireFields<MutationPaymentInitializeArgs, 'gateway'>>;
  paymentRefund?: Resolver<Maybe<ResolversTypes['PaymentRefund']>, ParentType, ContextType, RequireFields<MutationPaymentRefundArgs, 'paymentId'>>;
  paymentVoid?: Resolver<Maybe<ResolversTypes['PaymentVoid']>, ParentType, ContextType, RequireFields<MutationPaymentVoidArgs, 'paymentId'>>;
  permissionGroupCreate?: Resolver<Maybe<ResolversTypes['PermissionGroupCreate']>, ParentType, ContextType, RequireFields<MutationPermissionGroupCreateArgs, 'input'>>;
  permissionGroupDelete?: Resolver<Maybe<ResolversTypes['PermissionGroupDelete']>, ParentType, ContextType, RequireFields<MutationPermissionGroupDeleteArgs, 'id'>>;
  permissionGroupUpdate?: Resolver<Maybe<ResolversTypes['PermissionGroupUpdate']>, ParentType, ContextType, RequireFields<MutationPermissionGroupUpdateArgs, 'id' | 'input'>>;
  pluginUpdate?: Resolver<Maybe<ResolversTypes['PluginUpdate']>, ParentType, ContextType, RequireFields<MutationPluginUpdateArgs, 'id' | 'input'>>;
  productAttributeAssign?: Resolver<Maybe<ResolversTypes['ProductAttributeAssign']>, ParentType, ContextType, RequireFields<MutationProductAttributeAssignArgs, 'operations' | 'productTypeId'>>;
  productAttributeAssignmentUpdate?: Resolver<Maybe<ResolversTypes['ProductAttributeAssignmentUpdate']>, ParentType, ContextType, RequireFields<MutationProductAttributeAssignmentUpdateArgs, 'operations' | 'productTypeId'>>;
  productAttributeUnassign?: Resolver<Maybe<ResolversTypes['ProductAttributeUnassign']>, ParentType, ContextType, RequireFields<MutationProductAttributeUnassignArgs, 'attributeIds' | 'productTypeId'>>;
  productBulkDelete?: Resolver<Maybe<ResolversTypes['ProductBulkDelete']>, ParentType, ContextType, RequireFields<MutationProductBulkDeleteArgs, 'ids'>>;
  productChannelListingUpdate?: Resolver<Maybe<ResolversTypes['ProductChannelListingUpdate']>, ParentType, ContextType, RequireFields<MutationProductChannelListingUpdateArgs, 'id' | 'input'>>;
  productCreate?: Resolver<Maybe<ResolversTypes['ProductCreate']>, ParentType, ContextType, RequireFields<MutationProductCreateArgs, 'input'>>;
  productDelete?: Resolver<Maybe<ResolversTypes['ProductDelete']>, ParentType, ContextType, RequireFields<MutationProductDeleteArgs, 'id'>>;
  productMediaBulkDelete?: Resolver<Maybe<ResolversTypes['ProductMediaBulkDelete']>, ParentType, ContextType, RequireFields<MutationProductMediaBulkDeleteArgs, 'ids'>>;
  productMediaCreate?: Resolver<Maybe<ResolversTypes['ProductMediaCreate']>, ParentType, ContextType, RequireFields<MutationProductMediaCreateArgs, 'input'>>;
  productMediaDelete?: Resolver<Maybe<ResolversTypes['ProductMediaDelete']>, ParentType, ContextType, RequireFields<MutationProductMediaDeleteArgs, 'id'>>;
  productMediaReorder?: Resolver<Maybe<ResolversTypes['ProductMediaReorder']>, ParentType, ContextType, RequireFields<MutationProductMediaReorderArgs, 'mediaIds' | 'productId'>>;
  productMediaUpdate?: Resolver<Maybe<ResolversTypes['ProductMediaUpdate']>, ParentType, ContextType, RequireFields<MutationProductMediaUpdateArgs, 'id' | 'input'>>;
  productReorderAttributeValues?: Resolver<Maybe<ResolversTypes['ProductReorderAttributeValues']>, ParentType, ContextType, RequireFields<MutationProductReorderAttributeValuesArgs, 'attributeId' | 'moves' | 'productId'>>;
  productTranslate?: Resolver<Maybe<ResolversTypes['ProductTranslate']>, ParentType, ContextType, RequireFields<MutationProductTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  productTypeBulkDelete?: Resolver<Maybe<ResolversTypes['ProductTypeBulkDelete']>, ParentType, ContextType, RequireFields<MutationProductTypeBulkDeleteArgs, 'ids'>>;
  productTypeCreate?: Resolver<Maybe<ResolversTypes['ProductTypeCreate']>, ParentType, ContextType, RequireFields<MutationProductTypeCreateArgs, 'input'>>;
  productTypeDelete?: Resolver<Maybe<ResolversTypes['ProductTypeDelete']>, ParentType, ContextType, RequireFields<MutationProductTypeDeleteArgs, 'id'>>;
  productTypeReorderAttributes?: Resolver<Maybe<ResolversTypes['ProductTypeReorderAttributes']>, ParentType, ContextType, RequireFields<MutationProductTypeReorderAttributesArgs, 'moves' | 'productTypeId' | 'type'>>;
  productTypeUpdate?: Resolver<Maybe<ResolversTypes['ProductTypeUpdate']>, ParentType, ContextType, RequireFields<MutationProductTypeUpdateArgs, 'id' | 'input'>>;
  productUpdate?: Resolver<Maybe<ResolversTypes['ProductUpdate']>, ParentType, ContextType, RequireFields<MutationProductUpdateArgs, 'id' | 'input'>>;
  productVariantBulkCreate?: Resolver<Maybe<ResolversTypes['ProductVariantBulkCreate']>, ParentType, ContextType, RequireFields<MutationProductVariantBulkCreateArgs, 'product' | 'variants'>>;
  productVariantBulkDelete?: Resolver<Maybe<ResolversTypes['ProductVariantBulkDelete']>, ParentType, ContextType, RequireFields<MutationProductVariantBulkDeleteArgs, 'ids'>>;
  productVariantChannelListingUpdate?: Resolver<Maybe<ResolversTypes['ProductVariantChannelListingUpdate']>, ParentType, ContextType, RequireFields<MutationProductVariantChannelListingUpdateArgs, 'id' | 'input'>>;
  productVariantCreate?: Resolver<Maybe<ResolversTypes['ProductVariantCreate']>, ParentType, ContextType, RequireFields<MutationProductVariantCreateArgs, 'input'>>;
  productVariantDelete?: Resolver<Maybe<ResolversTypes['ProductVariantDelete']>, ParentType, ContextType, RequireFields<MutationProductVariantDeleteArgs, 'id'>>;
  productVariantPreorderDeactivate?: Resolver<Maybe<ResolversTypes['ProductVariantPreorderDeactivate']>, ParentType, ContextType, RequireFields<MutationProductVariantPreorderDeactivateArgs, 'id'>>;
  productVariantReorder?: Resolver<Maybe<ResolversTypes['ProductVariantReorder']>, ParentType, ContextType, RequireFields<MutationProductVariantReorderArgs, 'moves' | 'productId'>>;
  productVariantReorderAttributeValues?: Resolver<Maybe<ResolversTypes['ProductVariantReorderAttributeValues']>, ParentType, ContextType, RequireFields<MutationProductVariantReorderAttributeValuesArgs, 'attributeId' | 'moves' | 'variantId'>>;
  productVariantSetDefault?: Resolver<Maybe<ResolversTypes['ProductVariantSetDefault']>, ParentType, ContextType, RequireFields<MutationProductVariantSetDefaultArgs, 'productId' | 'variantId'>>;
  productVariantStocksCreate?: Resolver<Maybe<ResolversTypes['ProductVariantStocksCreate']>, ParentType, ContextType, RequireFields<MutationProductVariantStocksCreateArgs, 'stocks' | 'variantId'>>;
  productVariantStocksDelete?: Resolver<Maybe<ResolversTypes['ProductVariantStocksDelete']>, ParentType, ContextType, RequireFields<MutationProductVariantStocksDeleteArgs, 'variantId'>>;
  productVariantStocksUpdate?: Resolver<Maybe<ResolversTypes['ProductVariantStocksUpdate']>, ParentType, ContextType, RequireFields<MutationProductVariantStocksUpdateArgs, 'stocks' | 'variantId'>>;
  productVariantTranslate?: Resolver<Maybe<ResolversTypes['ProductVariantTranslate']>, ParentType, ContextType, RequireFields<MutationProductVariantTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  productVariantUpdate?: Resolver<Maybe<ResolversTypes['ProductVariantUpdate']>, ParentType, ContextType, RequireFields<MutationProductVariantUpdateArgs, 'id' | 'input'>>;
  requestEmailChange?: Resolver<Maybe<ResolversTypes['RequestEmailChange']>, ParentType, ContextType, RequireFields<MutationRequestEmailChangeArgs, 'newEmail' | 'password' | 'redirectUrl'>>;
  requestPasswordReset?: Resolver<Maybe<ResolversTypes['RequestPasswordReset']>, ParentType, ContextType, RequireFields<MutationRequestPasswordResetArgs, 'email' | 'redirectUrl'>>;
  saleBulkDelete?: Resolver<Maybe<ResolversTypes['SaleBulkDelete']>, ParentType, ContextType, RequireFields<MutationSaleBulkDeleteArgs, 'ids'>>;
  saleCataloguesAdd?: Resolver<Maybe<ResolversTypes['SaleAddCatalogues']>, ParentType, ContextType, RequireFields<MutationSaleCataloguesAddArgs, 'id' | 'input'>>;
  saleCataloguesRemove?: Resolver<Maybe<ResolversTypes['SaleRemoveCatalogues']>, ParentType, ContextType, RequireFields<MutationSaleCataloguesRemoveArgs, 'id' | 'input'>>;
  saleChannelListingUpdate?: Resolver<Maybe<ResolversTypes['SaleChannelListingUpdate']>, ParentType, ContextType, RequireFields<MutationSaleChannelListingUpdateArgs, 'id' | 'input'>>;
  saleCreate?: Resolver<Maybe<ResolversTypes['SaleCreate']>, ParentType, ContextType, RequireFields<MutationSaleCreateArgs, 'input'>>;
  saleDelete?: Resolver<Maybe<ResolversTypes['SaleDelete']>, ParentType, ContextType, RequireFields<MutationSaleDeleteArgs, 'id'>>;
  saleTranslate?: Resolver<Maybe<ResolversTypes['SaleTranslate']>, ParentType, ContextType, RequireFields<MutationSaleTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  saleUpdate?: Resolver<Maybe<ResolversTypes['SaleUpdate']>, ParentType, ContextType, RequireFields<MutationSaleUpdateArgs, 'id' | 'input'>>;
  setPassword?: Resolver<Maybe<ResolversTypes['SetPassword']>, ParentType, ContextType, RequireFields<MutationSetPasswordArgs, 'email' | 'password' | 'token'>>;
  shippingMethodChannelListingUpdate?: Resolver<Maybe<ResolversTypes['ShippingMethodChannelListingUpdate']>, ParentType, ContextType, RequireFields<MutationShippingMethodChannelListingUpdateArgs, 'id' | 'input'>>;
  shippingPriceBulkDelete?: Resolver<Maybe<ResolversTypes['ShippingPriceBulkDelete']>, ParentType, ContextType, RequireFields<MutationShippingPriceBulkDeleteArgs, 'ids'>>;
  shippingPriceCreate?: Resolver<Maybe<ResolversTypes['ShippingPriceCreate']>, ParentType, ContextType, RequireFields<MutationShippingPriceCreateArgs, 'input'>>;
  shippingPriceDelete?: Resolver<Maybe<ResolversTypes['ShippingPriceDelete']>, ParentType, ContextType, RequireFields<MutationShippingPriceDeleteArgs, 'id'>>;
  shippingPriceExcludeProducts?: Resolver<Maybe<ResolversTypes['ShippingPriceExcludeProducts']>, ParentType, ContextType, RequireFields<MutationShippingPriceExcludeProductsArgs, 'id' | 'input'>>;
  shippingPriceRemoveProductFromExclude?: Resolver<Maybe<ResolversTypes['ShippingPriceRemoveProductFromExclude']>, ParentType, ContextType, RequireFields<MutationShippingPriceRemoveProductFromExcludeArgs, 'id' | 'products'>>;
  shippingPriceTranslate?: Resolver<Maybe<ResolversTypes['ShippingPriceTranslate']>, ParentType, ContextType, RequireFields<MutationShippingPriceTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  shippingPriceUpdate?: Resolver<Maybe<ResolversTypes['ShippingPriceUpdate']>, ParentType, ContextType, RequireFields<MutationShippingPriceUpdateArgs, 'id' | 'input'>>;
  shippingZoneBulkDelete?: Resolver<Maybe<ResolversTypes['ShippingZoneBulkDelete']>, ParentType, ContextType, RequireFields<MutationShippingZoneBulkDeleteArgs, 'ids'>>;
  shippingZoneCreate?: Resolver<Maybe<ResolversTypes['ShippingZoneCreate']>, ParentType, ContextType, RequireFields<MutationShippingZoneCreateArgs, 'input'>>;
  shippingZoneDelete?: Resolver<Maybe<ResolversTypes['ShippingZoneDelete']>, ParentType, ContextType, RequireFields<MutationShippingZoneDeleteArgs, 'id'>>;
  shippingZoneUpdate?: Resolver<Maybe<ResolversTypes['ShippingZoneUpdate']>, ParentType, ContextType, RequireFields<MutationShippingZoneUpdateArgs, 'id' | 'input'>>;
  shopAddressUpdate?: Resolver<Maybe<ResolversTypes['ShopAddressUpdate']>, ParentType, ContextType, Partial<MutationShopAddressUpdateArgs>>;
  shopDomainUpdate?: Resolver<Maybe<ResolversTypes['ShopDomainUpdate']>, ParentType, ContextType, Partial<MutationShopDomainUpdateArgs>>;
  shopFetchTaxRates?: Resolver<Maybe<ResolversTypes['ShopFetchTaxRates']>, ParentType, ContextType>;
  shopSettingsTranslate?: Resolver<Maybe<ResolversTypes['ShopSettingsTranslate']>, ParentType, ContextType, RequireFields<MutationShopSettingsTranslateArgs, 'input' | 'languageCode'>>;
  shopSettingsUpdate?: Resolver<Maybe<ResolversTypes['ShopSettingsUpdate']>, ParentType, ContextType, RequireFields<MutationShopSettingsUpdateArgs, 'input'>>;
  staffBulkDelete?: Resolver<Maybe<ResolversTypes['StaffBulkDelete']>, ParentType, ContextType, RequireFields<MutationStaffBulkDeleteArgs, 'ids'>>;
  staffCreate?: Resolver<Maybe<ResolversTypes['StaffCreate']>, ParentType, ContextType, RequireFields<MutationStaffCreateArgs, 'input'>>;
  staffDelete?: Resolver<Maybe<ResolversTypes['StaffDelete']>, ParentType, ContextType, RequireFields<MutationStaffDeleteArgs, 'id'>>;
  staffNotificationRecipientCreate?: Resolver<Maybe<ResolversTypes['StaffNotificationRecipientCreate']>, ParentType, ContextType, RequireFields<MutationStaffNotificationRecipientCreateArgs, 'input'>>;
  staffNotificationRecipientDelete?: Resolver<Maybe<ResolversTypes['StaffNotificationRecipientDelete']>, ParentType, ContextType, RequireFields<MutationStaffNotificationRecipientDeleteArgs, 'id'>>;
  staffNotificationRecipientUpdate?: Resolver<Maybe<ResolversTypes['StaffNotificationRecipientUpdate']>, ParentType, ContextType, RequireFields<MutationStaffNotificationRecipientUpdateArgs, 'id' | 'input'>>;
  staffUpdate?: Resolver<Maybe<ResolversTypes['StaffUpdate']>, ParentType, ContextType, RequireFields<MutationStaffUpdateArgs, 'id' | 'input'>>;
  tokenCreate?: Resolver<Maybe<ResolversTypes['CreateToken']>, ParentType, ContextType, RequireFields<MutationTokenCreateArgs, 'email' | 'password'>>;
  tokenRefresh?: Resolver<Maybe<ResolversTypes['RefreshToken']>, ParentType, ContextType, Partial<MutationTokenRefreshArgs>>;
  tokenVerify?: Resolver<Maybe<ResolversTypes['VerifyToken']>, ParentType, ContextType, RequireFields<MutationTokenVerifyArgs, 'token'>>;
  tokensDeactivateAll?: Resolver<Maybe<ResolversTypes['DeactivateAllUserTokens']>, ParentType, ContextType>;
  unassignWarehouseShippingZone?: Resolver<Maybe<ResolversTypes['WarehouseShippingZoneUnassign']>, ParentType, ContextType, RequireFields<MutationUnassignWarehouseShippingZoneArgs, 'id' | 'shippingZoneIds'>>;
  updateMetadata?: Resolver<Maybe<ResolversTypes['UpdateMetadata']>, ParentType, ContextType, RequireFields<MutationUpdateMetadataArgs, 'id' | 'input'>>;
  updatePrivateMetadata?: Resolver<Maybe<ResolversTypes['UpdatePrivateMetadata']>, ParentType, ContextType, RequireFields<MutationUpdatePrivateMetadataArgs, 'id' | 'input'>>;
  updateWarehouse?: Resolver<Maybe<ResolversTypes['WarehouseUpdate']>, ParentType, ContextType, RequireFields<MutationUpdateWarehouseArgs, 'id' | 'input'>>;
  userAvatarDelete?: Resolver<Maybe<ResolversTypes['UserAvatarDelete']>, ParentType, ContextType>;
  userAvatarUpdate?: Resolver<Maybe<ResolversTypes['UserAvatarUpdate']>, ParentType, ContextType, RequireFields<MutationUserAvatarUpdateArgs, 'image'>>;
  userBulkSetActive?: Resolver<Maybe<ResolversTypes['UserBulkSetActive']>, ParentType, ContextType, RequireFields<MutationUserBulkSetActiveArgs, 'ids' | 'isActive'>>;
  variantMediaAssign?: Resolver<Maybe<ResolversTypes['VariantMediaAssign']>, ParentType, ContextType, RequireFields<MutationVariantMediaAssignArgs, 'mediaId' | 'variantId'>>;
  variantMediaUnassign?: Resolver<Maybe<ResolversTypes['VariantMediaUnassign']>, ParentType, ContextType, RequireFields<MutationVariantMediaUnassignArgs, 'mediaId' | 'variantId'>>;
  voucherBulkDelete?: Resolver<Maybe<ResolversTypes['VoucherBulkDelete']>, ParentType, ContextType, RequireFields<MutationVoucherBulkDeleteArgs, 'ids'>>;
  voucherCataloguesAdd?: Resolver<Maybe<ResolversTypes['VoucherAddCatalogues']>, ParentType, ContextType, RequireFields<MutationVoucherCataloguesAddArgs, 'id' | 'input'>>;
  voucherCataloguesRemove?: Resolver<Maybe<ResolversTypes['VoucherRemoveCatalogues']>, ParentType, ContextType, RequireFields<MutationVoucherCataloguesRemoveArgs, 'id' | 'input'>>;
  voucherChannelListingUpdate?: Resolver<Maybe<ResolversTypes['VoucherChannelListingUpdate']>, ParentType, ContextType, RequireFields<MutationVoucherChannelListingUpdateArgs, 'id' | 'input'>>;
  voucherCreate?: Resolver<Maybe<ResolversTypes['VoucherCreate']>, ParentType, ContextType, RequireFields<MutationVoucherCreateArgs, 'input'>>;
  voucherDelete?: Resolver<Maybe<ResolversTypes['VoucherDelete']>, ParentType, ContextType, RequireFields<MutationVoucherDeleteArgs, 'id'>>;
  voucherTranslate?: Resolver<Maybe<ResolversTypes['VoucherTranslate']>, ParentType, ContextType, RequireFields<MutationVoucherTranslateArgs, 'id' | 'input' | 'languageCode'>>;
  voucherUpdate?: Resolver<Maybe<ResolversTypes['VoucherUpdate']>, ParentType, ContextType, RequireFields<MutationVoucherUpdateArgs, 'id' | 'input'>>;
  webhookCreate?: Resolver<Maybe<ResolversTypes['WebhookCreate']>, ParentType, ContextType, RequireFields<MutationWebhookCreateArgs, 'input'>>;
  webhookDelete?: Resolver<Maybe<ResolversTypes['WebhookDelete']>, ParentType, ContextType, RequireFields<MutationWebhookDeleteArgs, 'id'>>;
  webhookUpdate?: Resolver<Maybe<ResolversTypes['WebhookUpdate']>, ParentType, ContextType, RequireFields<MutationWebhookUpdateArgs, 'id' | 'input'>>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'Address' | 'Allocation' | 'App' | 'AppExtension' | 'AppInstallation' | 'AppToken' | 'Attribute' | 'AttributeTranslatableContent' | 'AttributeTranslation' | 'AttributeValue' | 'AttributeValueTranslatableContent' | 'AttributeValueTranslation' | 'Category' | 'CategoryTranslatableContent' | 'CategoryTranslation' | 'Channel' | 'Checkout' | 'CheckoutLine' | 'Collection' | 'CollectionChannelListing' | 'CollectionTranslatableContent' | 'CollectionTranslation' | 'CustomerEvent' | 'DigitalContent' | 'DigitalContentUrl' | 'EventDelivery' | 'EventDeliveryAttempt' | 'ExportEvent' | 'ExportFile' | 'Fulfillment' | 'FulfillmentLine' | 'GiftCard' | 'GiftCardEvent' | 'GiftCardTag' | 'Group' | 'Invoice' | 'Menu' | 'MenuItem' | 'MenuItemTranslatableContent' | 'MenuItemTranslation' | 'Order' | 'OrderDiscount' | 'OrderEvent' | 'OrderLine' | 'Page' | 'PageTranslatableContent' | 'PageTranslation' | 'PageType' | 'Payment' | 'Product' | 'ProductChannelListing' | 'ProductMedia' | 'ProductTranslatableContent' | 'ProductTranslation' | 'ProductType' | 'ProductVariant' | 'ProductVariantChannelListing' | 'ProductVariantTranslatableContent' | 'ProductVariantTranslation' | 'Sale' | 'SaleChannelListing' | 'SaleTranslatableContent' | 'SaleTranslation' | 'ShippingMethod' | 'ShippingMethodChannelListing' | 'ShippingMethodPostalCodeRule' | 'ShippingMethodTranslatableContent' | 'ShippingMethodTranslation' | 'ShippingMethodType' | 'ShippingZone' | 'ShopTranslation' | 'StaffNotificationRecipient' | 'Stock' | 'Transaction' | 'User' | 'Voucher' | 'VoucherChannelListing' | 'VoucherTranslatableContent' | 'VoucherTranslation' | 'Warehouse' | 'Webhook', ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type ObjectWithMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['ObjectWithMetadata'] = ResolversParentTypes['ObjectWithMetadata']> = {
  __resolveType: TypeResolveFn<'App' | 'Attribute' | 'Category' | 'Checkout' | 'Collection' | 'DigitalContent' | 'Fulfillment' | 'GiftCard' | 'Invoice' | 'Menu' | 'MenuItem' | 'Order' | 'Page' | 'PageType' | 'Payment' | 'Product' | 'ProductType' | 'ProductVariant' | 'Sale' | 'ShippingMethod' | 'ShippingMethodType' | 'ShippingZone' | 'User' | 'Voucher' | 'Warehouse', ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ObjectWithMetadataMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ObjectWithMetadataMetafieldsArgs>>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ObjectWithMetadataPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ObjectWithMetadataPrivateMetafieldsArgs>>;
};

export type OrderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Order'] = ResolversParentTypes['Order']> = {
  actions?: Resolver<Array<ResolversTypes['OrderAction']>, ParentType, ContextType>;
  availableCollectionPoints?: Resolver<Array<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  availableShippingMethods?: Resolver<Maybe<Array<ResolversTypes['ShippingMethod']>>, ParentType, ContextType>;
  billingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  canFinalize?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  collectionPointName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  customerNote?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  deliveryMethod?: Resolver<Maybe<ResolversTypes['DeliveryMethod']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  discountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discounts?: Resolver<Array<ResolversTypes['OrderDiscount']>, ParentType, ContextType>;
  displayGrossPrices?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  events?: Resolver<Array<ResolversTypes['OrderEvent']>, ParentType, ContextType>;
  fulfillments?: Resolver<Array<ResolversTypes['Fulfillment']>, ParentType, ContextType>;
  giftCards?: Resolver<Array<ResolversTypes['GiftCard']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoices?: Resolver<Array<ResolversTypes['Invoice']>, ParentType, ContextType>;
  isPaid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isShippingRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  languageCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  languageCodeEnum?: Resolver<ResolversTypes['LanguageCodeEnum'], ParentType, ContextType>;
  lines?: Resolver<Array<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<OrderMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<OrderMetafieldsArgs>>;
  number?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  origin?: Resolver<ResolversTypes['OrderOriginEnum'], ParentType, ContextType>;
  original?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  paymentStatus?: Resolver<ResolversTypes['PaymentChargeStatusEnum'], ParentType, ContextType>;
  paymentStatusDisplay?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  payments?: Resolver<Array<ResolversTypes['Payment']>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<OrderPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<OrderPrivateMetafieldsArgs>>;
  redirectUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  shippingMethodName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shippingMethods?: Resolver<Array<ResolversTypes['ShippingMethod']>, ParentType, ContextType>;
  shippingPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  shippingTaxRate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['OrderStatus'], ParentType, ContextType>;
  statusDisplay?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  subtotal?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  total?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  totalAuthorized?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  totalBalance?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  totalCaptured?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  trackingClientId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translatedDiscountName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  undiscountedTotal?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  weight?: Resolver<ResolversTypes['Weight'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderAddNoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderAddNote'] = ResolversParentTypes['OrderAddNote']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  event?: Resolver<Maybe<ResolversTypes['OrderEvent']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderBulkCancelResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderBulkCancel'] = ResolversParentTypes['OrderBulkCancel']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCancelResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCancel'] = ResolversParentTypes['OrderCancel']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCancelledResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCancelled'] = ResolversParentTypes['OrderCancelled']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCaptureResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCapture'] = ResolversParentTypes['OrderCapture']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderConfirmResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderConfirm'] = ResolversParentTypes['OrderConfirm']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderConfirmedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderConfirmed'] = ResolversParentTypes['OrderConfirmed']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCountableConnection'] = ResolversParentTypes['OrderCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrderCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCountableEdge'] = ResolversParentTypes['OrderCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Order'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCreateFromCheckoutResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCreateFromCheckout'] = ResolversParentTypes['OrderCreateFromCheckout']> = {
  errors?: Resolver<Array<ResolversTypes['OrderCreateFromCheckoutError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCreateFromCheckoutErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCreateFromCheckoutError'] = ResolversParentTypes['OrderCreateFromCheckoutError']> = {
  code?: Resolver<ResolversTypes['OrderCreateFromCheckoutErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lines?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  variants?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderCreated'] = ResolversParentTypes['OrderCreated']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscount'] = ResolversParentTypes['OrderDiscount']> = {
  amount?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  translatedName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['OrderDiscountType'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['PositiveDecimal'], ParentType, ContextType>;
  valueType?: Resolver<ResolversTypes['DiscountValueTypeEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountAddResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscountAdd'] = ResolversParentTypes['OrderDiscountAdd']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscountDelete'] = ResolversParentTypes['OrderDiscountDelete']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderDiscountUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderDiscountUpdate'] = ResolversParentTypes['OrderDiscountUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderError'] = ResolversParentTypes['OrderError']> = {
  addressType?: Resolver<Maybe<ResolversTypes['AddressTypeEnum']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['OrderErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orderLines?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  variants?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEvent'] = ResolversParentTypes['OrderEvent']> = {
  amount?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType>;
  composedId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  date?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  discount?: Resolver<Maybe<ResolversTypes['OrderEventDiscountObject']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emailType?: Resolver<Maybe<ResolversTypes['OrderEventsEmailsEnum']>, ParentType, ContextType>;
  fulfilledItems?: Resolver<Maybe<Array<ResolversTypes['FulfillmentLine']>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoiceNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lines?: Resolver<Maybe<Array<ResolversTypes['OrderEventOrderLineObject']>>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orderNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  oversoldItems?: Resolver<Maybe<Array<ResolversTypes['String']>>, ParentType, ContextType>;
  paymentGateway?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  paymentId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  relatedOrder?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  shippingCostsIncluded?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  transactionReference?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['OrderEventsEnum']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEventCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEventCountableConnection'] = ResolversParentTypes['OrderEventCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrderEventCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEventCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEventCountableEdge'] = ResolversParentTypes['OrderEventCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['OrderEvent'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEventDiscountObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEventDiscountObject'] = ResolversParentTypes['OrderEventDiscountObject']> = {
  amount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  oldAmount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  oldValue?: Resolver<Maybe<ResolversTypes['PositiveDecimal']>, ParentType, ContextType>;
  oldValueType?: Resolver<Maybe<ResolversTypes['DiscountValueTypeEnum']>, ParentType, ContextType>;
  reason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  value?: Resolver<ResolversTypes['PositiveDecimal'], ParentType, ContextType>;
  valueType?: Resolver<ResolversTypes['DiscountValueTypeEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderEventOrderLineObjectResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderEventOrderLineObject'] = ResolversParentTypes['OrderEventOrderLineObject']> = {
  discount?: Resolver<Maybe<ResolversTypes['OrderEventDiscountObject']>, ParentType, ContextType>;
  itemName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  quantity?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderFulfillResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderFulfill'] = ResolversParentTypes['OrderFulfill']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  fulfillments?: Resolver<Maybe<Array<ResolversTypes['Fulfillment']>>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderFulfilledResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderFulfilled'] = ResolversParentTypes['OrderFulfilled']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderFullyPaidResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderFullyPaid'] = ResolversParentTypes['OrderFullyPaid']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLine'] = ResolversParentTypes['OrderLine']> = {
  allocations?: Resolver<Maybe<Array<ResolversTypes['Allocation']>>, ParentType, ContextType>;
  digitalContentUrl?: Resolver<Maybe<ResolversTypes['DigitalContentUrl']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isShippingRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  productName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  productSku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productVariantId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  quantityFulfilled?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  quantityToFulfill?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  taxRate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['Image']>, ParentType, ContextType, Partial<OrderLineThumbnailArgs>>;
  totalPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  translatedProductName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translatedVariantName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  undiscountedUnitPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  unitDiscount?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  unitDiscountReason?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  unitDiscountType?: Resolver<Maybe<ResolversTypes['DiscountValueTypeEnum']>, ParentType, ContextType>;
  unitDiscountValue?: Resolver<ResolversTypes['PositiveDecimal'], ParentType, ContextType>;
  unitPrice?: Resolver<ResolversTypes['TaxedMoney'], ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  variantName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineDelete'] = ResolversParentTypes['OrderLineDelete']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineDiscountRemoveResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineDiscountRemove'] = ResolversParentTypes['OrderLineDiscountRemove']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineDiscountUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineDiscountUpdate'] = ResolversParentTypes['OrderLineDiscountUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLineUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLineUpdate'] = ResolversParentTypes['OrderLineUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderLine?: Resolver<Maybe<ResolversTypes['OrderLine']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderLinesCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderLinesCreate'] = ResolversParentTypes['OrderLinesCreate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  orderLines?: Resolver<Maybe<Array<ResolversTypes['OrderLine']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderMarkAsPaidResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderMarkAsPaid'] = ResolversParentTypes['OrderMarkAsPaid']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderRefundResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderRefund'] = ResolversParentTypes['OrderRefund']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderSettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderSettings'] = ResolversParentTypes['OrderSettings']> = {
  automaticallyConfirmAllNewOrders?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  automaticallyFulfillNonShippableGiftCard?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderSettingsErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderSettingsError'] = ResolversParentTypes['OrderSettingsError']> = {
  code?: Resolver<ResolversTypes['OrderSettingsErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderSettingsUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderSettingsUpdate'] = ResolversParentTypes['OrderSettingsUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderSettingsError']>, ParentType, ContextType>;
  orderSettings?: Resolver<Maybe<ResolversTypes['OrderSettings']>, ParentType, ContextType>;
  orderSettingsErrors?: Resolver<Array<ResolversTypes['OrderSettingsError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderUpdate'] = ResolversParentTypes['OrderUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderUpdateShippingResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderUpdateShipping'] = ResolversParentTypes['OrderUpdateShipping']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderUpdated'] = ResolversParentTypes['OrderUpdated']> = {
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrderVoidResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrderVoid'] = ResolversParentTypes['OrderVoid']> = {
  errors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  orderErrors?: Resolver<Array<ResolversTypes['OrderError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageResolvers<ContextType = any, ParentType extends ResolversParentTypes['Page'] = ResolversParentTypes['Page']> = {
  attributes?: Resolver<Array<ResolversTypes['SelectedAttribute']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  contentJson?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<PageMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<PageMetafieldsArgs>>;
  pageType?: Resolver<ResolversTypes['PageType'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<PagePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<PagePrivateMetafieldsArgs>>;
  publicationDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['PageTranslation']>, ParentType, ContextType, RequireFields<PageTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageAttributeAssignResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageAttributeAssign'] = ResolversParentTypes['PageAttributeAssign']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageAttributeUnassignResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageAttributeUnassign'] = ResolversParentTypes['PageAttributeUnassign']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageBulkDelete'] = ResolversParentTypes['PageBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageBulkPublishResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageBulkPublish'] = ResolversParentTypes['PageBulkPublish']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageCountableConnection'] = ResolversParentTypes['PageCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PageCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageCountableEdge'] = ResolversParentTypes['PageCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Page'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageCreate'] = ResolversParentTypes['PageCreate']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageCreated'] = ResolversParentTypes['PageCreated']> = {
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageDelete'] = ResolversParentTypes['PageDelete']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageDeleted'] = ResolversParentTypes['PageDeleted']> = {
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageError'] = ResolversParentTypes['PageError']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['PageErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  values?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageReorderAttributeValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageReorderAttributeValues'] = ResolversParentTypes['PageReorderAttributeValues']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTranslatableContent'] = ResolversParentTypes['PageTranslatableContent']> = {
  attributeValues?: Resolver<Array<ResolversTypes['AttributeValueTranslatableContent']>, ParentType, ContextType>;
  content?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  contentJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['PageTranslation']>, ParentType, ContextType, RequireFields<PageTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTranslate'] = ResolversParentTypes['PageTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['PageTranslatableContent']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTranslation'] = ResolversParentTypes['PageTranslation']> = {
  content?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  contentJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageType'] = ResolversParentTypes['PageType']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['Attribute']>>, ParentType, ContextType>;
  availableAttributes?: Resolver<Maybe<ResolversTypes['AttributeCountableConnection']>, ParentType, ContextType, Partial<PageTypeAvailableAttributesArgs>>;
  hasPages?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<PageTypeMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<PageTypeMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<PageTypePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<PageTypePrivateMetafieldsArgs>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeBulkDelete'] = ResolversParentTypes['PageTypeBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeCountableConnection'] = ResolversParentTypes['PageTypeCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PageTypeCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeCountableEdge'] = ResolversParentTypes['PageTypeCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['PageType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeCreate'] = ResolversParentTypes['PageTypeCreate']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeDelete'] = ResolversParentTypes['PageTypeDelete']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeReorderAttributesResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeReorderAttributes'] = ResolversParentTypes['PageTypeReorderAttributes']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageTypeUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageTypeUpdate'] = ResolversParentTypes['PageTypeUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageUpdate'] = ResolversParentTypes['PageUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  pageErrors?: Resolver<Array<ResolversTypes['PageError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageUpdated'] = ResolversParentTypes['PageUpdated']> = {
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PasswordChangeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PasswordChange'] = ResolversParentTypes['PasswordChange']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentResolvers<ContextType = any, ParentType extends ResolversParentTypes['Payment'] = ResolversParentTypes['Payment']> = {
  actions?: Resolver<Array<ResolversTypes['OrderAction']>, ParentType, ContextType>;
  availableCaptureAmount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  availableRefundAmount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  capturedAmount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  chargeStatus?: Resolver<ResolversTypes['PaymentChargeStatusEnum'], ParentType, ContextType>;
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  creditCard?: Resolver<Maybe<ResolversTypes['CreditCard']>, ParentType, ContextType>;
  customerIpAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gateway?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<PaymentMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<PaymentMetafieldsArgs>>;
  modified?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType>;
  paymentMethodType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<PaymentPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<PaymentPrivateMetafieldsArgs>>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  total?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  transactions?: Resolver<Maybe<Array<ResolversTypes['Transaction']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentCaptureResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentCapture'] = ResolversParentTypes['PaymentCapture']> = {
  errors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  paymentErrors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentCheckBalanceResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentCheckBalance'] = ResolversParentTypes['PaymentCheckBalance']> = {
  data?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  paymentErrors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentCountableConnection'] = ResolversParentTypes['PaymentCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PaymentCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentCountableEdge'] = ResolversParentTypes['PaymentCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Payment'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentError'] = ResolversParentTypes['PaymentError']> = {
  code?: Resolver<ResolversTypes['PaymentErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  variants?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentGatewayResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentGateway'] = ResolversParentTypes['PaymentGateway']> = {
  config?: Resolver<Array<ResolversTypes['GatewayConfigLine']>, ParentType, ContextType>;
  currencies?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentInitializeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentInitialize'] = ResolversParentTypes['PaymentInitialize']> = {
  errors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  initializedPayment?: Resolver<Maybe<ResolversTypes['PaymentInitialized']>, ParentType, ContextType>;
  paymentErrors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentInitializedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentInitialized'] = ResolversParentTypes['PaymentInitialized']> = {
  data?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  gateway?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentRefundResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentRefund'] = ResolversParentTypes['PaymentRefund']> = {
  errors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  paymentErrors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentSourceResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentSource'] = ResolversParentTypes['PaymentSource']> = {
  creditCardInfo?: Resolver<Maybe<ResolversTypes['CreditCard']>, ParentType, ContextType>;
  gateway?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  paymentMethodId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PaymentVoidResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentVoid'] = ResolversParentTypes['PaymentVoid']> = {
  errors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType>;
  paymentErrors?: Resolver<Array<ResolversTypes['PaymentError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Permission'] = ResolversParentTypes['Permission']> = {
  code?: Resolver<ResolversTypes['PermissionEnum'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionGroupCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionGroupCreate'] = ResolversParentTypes['PermissionGroupCreate']> = {
  errors?: Resolver<Array<ResolversTypes['PermissionGroupError']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  permissionGroupErrors?: Resolver<Array<ResolversTypes['PermissionGroupError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionGroupDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionGroupDelete'] = ResolversParentTypes['PermissionGroupDelete']> = {
  errors?: Resolver<Array<ResolversTypes['PermissionGroupError']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  permissionGroupErrors?: Resolver<Array<ResolversTypes['PermissionGroupError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionGroupErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionGroupError'] = ResolversParentTypes['PermissionGroupError']> = {
  code?: Resolver<ResolversTypes['PermissionGroupErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['PermissionEnum']>>, ParentType, ContextType>;
  users?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionGroupUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionGroupUpdate'] = ResolversParentTypes['PermissionGroupUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['PermissionGroupError']>, ParentType, ContextType>;
  group?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType>;
  permissionGroupErrors?: Resolver<Array<ResolversTypes['PermissionGroupError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PluginResolvers<ContextType = any, ParentType extends ResolversParentTypes['Plugin'] = ResolversParentTypes['Plugin']> = {
  channelConfigurations?: Resolver<Array<ResolversTypes['PluginConfiguration']>, ParentType, ContextType>;
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  globalConfiguration?: Resolver<Maybe<ResolversTypes['PluginConfiguration']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PluginConfigurationResolvers<ContextType = any, ParentType extends ResolversParentTypes['PluginConfiguration'] = ResolversParentTypes['PluginConfiguration']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType>;
  configuration?: Resolver<Maybe<Array<ResolversTypes['ConfigurationItem']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PluginCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PluginCountableConnection'] = ResolversParentTypes['PluginCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PluginCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PluginCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PluginCountableEdge'] = ResolversParentTypes['PluginCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Plugin'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PluginErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['PluginError'] = ResolversParentTypes['PluginError']> = {
  code?: Resolver<ResolversTypes['PluginErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PluginUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['PluginUpdate'] = ResolversParentTypes['PluginUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['PluginError']>, ParentType, ContextType>;
  plugin?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType>;
  pluginsErrors?: Resolver<Array<ResolversTypes['PluginError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface PositiveDecimalScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['PositiveDecimal'], any> {
  name: 'PositiveDecimal';
}

export type PreorderDataResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreorderData'] = ResolversParentTypes['PreorderData']> = {
  endDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  globalSoldUnits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  globalThreshold?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PreorderThresholdResolvers<ContextType = any, ParentType extends ResolversParentTypes['PreorderThreshold'] = ResolversParentTypes['PreorderThreshold']> = {
  quantity?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  soldUnits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductResolvers<ContextType = any, ParentType extends ResolversParentTypes['Product'] = ResolversParentTypes['Product']> = {
  attributes?: Resolver<Array<ResolversTypes['SelectedAttribute']>, ParentType, ContextType>;
  availableForPurchase?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  availableForPurchaseAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  channel?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channelListings?: Resolver<Maybe<Array<ResolversTypes['ProductChannelListing']>>, ParentType, ContextType>;
  chargeTaxes?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  collections?: Resolver<Maybe<Array<ResolversTypes['Collection']>>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  defaultVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  imageById?: Resolver<Maybe<ResolversTypes['ProductImage']>, ParentType, ContextType, Partial<ProductImageByIdArgs>>;
  images?: Resolver<Maybe<Array<ResolversTypes['ProductImage']>>, ParentType, ContextType>;
  isAvailable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, Partial<ProductIsAvailableArgs>>;
  isAvailableForPurchase?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  media?: Resolver<Maybe<Array<ResolversTypes['ProductMedia']>>, ParentType, ContextType>;
  mediaById?: Resolver<Maybe<ResolversTypes['ProductMedia']>, ParentType, ContextType, Partial<ProductMediaByIdArgs>>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ProductMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  pricing?: Resolver<Maybe<ResolversTypes['ProductPricingInfo']>, ParentType, ContextType, Partial<ProductPricingArgs>>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ProductPrivateMetafieldsArgs>>;
  productType?: Resolver<ResolversTypes['ProductType'], ParentType, ContextType>;
  rating?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  taxType?: Resolver<Maybe<ResolversTypes['TaxType']>, ParentType, ContextType>;
  thumbnail?: Resolver<Maybe<ResolversTypes['Image']>, ParentType, ContextType, Partial<ProductThumbnailArgs>>;
  translation?: Resolver<Maybe<ResolversTypes['ProductTranslation']>, ParentType, ContextType, RequireFields<ProductTranslationArgs, 'languageCode'>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  variants?: Resolver<Maybe<Array<ResolversTypes['ProductVariant']>>, ParentType, ContextType>;
  weight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductAttributeAssignResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductAttributeAssign'] = ResolversParentTypes['ProductAttributeAssign']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductAttributeAssignmentUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductAttributeAssignmentUpdate'] = ResolversParentTypes['ProductAttributeAssignmentUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductAttributeUnassignResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductAttributeUnassign'] = ResolversParentTypes['ProductAttributeUnassign']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductBulkDelete'] = ResolversParentTypes['ProductBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductChannelListingResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductChannelListing'] = ResolversParentTypes['ProductChannelListing']> = {
  availableForPurchase?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  availableForPurchaseAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  discountedPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isAvailableForPurchase?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isPublished?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  margin?: Resolver<Maybe<ResolversTypes['Margin']>, ParentType, ContextType>;
  pricing?: Resolver<Maybe<ResolversTypes['ProductPricingInfo']>, ParentType, ContextType, Partial<ProductChannelListingPricingArgs>>;
  publicationDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  publishedAt?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  purchaseCost?: Resolver<Maybe<ResolversTypes['MoneyRange']>, ParentType, ContextType>;
  visibleInListings?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductChannelListingErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductChannelListingError'] = ResolversParentTypes['ProductChannelListingError']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  channels?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['ProductErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  values?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  variants?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductChannelListingUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductChannelListingUpdate'] = ResolversParentTypes['ProductChannelListingUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductChannelListingError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productChannelListingErrors?: Resolver<Array<ResolversTypes['ProductChannelListingError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductCountableConnection'] = ResolversParentTypes['ProductCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ProductCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductCountableEdge'] = ResolversParentTypes['ProductCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Product'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductCreate'] = ResolversParentTypes['ProductCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductCreated'] = ResolversParentTypes['ProductCreated']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, Partial<ProductCreatedProductArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDelete'] = ResolversParentTypes['ProductDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductDeleted'] = ResolversParentTypes['ProductDeleted']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, Partial<ProductDeletedProductArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductError'] = ResolversParentTypes['ProductError']> = {
  attributes?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['ProductErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  values?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductImage'] = ResolversParentTypes['ProductImage']> = {
  alt?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  sortOrder?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<ProductImageUrlArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductMediaResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductMedia'] = ResolversParentTypes['ProductMedia']> = {
  alt?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oembedData?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  sortOrder?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  type?: Resolver<ResolversTypes['ProductMediaType'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType, Partial<ProductMediaUrlArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductMediaBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductMediaBulkDelete'] = ResolversParentTypes['ProductMediaBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductMediaCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductMediaCreate'] = ResolversParentTypes['ProductMediaCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['ProductMedia']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductMediaDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductMediaDelete'] = ResolversParentTypes['ProductMediaDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['ProductMedia']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductMediaReorderResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductMediaReorder'] = ResolversParentTypes['ProductMediaReorder']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  media?: Resolver<Maybe<Array<ResolversTypes['ProductMedia']>>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductMediaUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductMediaUpdate'] = ResolversParentTypes['ProductMediaUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['ProductMedia']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductPricingInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductPricingInfo'] = ResolversParentTypes['ProductPricingInfo']> = {
  discount?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  discountLocalCurrency?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  onSale?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  priceRange?: Resolver<Maybe<ResolversTypes['TaxedMoneyRange']>, ParentType, ContextType>;
  priceRangeLocalCurrency?: Resolver<Maybe<ResolversTypes['TaxedMoneyRange']>, ParentType, ContextType>;
  priceRangeUndiscounted?: Resolver<Maybe<ResolversTypes['TaxedMoneyRange']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductReorderAttributeValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductReorderAttributeValues'] = ResolversParentTypes['ProductReorderAttributeValues']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTranslatableContent'] = ResolversParentTypes['ProductTranslatableContent']> = {
  attributeValues?: Resolver<Array<ResolversTypes['AttributeValueTranslatableContent']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['ProductTranslation']>, ParentType, ContextType, RequireFields<ProductTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTranslate'] = ResolversParentTypes['ProductTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTranslation'] = ResolversParentTypes['ProductTranslation']> = {
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  descriptionJson?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  seoTitle?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductType'] = ResolversParentTypes['ProductType']> = {
  assignedVariantAttributes?: Resolver<Maybe<Array<ResolversTypes['AssignedVariantAttribute']>>, ParentType, ContextType, Partial<ProductTypeAssignedVariantAttributesArgs>>;
  availableAttributes?: Resolver<Maybe<ResolversTypes['AttributeCountableConnection']>, ParentType, ContextType, Partial<ProductTypeAvailableAttributesArgs>>;
  hasVariants?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isDigital?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isShippingRequired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['ProductTypeKindEnum'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductTypeMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ProductTypeMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductTypePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ProductTypePrivateMetafieldsArgs>>;
  productAttributes?: Resolver<Maybe<Array<ResolversTypes['Attribute']>>, ParentType, ContextType>;
  products?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<ProductTypeProductsArgs>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  taxType?: Resolver<Maybe<ResolversTypes['TaxType']>, ParentType, ContextType>;
  variantAttributes?: Resolver<Maybe<Array<ResolversTypes['Attribute']>>, ParentType, ContextType, Partial<ProductTypeVariantAttributesArgs>>;
  weight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeBulkDelete'] = ResolversParentTypes['ProductTypeBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeCountableConnection'] = ResolversParentTypes['ProductTypeCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ProductTypeCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeCountableEdge'] = ResolversParentTypes['ProductTypeCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ProductType'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeCreate'] = ResolversParentTypes['ProductTypeCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeDelete'] = ResolversParentTypes['ProductTypeDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeReorderAttributesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeReorderAttributes'] = ResolversParentTypes['ProductTypeReorderAttributes']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductTypeUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductTypeUpdate'] = ResolversParentTypes['ProductTypeUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductUpdate'] = ResolversParentTypes['ProductUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductUpdated'] = ResolversParentTypes['ProductUpdated']> = {
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, Partial<ProductUpdatedProductArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariant'] = ResolversParentTypes['ProductVariant']> = {
  attributes?: Resolver<Array<ResolversTypes['SelectedAttribute']>, ParentType, ContextType, Partial<ProductVariantAttributesArgs>>;
  channel?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  channelListings?: Resolver<Maybe<Array<ResolversTypes['ProductVariantChannelListing']>>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  digitalContent?: Resolver<Maybe<ResolversTypes['DigitalContent']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  images?: Resolver<Maybe<Array<ResolversTypes['ProductImage']>>, ParentType, ContextType>;
  margin?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  media?: Resolver<Maybe<Array<ResolversTypes['ProductMedia']>>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductVariantMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ProductVariantMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  preorder?: Resolver<Maybe<ResolversTypes['PreorderData']>, ParentType, ContextType>;
  pricing?: Resolver<Maybe<ResolversTypes['VariantPricingInfo']>, ParentType, ContextType, Partial<ProductVariantPricingArgs>>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ProductVariantPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ProductVariantPrivateMetafieldsArgs>>;
  product?: Resolver<ResolversTypes['Product'], ParentType, ContextType>;
  quantityAvailable?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, Partial<ProductVariantQuantityAvailableArgs>>;
  quantityLimitPerCustomer?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  quantityOrdered?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  revenue?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType, Partial<ProductVariantRevenueArgs>>;
  sku?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stocks?: Resolver<Maybe<Array<ResolversTypes['Stock']>>, ParentType, ContextType, Partial<ProductVariantStocksArgs>>;
  trackInventory?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['ProductVariantTranslation']>, ParentType, ContextType, RequireFields<ProductVariantTranslationArgs, 'languageCode'>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  weight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantBackInStockResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantBackInStock'] = ResolversParentTypes['ProductVariantBackInStock']> = {
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductVariantBackInStockProductVariantArgs>>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantBulkCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantBulkCreate'] = ResolversParentTypes['ProductVariantBulkCreate']> = {
  bulkProductErrors?: Resolver<Array<ResolversTypes['BulkProductError']>, ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['BulkProductError']>, ParentType, ContextType>;
  productVariants?: Resolver<Array<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantBulkDelete'] = ResolversParentTypes['ProductVariantBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantChannelListingResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantChannelListing'] = ResolversParentTypes['ProductVariantChannelListing']> = {
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  costPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  margin?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  preorderThreshold?: Resolver<Maybe<ResolversTypes['PreorderThreshold']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantChannelListingUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantChannelListingUpdate'] = ResolversParentTypes['ProductVariantChannelListingUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductChannelListingError']>, ParentType, ContextType>;
  productChannelListingErrors?: Resolver<Array<ResolversTypes['ProductChannelListingError']>, ParentType, ContextType>;
  variant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantCountableConnection'] = ResolversParentTypes['ProductVariantCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ProductVariantCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantCountableEdge'] = ResolversParentTypes['ProductVariantCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantCreate'] = ResolversParentTypes['ProductVariantCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantCreated'] = ResolversParentTypes['ProductVariantCreated']> = {
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductVariantCreatedProductVariantArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantDelete'] = ResolversParentTypes['ProductVariantDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantDeleted'] = ResolversParentTypes['ProductVariantDeleted']> = {
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductVariantDeletedProductVariantArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantOutOfStockResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantOutOfStock'] = ResolversParentTypes['ProductVariantOutOfStock']> = {
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductVariantOutOfStockProductVariantArgs>>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantPreorderDeactivateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantPreorderDeactivate'] = ResolversParentTypes['ProductVariantPreorderDeactivate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantReorderResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantReorder'] = ResolversParentTypes['ProductVariantReorder']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantReorderAttributeValuesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantReorderAttributeValues'] = ResolversParentTypes['ProductVariantReorderAttributeValues']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantSetDefaultResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantSetDefault'] = ResolversParentTypes['ProductVariantSetDefault']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantStocksCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantStocksCreate'] = ResolversParentTypes['ProductVariantStocksCreate']> = {
  bulkStockErrors?: Resolver<Array<ResolversTypes['BulkStockError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['BulkStockError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantStocksDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantStocksDelete'] = ResolversParentTypes['ProductVariantStocksDelete']> = {
  errors?: Resolver<Array<ResolversTypes['StockError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  stockErrors?: Resolver<Array<ResolversTypes['StockError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantStocksUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantStocksUpdate'] = ResolversParentTypes['ProductVariantStocksUpdate']> = {
  bulkStockErrors?: Resolver<Array<ResolversTypes['BulkStockError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['BulkStockError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantTranslatableContent'] = ResolversParentTypes['ProductVariantTranslatableContent']> = {
  attributeValues?: Resolver<Array<ResolversTypes['AttributeValueTranslatableContent']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['ProductVariantTranslation']>, ParentType, ContextType, RequireFields<ProductVariantTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantTranslate'] = ResolversParentTypes['ProductVariantTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantTranslation'] = ResolversParentTypes['ProductVariantTranslation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantUpdate'] = ResolversParentTypes['ProductVariantUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ProductVariantUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ProductVariantUpdated'] = ResolversParentTypes['ProductVariantUpdated']> = {
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<ProductVariantUpdatedProductVariantArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  _entities?: Resolver<Maybe<Array<Maybe<ResolversTypes['_Entity']>>>, ParentType, ContextType, Partial<Query_EntitiesArgs>>;
  _service?: Resolver<Maybe<ResolversTypes['_Service']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType, RequireFields<QueryAddressArgs, 'id'>>;
  addressValidationRules?: Resolver<Maybe<ResolversTypes['AddressValidationData']>, ParentType, ContextType, RequireFields<QueryAddressValidationRulesArgs, 'countryCode'>>;
  app?: Resolver<Maybe<ResolversTypes['App']>, ParentType, ContextType, Partial<QueryAppArgs>>;
  appExtension?: Resolver<Maybe<ResolversTypes['AppExtension']>, ParentType, ContextType, RequireFields<QueryAppExtensionArgs, 'id'>>;
  appExtensions?: Resolver<Maybe<ResolversTypes['AppExtensionCountableConnection']>, ParentType, ContextType, Partial<QueryAppExtensionsArgs>>;
  apps?: Resolver<Maybe<ResolversTypes['AppCountableConnection']>, ParentType, ContextType, Partial<QueryAppsArgs>>;
  appsInstallations?: Resolver<Array<ResolversTypes['AppInstallation']>, ParentType, ContextType>;
  attribute?: Resolver<Maybe<ResolversTypes['Attribute']>, ParentType, ContextType, Partial<QueryAttributeArgs>>;
  attributes?: Resolver<Maybe<ResolversTypes['AttributeCountableConnection']>, ParentType, ContextType, Partial<QueryAttributesArgs>>;
  categories?: Resolver<Maybe<ResolversTypes['CategoryCountableConnection']>, ParentType, ContextType, Partial<QueryCategoriesArgs>>;
  category?: Resolver<Maybe<ResolversTypes['Category']>, ParentType, ContextType, Partial<QueryCategoryArgs>>;
  channel?: Resolver<Maybe<ResolversTypes['Channel']>, ParentType, ContextType, Partial<QueryChannelArgs>>;
  channels?: Resolver<Maybe<Array<ResolversTypes['Channel']>>, ParentType, ContextType>;
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType, Partial<QueryCheckoutArgs>>;
  checkoutLines?: Resolver<Maybe<ResolversTypes['CheckoutLineCountableConnection']>, ParentType, ContextType, Partial<QueryCheckoutLinesArgs>>;
  checkouts?: Resolver<Maybe<ResolversTypes['CheckoutCountableConnection']>, ParentType, ContextType, Partial<QueryCheckoutsArgs>>;
  collection?: Resolver<Maybe<ResolversTypes['Collection']>, ParentType, ContextType, Partial<QueryCollectionArgs>>;
  collections?: Resolver<Maybe<ResolversTypes['CollectionCountableConnection']>, ParentType, ContextType, Partial<QueryCollectionsArgs>>;
  customers?: Resolver<Maybe<ResolversTypes['UserCountableConnection']>, ParentType, ContextType, Partial<QueryCustomersArgs>>;
  digitalContent?: Resolver<Maybe<ResolversTypes['DigitalContent']>, ParentType, ContextType, RequireFields<QueryDigitalContentArgs, 'id'>>;
  digitalContents?: Resolver<Maybe<ResolversTypes['DigitalContentCountableConnection']>, ParentType, ContextType, Partial<QueryDigitalContentsArgs>>;
  draftOrders?: Resolver<Maybe<ResolversTypes['OrderCountableConnection']>, ParentType, ContextType, Partial<QueryDraftOrdersArgs>>;
  exportFile?: Resolver<Maybe<ResolversTypes['ExportFile']>, ParentType, ContextType, RequireFields<QueryExportFileArgs, 'id'>>;
  exportFiles?: Resolver<Maybe<ResolversTypes['ExportFileCountableConnection']>, ParentType, ContextType, Partial<QueryExportFilesArgs>>;
  giftCard?: Resolver<Maybe<ResolversTypes['GiftCard']>, ParentType, ContextType, RequireFields<QueryGiftCardArgs, 'id'>>;
  giftCardCurrencies?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  giftCardSettings?: Resolver<ResolversTypes['GiftCardSettings'], ParentType, ContextType>;
  giftCardTags?: Resolver<Maybe<ResolversTypes['GiftCardTagCountableConnection']>, ParentType, ContextType, Partial<QueryGiftCardTagsArgs>>;
  giftCards?: Resolver<Maybe<ResolversTypes['GiftCardCountableConnection']>, ParentType, ContextType, Partial<QueryGiftCardsArgs>>;
  homepageEvents?: Resolver<Maybe<ResolversTypes['OrderEventCountableConnection']>, ParentType, ContextType, Partial<QueryHomepageEventsArgs>>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  menu?: Resolver<Maybe<ResolversTypes['Menu']>, ParentType, ContextType, Partial<QueryMenuArgs>>;
  menuItem?: Resolver<Maybe<ResolversTypes['MenuItem']>, ParentType, ContextType, RequireFields<QueryMenuItemArgs, 'id'>>;
  menuItems?: Resolver<Maybe<ResolversTypes['MenuItemCountableConnection']>, ParentType, ContextType, Partial<QueryMenuItemsArgs>>;
  menus?: Resolver<Maybe<ResolversTypes['MenuCountableConnection']>, ParentType, ContextType, Partial<QueryMenusArgs>>;
  order?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<QueryOrderArgs, 'id'>>;
  orderByToken?: Resolver<Maybe<ResolversTypes['Order']>, ParentType, ContextType, RequireFields<QueryOrderByTokenArgs, 'token'>>;
  orderSettings?: Resolver<Maybe<ResolversTypes['OrderSettings']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['OrderCountableConnection']>, ParentType, ContextType, Partial<QueryOrdersArgs>>;
  ordersTotal?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType, Partial<QueryOrdersTotalArgs>>;
  page?: Resolver<Maybe<ResolversTypes['Page']>, ParentType, ContextType, Partial<QueryPageArgs>>;
  pageType?: Resolver<Maybe<ResolversTypes['PageType']>, ParentType, ContextType, RequireFields<QueryPageTypeArgs, 'id'>>;
  pageTypes?: Resolver<Maybe<ResolversTypes['PageTypeCountableConnection']>, ParentType, ContextType, Partial<QueryPageTypesArgs>>;
  pages?: Resolver<Maybe<ResolversTypes['PageCountableConnection']>, ParentType, ContextType, Partial<QueryPagesArgs>>;
  payment?: Resolver<Maybe<ResolversTypes['Payment']>, ParentType, ContextType, RequireFields<QueryPaymentArgs, 'id'>>;
  payments?: Resolver<Maybe<ResolversTypes['PaymentCountableConnection']>, ParentType, ContextType, Partial<QueryPaymentsArgs>>;
  permissionGroup?: Resolver<Maybe<ResolversTypes['Group']>, ParentType, ContextType, RequireFields<QueryPermissionGroupArgs, 'id'>>;
  permissionGroups?: Resolver<Maybe<ResolversTypes['GroupCountableConnection']>, ParentType, ContextType, Partial<QueryPermissionGroupsArgs>>;
  plugin?: Resolver<Maybe<ResolversTypes['Plugin']>, ParentType, ContextType, RequireFields<QueryPluginArgs, 'id'>>;
  plugins?: Resolver<Maybe<ResolversTypes['PluginCountableConnection']>, ParentType, ContextType, Partial<QueryPluginsArgs>>;
  product?: Resolver<Maybe<ResolversTypes['Product']>, ParentType, ContextType, Partial<QueryProductArgs>>;
  productType?: Resolver<Maybe<ResolversTypes['ProductType']>, ParentType, ContextType, RequireFields<QueryProductTypeArgs, 'id'>>;
  productTypes?: Resolver<Maybe<ResolversTypes['ProductTypeCountableConnection']>, ParentType, ContextType, Partial<QueryProductTypesArgs>>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType, Partial<QueryProductVariantArgs>>;
  productVariants?: Resolver<Maybe<ResolversTypes['ProductVariantCountableConnection']>, ParentType, ContextType, Partial<QueryProductVariantsArgs>>;
  products?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<QueryProductsArgs>>;
  reportProductSales?: Resolver<Maybe<ResolversTypes['ProductVariantCountableConnection']>, ParentType, ContextType, RequireFields<QueryReportProductSalesArgs, 'channel' | 'period'>>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType, RequireFields<QuerySaleArgs, 'id'>>;
  sales?: Resolver<Maybe<ResolversTypes['SaleCountableConnection']>, ParentType, ContextType, Partial<QuerySalesArgs>>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, RequireFields<QueryShippingZoneArgs, 'id'>>;
  shippingZones?: Resolver<Maybe<ResolversTypes['ShippingZoneCountableConnection']>, ParentType, ContextType, Partial<QueryShippingZonesArgs>>;
  shop?: Resolver<ResolversTypes['Shop'], ParentType, ContextType>;
  staffUsers?: Resolver<Maybe<ResolversTypes['UserCountableConnection']>, ParentType, ContextType, Partial<QueryStaffUsersArgs>>;
  stock?: Resolver<Maybe<ResolversTypes['Stock']>, ParentType, ContextType, RequireFields<QueryStockArgs, 'id'>>;
  stocks?: Resolver<Maybe<ResolversTypes['StockCountableConnection']>, ParentType, ContextType, Partial<QueryStocksArgs>>;
  taxTypes?: Resolver<Maybe<Array<ResolversTypes['TaxType']>>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['TranslatableItem']>, ParentType, ContextType, RequireFields<QueryTranslationArgs, 'id' | 'kind'>>;
  translations?: Resolver<Maybe<ResolversTypes['TranslatableItemConnection']>, ParentType, ContextType, RequireFields<QueryTranslationsArgs, 'kind'>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, Partial<QueryUserArgs>>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType, RequireFields<QueryVoucherArgs, 'id'>>;
  vouchers?: Resolver<Maybe<ResolversTypes['VoucherCountableConnection']>, ParentType, ContextType, Partial<QueryVouchersArgs>>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType, RequireFields<QueryWarehouseArgs, 'id'>>;
  warehouses?: Resolver<Maybe<ResolversTypes['WarehouseCountableConnection']>, ParentType, ContextType, Partial<QueryWarehousesArgs>>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType, RequireFields<QueryWebhookArgs, 'id'>>;
  webhookEvents?: Resolver<Maybe<Array<ResolversTypes['WebhookEvent']>>, ParentType, ContextType>;
  webhookSamplePayload?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType, RequireFields<QueryWebhookSamplePayloadArgs, 'eventType'>>;
};

export type ReducedRateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReducedRate'] = ResolversParentTypes['ReducedRate']> = {
  rate?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  rateType?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RefreshTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['RefreshToken'] = ResolversParentTypes['RefreshToken']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequestEmailChangeResolvers<ContextType = any, ParentType extends ResolversParentTypes['RequestEmailChange'] = ResolversParentTypes['RequestEmailChange']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RequestPasswordResetResolvers<ContextType = any, ParentType extends ResolversParentTypes['RequestPasswordReset'] = ResolversParentTypes['RequestPasswordReset']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleResolvers<ContextType = any, ParentType extends ResolversParentTypes['Sale'] = ResolversParentTypes['Sale']> = {
  categories?: Resolver<Maybe<ResolversTypes['CategoryCountableConnection']>, ParentType, ContextType, Partial<SaleCategoriesArgs>>;
  channelListings?: Resolver<Maybe<Array<ResolversTypes['SaleChannelListing']>>, ParentType, ContextType>;
  collections?: Resolver<Maybe<ResolversTypes['CollectionCountableConnection']>, ParentType, ContextType, Partial<SaleCollectionsArgs>>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discountValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SaleMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<SaleMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<SalePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<SalePrivateMetafieldsArgs>>;
  products?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<SaleProductsArgs>>;
  startDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['SaleTranslation']>, ParentType, ContextType, RequireFields<SaleTranslationArgs, 'languageCode'>>;
  type?: Resolver<ResolversTypes['SaleType'], ParentType, ContextType>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  variants?: Resolver<Maybe<ResolversTypes['ProductVariantCountableConnection']>, ParentType, ContextType, Partial<SaleVariantsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleAddCataloguesResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleAddCatalogues'] = ResolversParentTypes['SaleAddCatalogues']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleBulkDelete'] = ResolversParentTypes['SaleBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleChannelListingResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleChannelListing'] = ResolversParentTypes['SaleChannelListing']> = {
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  discountValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleChannelListingUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleChannelListingUpdate'] = ResolversParentTypes['SaleChannelListingUpdate']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleCountableConnection'] = ResolversParentTypes['SaleCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SaleCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleCountableEdge'] = ResolversParentTypes['SaleCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Sale'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleCreate'] = ResolversParentTypes['SaleCreate']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleCreated'] = ResolversParentTypes['SaleCreated']> = {
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType, Partial<SaleCreatedSaleArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleDelete'] = ResolversParentTypes['SaleDelete']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleDeleted'] = ResolversParentTypes['SaleDeleted']> = {
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType, Partial<SaleDeletedSaleArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleRemoveCataloguesResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleRemoveCatalogues'] = ResolversParentTypes['SaleRemoveCatalogues']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleTranslatableContent'] = ResolversParentTypes['SaleTranslatableContent']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['SaleTranslation']>, ParentType, ContextType, RequireFields<SaleTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleTranslate'] = ResolversParentTypes['SaleTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleTranslation'] = ResolversParentTypes['SaleTranslation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleUpdate'] = ResolversParentTypes['SaleUpdate']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SaleUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['SaleUpdated'] = ResolversParentTypes['SaleUpdated']> = {
  sale?: Resolver<Maybe<ResolversTypes['Sale']>, ParentType, ContextType, Partial<SaleUpdatedSaleArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SelectedAttributeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SelectedAttribute'] = ResolversParentTypes['SelectedAttribute']> = {
  attribute?: Resolver<ResolversTypes['Attribute'], ParentType, ContextType>;
  values?: Resolver<Array<ResolversTypes['AttributeValue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SetPasswordResolvers<ContextType = any, ParentType extends ResolversParentTypes['SetPassword'] = ResolversParentTypes['SetPassword']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  csrfToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  refreshToken?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  token?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingError'] = ResolversParentTypes['ShippingError']> = {
  channels?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['ShippingErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  warehouses?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethod'] = ResolversParentTypes['ShippingMethod']> = {
  active?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  maximumDeliveryDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximumOrderPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  maximumOrderWeight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ShippingMethodMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ShippingMethodMetafieldsArgs>>;
  minimumDeliveryDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minimumOrderPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  minimumOrderWeight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  price?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ShippingMethodPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ShippingMethodPrivateMetafieldsArgs>>;
  translation?: Resolver<Maybe<ResolversTypes['ShippingMethodTranslation']>, ParentType, ContextType, RequireFields<ShippingMethodTranslationArgs, 'languageCode'>>;
  type?: Resolver<Maybe<ResolversTypes['ShippingMethodTypeEnum']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodChannelListingResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodChannelListing'] = ResolversParentTypes['ShippingMethodChannelListing']> = {
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  maximumOrderPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  minimumOrderPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodChannelListingUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodChannelListingUpdate'] = ResolversParentTypes['ShippingMethodChannelListingUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodPostalCodeRuleResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodPostalCodeRule'] = ResolversParentTypes['ShippingMethodPostalCodeRule']> = {
  end?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  inclusionType?: Resolver<Maybe<ResolversTypes['PostalCodeRuleInclusionTypeEnum']>, ParentType, ContextType>;
  start?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodTranslatableContent'] = ResolversParentTypes['ShippingMethodTranslatableContent']> = {
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['ShippingMethodTranslation']>, ParentType, ContextType, RequireFields<ShippingMethodTranslatableContentTranslationArgs, 'languageCode'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodTranslation'] = ResolversParentTypes['ShippingMethodTranslation']> = {
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingMethodTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingMethodType'] = ResolversParentTypes['ShippingMethodType']> = {
  channelListings?: Resolver<Maybe<Array<ResolversTypes['ShippingMethodChannelListing']>>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['JSONString']>, ParentType, ContextType>;
  excludedProducts?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<ShippingMethodTypeExcludedProductsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  maximumDeliveryDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  maximumOrderPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  maximumOrderWeight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ShippingMethodTypeMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ShippingMethodTypeMetafieldsArgs>>;
  minimumDeliveryDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minimumOrderPrice?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  minimumOrderWeight?: Resolver<Maybe<ResolversTypes['Weight']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  postalCodeRules?: Resolver<Maybe<Array<ResolversTypes['ShippingMethodPostalCodeRule']>>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ShippingMethodTypePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ShippingMethodTypePrivateMetafieldsArgs>>;
  translation?: Resolver<Maybe<ResolversTypes['ShippingMethodTranslation']>, ParentType, ContextType, RequireFields<ShippingMethodTypeTranslationArgs, 'languageCode'>>;
  type?: Resolver<Maybe<ResolversTypes['ShippingMethodTypeEnum']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceBulkDelete'] = ResolversParentTypes['ShippingPriceBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceCreate'] = ResolversParentTypes['ShippingPriceCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceCreated'] = ResolversParentTypes['ShippingPriceCreated']> = {
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType, Partial<ShippingPriceCreatedShippingMethodArgs>>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, Partial<ShippingPriceCreatedShippingZoneArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceDelete'] = ResolversParentTypes['ShippingPriceDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceDeleted'] = ResolversParentTypes['ShippingPriceDeleted']> = {
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType, Partial<ShippingPriceDeletedShippingMethodArgs>>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, Partial<ShippingPriceDeletedShippingZoneArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceExcludeProductsResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceExcludeProducts'] = ResolversParentTypes['ShippingPriceExcludeProducts']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceRemoveProductFromExcludeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceRemoveProductFromExclude'] = ResolversParentTypes['ShippingPriceRemoveProductFromExclude']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceTranslate'] = ResolversParentTypes['ShippingPriceTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceUpdate'] = ResolversParentTypes['ShippingPriceUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingPriceUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingPriceUpdated'] = ResolversParentTypes['ShippingPriceUpdated']> = {
  shippingMethod?: Resolver<Maybe<ResolversTypes['ShippingMethodType']>, ParentType, ContextType, Partial<ShippingPriceUpdatedShippingMethodArgs>>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, Partial<ShippingPriceUpdatedShippingZoneArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZone'] = ResolversParentTypes['ShippingZone']> = {
  channels?: Resolver<Array<ResolversTypes['Channel']>, ParentType, ContextType>;
  countries?: Resolver<Array<ResolversTypes['CountryDisplay']>, ParentType, ContextType>;
  default?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ShippingZoneMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ShippingZoneMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  priceRange?: Resolver<Maybe<ResolversTypes['MoneyRange']>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<ShippingZonePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<ShippingZonePrivateMetafieldsArgs>>;
  shippingMethods?: Resolver<Maybe<Array<ResolversTypes['ShippingMethodType']>>, ParentType, ContextType>;
  warehouses?: Resolver<Array<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneBulkDelete'] = ResolversParentTypes['ShippingZoneBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneCountableConnection'] = ResolversParentTypes['ShippingZoneCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ShippingZoneCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneCountableEdge'] = ResolversParentTypes['ShippingZoneCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['ShippingZone'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneCreate'] = ResolversParentTypes['ShippingZoneCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneCreated'] = ResolversParentTypes['ShippingZoneCreated']> = {
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, Partial<ShippingZoneCreatedShippingZoneArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneDelete'] = ResolversParentTypes['ShippingZoneDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneDeletedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneDeleted'] = ResolversParentTypes['ShippingZoneDeleted']> = {
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, Partial<ShippingZoneDeletedShippingZoneArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneUpdate'] = ResolversParentTypes['ShippingZoneUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingErrors?: Resolver<Array<ResolversTypes['ShippingError']>, ParentType, ContextType>;
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShippingZoneUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShippingZoneUpdated'] = ResolversParentTypes['ShippingZoneUpdated']> = {
  shippingZone?: Resolver<Maybe<ResolversTypes['ShippingZone']>, ParentType, ContextType, Partial<ShippingZoneUpdatedShippingZoneArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopResolvers<ContextType = any, ParentType extends ResolversParentTypes['Shop'] = ResolversParentTypes['Shop']> = {
  automaticFulfillmentDigitalProducts?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  availableExternalAuthentications?: Resolver<Array<ResolversTypes['ExternalAuthentication']>, ParentType, ContextType>;
  availablePaymentGateways?: Resolver<Array<ResolversTypes['PaymentGateway']>, ParentType, ContextType, Partial<ShopAvailablePaymentGatewaysArgs>>;
  availableShippingMethods?: Resolver<Maybe<Array<ResolversTypes['ShippingMethod']>>, ParentType, ContextType, RequireFields<ShopAvailableShippingMethodsArgs, 'channel'>>;
  channelCurrencies?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  chargeTaxesOnShipping?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  companyAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  countries?: Resolver<Array<ResolversTypes['CountryDisplay']>, ParentType, ContextType, Partial<ShopCountriesArgs>>;
  customerSetPasswordUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultCountry?: Resolver<Maybe<ResolversTypes['CountryDisplay']>, ParentType, ContextType>;
  defaultDigitalMaxDownloads?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  defaultDigitalUrlValidDays?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  defaultMailSenderAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultMailSenderName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultWeightUnit?: Resolver<Maybe<ResolversTypes['WeightUnitsEnum']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayGrossPrices?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  domain?: Resolver<ResolversTypes['Domain'], ParentType, ContextType>;
  fulfillmentAllowUnpaid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  fulfillmentAutoApprove?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  headerText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  includeTaxesInPrices?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  languages?: Resolver<Array<ResolversTypes['LanguageDisplay']>, ParentType, ContextType>;
  limitQuantityPerCheckout?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  limits?: Resolver<ResolversTypes['LimitInfo'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  permissions?: Resolver<Array<ResolversTypes['Permission']>, ParentType, ContextType>;
  phonePrefixes?: Resolver<Array<ResolversTypes['String']>, ParentType, ContextType>;
  reserveStockDurationAnonymousUser?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reserveStockDurationAuthenticatedUser?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  staffNotificationRecipients?: Resolver<Maybe<Array<ResolversTypes['StaffNotificationRecipient']>>, ParentType, ContextType>;
  trackInventoryByDefault?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['ShopTranslation']>, ParentType, ContextType, RequireFields<ShopTranslationArgs, 'languageCode'>>;
  version?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopAddressUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopAddressUpdate'] = ResolversParentTypes['ShopAddressUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shop?: Resolver<Maybe<ResolversTypes['Shop']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopDomainUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopDomainUpdate'] = ResolversParentTypes['ShopDomainUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shop?: Resolver<Maybe<ResolversTypes['Shop']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopError'] = ResolversParentTypes['ShopError']> = {
  code?: Resolver<ResolversTypes['ShopErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopFetchTaxRatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopFetchTaxRates'] = ResolversParentTypes['ShopFetchTaxRates']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shop?: Resolver<Maybe<ResolversTypes['Shop']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopSettingsTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopSettingsTranslate'] = ResolversParentTypes['ShopSettingsTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  shop?: Resolver<Maybe<ResolversTypes['Shop']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopSettingsUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopSettingsUpdate'] = ResolversParentTypes['ShopSettingsUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shop?: Resolver<Maybe<ResolversTypes['Shop']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ShopTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['ShopTranslation'] = ResolversParentTypes['ShopTranslation']> = {
  description?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  headerText?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffBulkDelete'] = ResolversParentTypes['StaffBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  staffErrors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffCreate'] = ResolversParentTypes['StaffCreate']> = {
  errors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  staffErrors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffDelete'] = ResolversParentTypes['StaffDelete']> = {
  errors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  staffErrors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffError'] = ResolversParentTypes['StaffError']> = {
  addressType?: Resolver<Maybe<ResolversTypes['AddressTypeEnum']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['AccountErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  groups?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissions?: Resolver<Maybe<Array<ResolversTypes['PermissionEnum']>>, ParentType, ContextType>;
  users?: Resolver<Maybe<Array<ResolversTypes['ID']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffNotificationRecipientResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffNotificationRecipient'] = ResolversParentTypes['StaffNotificationRecipient']> = {
  active?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffNotificationRecipientCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffNotificationRecipientCreate'] = ResolversParentTypes['StaffNotificationRecipientCreate']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  staffNotificationRecipient?: Resolver<Maybe<ResolversTypes['StaffNotificationRecipient']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffNotificationRecipientDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffNotificationRecipientDelete'] = ResolversParentTypes['StaffNotificationRecipientDelete']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  staffNotificationRecipient?: Resolver<Maybe<ResolversTypes['StaffNotificationRecipient']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffNotificationRecipientUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffNotificationRecipientUpdate'] = ResolversParentTypes['StaffNotificationRecipientUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  shopErrors?: Resolver<Array<ResolversTypes['ShopError']>, ParentType, ContextType>;
  staffNotificationRecipient?: Resolver<Maybe<ResolversTypes['StaffNotificationRecipient']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StaffUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['StaffUpdate'] = ResolversParentTypes['StaffUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  staffErrors?: Resolver<Array<ResolversTypes['StaffError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StockResolvers<ContextType = any, ParentType extends ResolversParentTypes['Stock'] = ResolversParentTypes['Stock']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  productVariant?: Resolver<ResolversTypes['ProductVariant'], ParentType, ContextType>;
  quantity?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  quantityAllocated?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  quantityReserved?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  warehouse?: Resolver<ResolversTypes['Warehouse'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StockCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StockCountableConnection'] = ResolversParentTypes['StockCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['StockCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StockCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StockCountableEdge'] = ResolversParentTypes['StockCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Stock'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StockErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['StockError'] = ResolversParentTypes['StockError']> = {
  code?: Resolver<ResolversTypes['StockErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  event?: SubscriptionResolver<Maybe<ResolversTypes['Event']>, "event", ParentType, ContextType>;
};

export type TaxTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxType'] = ResolversParentTypes['TaxType']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  taxCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxedMoneyResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxedMoney'] = ResolversParentTypes['TaxedMoney']> = {
  currency?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  gross?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  net?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  tax?: Resolver<ResolversTypes['Money'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TaxedMoneyRangeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TaxedMoneyRange'] = ResolversParentTypes['TaxedMoneyRange']> = {
  start?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  stop?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TimePeriodResolvers<ContextType = any, ParentType extends ResolversParentTypes['TimePeriod'] = ResolversParentTypes['TimePeriod']> = {
  amount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['TimePeriodTypeEnum'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = {
  amount?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  created?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  error?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gatewayResponse?: Resolver<ResolversTypes['JSONString'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isSuccess?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  kind?: Resolver<ResolversTypes['TransactionKind'], ParentType, ContextType>;
  payment?: Resolver<ResolversTypes['Payment'], ParentType, ContextType>;
  token?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TranslatableItemResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslatableItem'] = ResolversParentTypes['TranslatableItem']> = {
  __resolveType: TypeResolveFn<'AttributeTranslatableContent' | 'AttributeValueTranslatableContent' | 'CategoryTranslatableContent' | 'CollectionTranslatableContent' | 'MenuItemTranslatableContent' | 'PageTranslatableContent' | 'ProductTranslatableContent' | 'ProductVariantTranslatableContent' | 'SaleTranslatableContent' | 'ShippingMethodTranslatableContent' | 'VoucherTranslatableContent', ParentType, ContextType>;
};

export type TranslatableItemConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslatableItemConnection'] = ResolversParentTypes['TranslatableItemConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TranslatableItemEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TranslatableItemEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslatableItemEdge'] = ResolversParentTypes['TranslatableItemEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['TranslatableItem'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TranslationCreatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslationCreated'] = ResolversParentTypes['TranslationCreated']> = {
  translation?: Resolver<Maybe<ResolversTypes['TranslationTypes']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TranslationErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslationError'] = ResolversParentTypes['TranslationError']> = {
  code?: Resolver<ResolversTypes['TranslationErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TranslationTypesResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslationTypes'] = ResolversParentTypes['TranslationTypes']> = {
  __resolveType: TypeResolveFn<'AttributeTranslation' | 'AttributeValueTranslation' | 'CategoryTranslation' | 'CollectionTranslation' | 'MenuItemTranslation' | 'PageTranslation' | 'ProductTranslation' | 'ProductVariantTranslation' | 'SaleTranslation' | 'ShippingMethodTranslation' | 'VoucherTranslation', ParentType, ContextType>;
};

export type TranslationUpdatedResolvers<ContextType = any, ParentType extends ResolversParentTypes['TranslationUpdated'] = ResolversParentTypes['TranslationUpdated']> = {
  translation?: Resolver<Maybe<ResolversTypes['TranslationTypes']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UuidScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['UUID'], any> {
  name: 'UUID';
}

export type UpdateMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateMetadata'] = ResolversParentTypes['UpdateMetadata']> = {
  errors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ObjectWithMetadata']>, ParentType, ContextType>;
  metadataErrors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePrivateMetadataResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePrivateMetadata'] = ResolversParentTypes['UpdatePrivateMetadata']> = {
  errors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  item?: Resolver<Maybe<ResolversTypes['ObjectWithMetadata']>, ParentType, ContextType>;
  metadataErrors?: Resolver<Array<ResolversTypes['MetadataError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UploadScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Upload'], any> {
  name: 'Upload';
}

export type UploadErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['UploadError'] = ResolversParentTypes['UploadError']> = {
  code?: Resolver<ResolversTypes['UploadErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  addresses?: Resolver<Maybe<Array<ResolversTypes['Address']>>, ParentType, ContextType>;
  avatar?: Resolver<Maybe<ResolversTypes['Image']>, ParentType, ContextType, Partial<UserAvatarArgs>>;
  checkout?: Resolver<Maybe<ResolversTypes['Checkout']>, ParentType, ContextType>;
  checkoutTokens?: Resolver<Maybe<Array<ResolversTypes['UUID']>>, ParentType, ContextType, Partial<UserCheckoutTokensArgs>>;
  dateJoined?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  defaultBillingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  defaultShippingAddress?: Resolver<Maybe<ResolversTypes['Address']>, ParentType, ContextType>;
  editableGroups?: Resolver<Maybe<Array<ResolversTypes['Group']>>, ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  events?: Resolver<Maybe<Array<ResolversTypes['CustomerEvent']>>, ParentType, ContextType>;
  firstName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  giftCards?: Resolver<Maybe<ResolversTypes['GiftCardCountableConnection']>, ParentType, ContextType, Partial<UserGiftCardsArgs>>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isStaff?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  languageCode?: Resolver<ResolversTypes['LanguageCodeEnum'], ParentType, ContextType>;
  lastLogin?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  lastName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<UserMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<UserMetafieldsArgs>>;
  note?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orders?: Resolver<Maybe<ResolversTypes['OrderCountableConnection']>, ParentType, ContextType, Partial<UserOrdersArgs>>;
  permissionGroups?: Resolver<Maybe<Array<ResolversTypes['Group']>>, ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<UserPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<UserPrivateMetafieldsArgs>>;
  storedPaymentSources?: Resolver<Maybe<Array<ResolversTypes['PaymentSource']>>, ParentType, ContextType, Partial<UserStoredPaymentSourcesArgs>>;
  updatedAt?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  userPermissions?: Resolver<Maybe<Array<ResolversTypes['UserPermission']>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAvatarDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAvatarDelete'] = ResolversParentTypes['UserAvatarDelete']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserAvatarUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserAvatarUpdate'] = ResolversParentTypes['UserAvatarUpdate']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserBulkSetActiveResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserBulkSetActive'] = ResolversParentTypes['UserBulkSetActive']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCountableConnection'] = ResolversParentTypes['UserCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserCountableEdge'] = ResolversParentTypes['UserCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['User'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserPermissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserPermission'] = ResolversParentTypes['UserPermission']> = {
  code?: Resolver<ResolversTypes['PermissionEnum'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  sourcePermissionGroups?: Resolver<Maybe<Array<ResolversTypes['Group']>>, ParentType, ContextType, RequireFields<UserPermissionSourcePermissionGroupsArgs, 'userId'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VatResolvers<ContextType = any, ParentType extends ResolversParentTypes['VAT'] = ResolversParentTypes['VAT']> = {
  countryCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  reducedRates?: Resolver<Array<ResolversTypes['ReducedRate']>, ParentType, ContextType>;
  standardRate?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VariantMediaAssignResolvers<ContextType = any, ParentType extends ResolversParentTypes['VariantMediaAssign'] = ResolversParentTypes['VariantMediaAssign']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['ProductMedia']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VariantMediaUnassignResolvers<ContextType = any, ParentType extends ResolversParentTypes['VariantMediaUnassign'] = ResolversParentTypes['VariantMediaUnassign']> = {
  errors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  media?: Resolver<Maybe<ResolversTypes['ProductMedia']>, ParentType, ContextType>;
  productErrors?: Resolver<Array<ResolversTypes['ProductError']>, ParentType, ContextType>;
  productVariant?: Resolver<Maybe<ResolversTypes['ProductVariant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VariantPricingInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['VariantPricingInfo'] = ResolversParentTypes['VariantPricingInfo']> = {
  discount?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  discountLocalCurrency?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  onSale?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  priceLocalCurrency?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  priceUndiscounted?: Resolver<Maybe<ResolversTypes['TaxedMoney']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerifyTokenResolvers<ContextType = any, ParentType extends ResolversParentTypes['VerifyToken'] = ResolversParentTypes['VerifyToken']> = {
  accountErrors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['AccountError']>, ParentType, ContextType>;
  isValid?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  payload?: Resolver<Maybe<ResolversTypes['GenericScalar']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherResolvers<ContextType = any, ParentType extends ResolversParentTypes['Voucher'] = ResolversParentTypes['Voucher']> = {
  applyOncePerCustomer?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  applyOncePerOrder?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  categories?: Resolver<Maybe<ResolversTypes['CategoryCountableConnection']>, ParentType, ContextType, Partial<VoucherCategoriesArgs>>;
  channelListings?: Resolver<Maybe<Array<ResolversTypes['VoucherChannelListing']>>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  collections?: Resolver<Maybe<ResolversTypes['CollectionCountableConnection']>, ParentType, ContextType, Partial<VoucherCollectionsArgs>>;
  countries?: Resolver<Maybe<Array<ResolversTypes['CountryDisplay']>>, ParentType, ContextType>;
  currency?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  discountValue?: Resolver<Maybe<ResolversTypes['Float']>, ParentType, ContextType>;
  discountValueType?: Resolver<ResolversTypes['DiscountValueTypeEnum'], ParentType, ContextType>;
  endDate?: Resolver<Maybe<ResolversTypes['DateTime']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<VoucherMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<VoucherMetafieldsArgs>>;
  minCheckoutItemsQuantity?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  minSpent?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  onlyForStaff?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<VoucherPrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<VoucherPrivateMetafieldsArgs>>;
  products?: Resolver<Maybe<ResolversTypes['ProductCountableConnection']>, ParentType, ContextType, Partial<VoucherProductsArgs>>;
  startDate?: Resolver<ResolversTypes['DateTime'], ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['VoucherTranslation']>, ParentType, ContextType, RequireFields<VoucherTranslationArgs, 'languageCode'>>;
  type?: Resolver<ResolversTypes['VoucherTypeEnum'], ParentType, ContextType>;
  usageLimit?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  used?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  variants?: Resolver<Maybe<ResolversTypes['ProductVariantCountableConnection']>, ParentType, ContextType, Partial<VoucherVariantsArgs>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherAddCataloguesResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherAddCatalogues'] = ResolversParentTypes['VoucherAddCatalogues']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherBulkDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherBulkDelete'] = ResolversParentTypes['VoucherBulkDelete']> = {
  count?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherChannelListingResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherChannelListing'] = ResolversParentTypes['VoucherChannelListing']> = {
  channel?: Resolver<ResolversTypes['Channel'], ParentType, ContextType>;
  currency?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  discountValue?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  minSpent?: Resolver<Maybe<ResolversTypes['Money']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherChannelListingUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherChannelListingUpdate'] = ResolversParentTypes['VoucherChannelListingUpdate']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherCountableConnection'] = ResolversParentTypes['VoucherCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['VoucherCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherCountableEdge'] = ResolversParentTypes['VoucherCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Voucher'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherCreate'] = ResolversParentTypes['VoucherCreate']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherDelete'] = ResolversParentTypes['VoucherDelete']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherRemoveCataloguesResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherRemoveCatalogues'] = ResolversParentTypes['VoucherRemoveCatalogues']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherTranslatableContentResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherTranslatableContent'] = ResolversParentTypes['VoucherTranslatableContent']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  translation?: Resolver<Maybe<ResolversTypes['VoucherTranslation']>, ParentType, ContextType, RequireFields<VoucherTranslatableContentTranslationArgs, 'languageCode'>>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherTranslateResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherTranslate'] = ResolversParentTypes['VoucherTranslate']> = {
  errors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  translationErrors?: Resolver<Array<ResolversTypes['TranslationError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherTranslationResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherTranslation'] = ResolversParentTypes['VoucherTranslation']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['LanguageDisplay'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VoucherUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['VoucherUpdate'] = ResolversParentTypes['VoucherUpdate']> = {
  discountErrors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  errors?: Resolver<Array<ResolversTypes['DiscountError']>, ParentType, ContextType>;
  voucher?: Resolver<Maybe<ResolversTypes['Voucher']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseResolvers<ContextType = any, ParentType extends ResolversParentTypes['Warehouse'] = ResolversParentTypes['Warehouse']> = {
  address?: Resolver<ResolversTypes['Address'], ParentType, ContextType>;
  clickAndCollectOption?: Resolver<ResolversTypes['WarehouseClickAndCollectOptionEnum'], ParentType, ContextType>;
  companyName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  email?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isPrivate?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  metadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  metafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<WarehouseMetafieldArgs, 'key'>>;
  metafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<WarehouseMetafieldsArgs>>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  privateMetadata?: Resolver<Array<ResolversTypes['MetadataItem']>, ParentType, ContextType>;
  privateMetafield?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<WarehousePrivateMetafieldArgs, 'key'>>;
  privateMetafields?: Resolver<Maybe<ResolversTypes['Metadata']>, ParentType, ContextType, Partial<WarehousePrivateMetafieldsArgs>>;
  shippingZones?: Resolver<ResolversTypes['ShippingZoneCountableConnection'], ParentType, ContextType, Partial<WarehouseShippingZonesArgs>>;
  slug?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseCountableConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseCountableConnection'] = ResolversParentTypes['WarehouseCountableConnection']> = {
  edges?: Resolver<Array<ResolversTypes['WarehouseCountableEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseCountableEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseCountableEdge'] = ResolversParentTypes['WarehouseCountableEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Warehouse'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseCreate'] = ResolversParentTypes['WarehouseCreate']> = {
  errors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  warehouseErrors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseDelete'] = ResolversParentTypes['WarehouseDelete']> = {
  errors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  warehouseErrors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseError'] = ResolversParentTypes['WarehouseError']> = {
  code?: Resolver<ResolversTypes['WarehouseErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseShippingZoneAssignResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseShippingZoneAssign'] = ResolversParentTypes['WarehouseShippingZoneAssign']> = {
  errors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  warehouseErrors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseShippingZoneUnassignResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseShippingZoneUnassign'] = ResolversParentTypes['WarehouseShippingZoneUnassign']> = {
  errors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  warehouseErrors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WarehouseUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['WarehouseUpdate'] = ResolversParentTypes['WarehouseUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  warehouse?: Resolver<Maybe<ResolversTypes['Warehouse']>, ParentType, ContextType>;
  warehouseErrors?: Resolver<Array<ResolversTypes['WarehouseError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookResolvers<ContextType = any, ParentType extends ResolversParentTypes['Webhook'] = ResolversParentTypes['Webhook']> = {
  app?: Resolver<ResolversTypes['App'], ParentType, ContextType>;
  asyncEvents?: Resolver<Array<ResolversTypes['WebhookEventAsync']>, ParentType, ContextType>;
  eventDeliveries?: Resolver<Maybe<ResolversTypes['EventDeliveryCountableConnection']>, ParentType, ContextType, Partial<WebhookEventDeliveriesArgs>>;
  events?: Resolver<Array<ResolversTypes['WebhookEvent']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  isActive?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  secretKey?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  subscriptionQuery?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  syncEvents?: Resolver<Array<ResolversTypes['WebhookEventSync']>, ParentType, ContextType>;
  targetUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookCreateResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookCreate'] = ResolversParentTypes['WebhookCreate']> = {
  errors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  webhookErrors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookDeleteResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookDelete'] = ResolversParentTypes['WebhookDelete']> = {
  errors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  webhookErrors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookError'] = ResolversParentTypes['WebhookError']> = {
  code?: Resolver<ResolversTypes['WebhookErrorCode'], ParentType, ContextType>;
  field?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookEventResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookEvent'] = ResolversParentTypes['WebhookEvent']> = {
  eventType?: Resolver<ResolversTypes['WebhookEventTypeEnum'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookEventAsyncResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookEventAsync'] = ResolversParentTypes['WebhookEventAsync']> = {
  eventType?: Resolver<ResolversTypes['WebhookEventTypeAsyncEnum'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookEventSyncResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookEventSync'] = ResolversParentTypes['WebhookEventSync']> = {
  eventType?: Resolver<ResolversTypes['WebhookEventTypeSyncEnum'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WebhookUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['WebhookUpdate'] = ResolversParentTypes['WebhookUpdate']> = {
  errors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  webhook?: Resolver<Maybe<ResolversTypes['Webhook']>, ParentType, ContextType>;
  webhookErrors?: Resolver<Array<ResolversTypes['WebhookError']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type WeightResolvers<ContextType = any, ParentType extends ResolversParentTypes['Weight'] = ResolversParentTypes['Weight']> = {
  unit?: Resolver<ResolversTypes['WeightUnitsEnum'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface WeightScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['WeightScalar'], any> {
  name: 'WeightScalar';
}

export interface _AnyScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['_Any'], any> {
  name: '_Any';
}

export type _EntityResolvers<ContextType = any, ParentType extends ResolversParentTypes['_Entity'] = ResolversParentTypes['_Entity']> = {
  __resolveType: TypeResolveFn<'Address' | 'App' | 'Category' | 'Collection' | 'Group' | 'PageType' | 'Product' | 'ProductMedia' | 'ProductType' | 'ProductVariant' | 'User', ParentType, ContextType>;
};

export type _ServiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['_Service'] = ResolversParentTypes['_Service']> = {
  sdl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  AccountAddressCreate?: AccountAddressCreateResolvers<ContextType>;
  AccountAddressDelete?: AccountAddressDeleteResolvers<ContextType>;
  AccountAddressUpdate?: AccountAddressUpdateResolvers<ContextType>;
  AccountDelete?: AccountDeleteResolvers<ContextType>;
  AccountError?: AccountErrorResolvers<ContextType>;
  AccountRegister?: AccountRegisterResolvers<ContextType>;
  AccountRequestDeletion?: AccountRequestDeletionResolvers<ContextType>;
  AccountSetDefaultAddress?: AccountSetDefaultAddressResolvers<ContextType>;
  AccountUpdate?: AccountUpdateResolvers<ContextType>;
  Address?: AddressResolvers<ContextType>;
  AddressCreate?: AddressCreateResolvers<ContextType>;
  AddressDelete?: AddressDeleteResolvers<ContextType>;
  AddressSetDefault?: AddressSetDefaultResolvers<ContextType>;
  AddressUpdate?: AddressUpdateResolvers<ContextType>;
  AddressValidationData?: AddressValidationDataResolvers<ContextType>;
  Allocation?: AllocationResolvers<ContextType>;
  App?: AppResolvers<ContextType>;
  AppActivate?: AppActivateResolvers<ContextType>;
  AppCountableConnection?: AppCountableConnectionResolvers<ContextType>;
  AppCountableEdge?: AppCountableEdgeResolvers<ContextType>;
  AppCreate?: AppCreateResolvers<ContextType>;
  AppDeactivate?: AppDeactivateResolvers<ContextType>;
  AppDelete?: AppDeleteResolvers<ContextType>;
  AppDeleteFailedInstallation?: AppDeleteFailedInstallationResolvers<ContextType>;
  AppError?: AppErrorResolvers<ContextType>;
  AppExtension?: AppExtensionResolvers<ContextType>;
  AppExtensionCountableConnection?: AppExtensionCountableConnectionResolvers<ContextType>;
  AppExtensionCountableEdge?: AppExtensionCountableEdgeResolvers<ContextType>;
  AppFetchManifest?: AppFetchManifestResolvers<ContextType>;
  AppInstall?: AppInstallResolvers<ContextType>;
  AppInstallation?: AppInstallationResolvers<ContextType>;
  AppManifestExtension?: AppManifestExtensionResolvers<ContextType>;
  AppRetryInstall?: AppRetryInstallResolvers<ContextType>;
  AppToken?: AppTokenResolvers<ContextType>;
  AppTokenCreate?: AppTokenCreateResolvers<ContextType>;
  AppTokenDelete?: AppTokenDeleteResolvers<ContextType>;
  AppTokenVerify?: AppTokenVerifyResolvers<ContextType>;
  AppUpdate?: AppUpdateResolvers<ContextType>;
  AssignNavigation?: AssignNavigationResolvers<ContextType>;
  AssignedVariantAttribute?: AssignedVariantAttributeResolvers<ContextType>;
  Attribute?: AttributeResolvers<ContextType>;
  AttributeBulkDelete?: AttributeBulkDeleteResolvers<ContextType>;
  AttributeCountableConnection?: AttributeCountableConnectionResolvers<ContextType>;
  AttributeCountableEdge?: AttributeCountableEdgeResolvers<ContextType>;
  AttributeCreate?: AttributeCreateResolvers<ContextType>;
  AttributeDelete?: AttributeDeleteResolvers<ContextType>;
  AttributeError?: AttributeErrorResolvers<ContextType>;
  AttributeReorderValues?: AttributeReorderValuesResolvers<ContextType>;
  AttributeTranslatableContent?: AttributeTranslatableContentResolvers<ContextType>;
  AttributeTranslate?: AttributeTranslateResolvers<ContextType>;
  AttributeTranslation?: AttributeTranslationResolvers<ContextType>;
  AttributeUpdate?: AttributeUpdateResolvers<ContextType>;
  AttributeValue?: AttributeValueResolvers<ContextType>;
  AttributeValueBulkDelete?: AttributeValueBulkDeleteResolvers<ContextType>;
  AttributeValueCountableConnection?: AttributeValueCountableConnectionResolvers<ContextType>;
  AttributeValueCountableEdge?: AttributeValueCountableEdgeResolvers<ContextType>;
  AttributeValueCreate?: AttributeValueCreateResolvers<ContextType>;
  AttributeValueDelete?: AttributeValueDeleteResolvers<ContextType>;
  AttributeValueTranslatableContent?: AttributeValueTranslatableContentResolvers<ContextType>;
  AttributeValueTranslate?: AttributeValueTranslateResolvers<ContextType>;
  AttributeValueTranslation?: AttributeValueTranslationResolvers<ContextType>;
  AttributeValueUpdate?: AttributeValueUpdateResolvers<ContextType>;
  BulkProductError?: BulkProductErrorResolvers<ContextType>;
  BulkStockError?: BulkStockErrorResolvers<ContextType>;
  Category?: CategoryResolvers<ContextType>;
  CategoryBulkDelete?: CategoryBulkDeleteResolvers<ContextType>;
  CategoryCountableConnection?: CategoryCountableConnectionResolvers<ContextType>;
  CategoryCountableEdge?: CategoryCountableEdgeResolvers<ContextType>;
  CategoryCreate?: CategoryCreateResolvers<ContextType>;
  CategoryCreated?: CategoryCreatedResolvers<ContextType>;
  CategoryDelete?: CategoryDeleteResolvers<ContextType>;
  CategoryDeleted?: CategoryDeletedResolvers<ContextType>;
  CategoryTranslatableContent?: CategoryTranslatableContentResolvers<ContextType>;
  CategoryTranslate?: CategoryTranslateResolvers<ContextType>;
  CategoryTranslation?: CategoryTranslationResolvers<ContextType>;
  CategoryUpdate?: CategoryUpdateResolvers<ContextType>;
  CategoryUpdated?: CategoryUpdatedResolvers<ContextType>;
  Channel?: ChannelResolvers<ContextType>;
  ChannelActivate?: ChannelActivateResolvers<ContextType>;
  ChannelCreate?: ChannelCreateResolvers<ContextType>;
  ChannelCreated?: ChannelCreatedResolvers<ContextType>;
  ChannelDeactivate?: ChannelDeactivateResolvers<ContextType>;
  ChannelDelete?: ChannelDeleteResolvers<ContextType>;
  ChannelDeleted?: ChannelDeletedResolvers<ContextType>;
  ChannelError?: ChannelErrorResolvers<ContextType>;
  ChannelStatusChanged?: ChannelStatusChangedResolvers<ContextType>;
  ChannelUpdate?: ChannelUpdateResolvers<ContextType>;
  ChannelUpdated?: ChannelUpdatedResolvers<ContextType>;
  Checkout?: CheckoutResolvers<ContextType>;
  CheckoutAddPromoCode?: CheckoutAddPromoCodeResolvers<ContextType>;
  CheckoutBillingAddressUpdate?: CheckoutBillingAddressUpdateResolvers<ContextType>;
  CheckoutComplete?: CheckoutCompleteResolvers<ContextType>;
  CheckoutCountableConnection?: CheckoutCountableConnectionResolvers<ContextType>;
  CheckoutCountableEdge?: CheckoutCountableEdgeResolvers<ContextType>;
  CheckoutCreate?: CheckoutCreateResolvers<ContextType>;
  CheckoutCreated?: CheckoutCreatedResolvers<ContextType>;
  CheckoutCustomerAttach?: CheckoutCustomerAttachResolvers<ContextType>;
  CheckoutCustomerDetach?: CheckoutCustomerDetachResolvers<ContextType>;
  CheckoutDeliveryMethodUpdate?: CheckoutDeliveryMethodUpdateResolvers<ContextType>;
  CheckoutEmailUpdate?: CheckoutEmailUpdateResolvers<ContextType>;
  CheckoutError?: CheckoutErrorResolvers<ContextType>;
  CheckoutLanguageCodeUpdate?: CheckoutLanguageCodeUpdateResolvers<ContextType>;
  CheckoutLine?: CheckoutLineResolvers<ContextType>;
  CheckoutLineCountableConnection?: CheckoutLineCountableConnectionResolvers<ContextType>;
  CheckoutLineCountableEdge?: CheckoutLineCountableEdgeResolvers<ContextType>;
  CheckoutLineDelete?: CheckoutLineDeleteResolvers<ContextType>;
  CheckoutLinesAdd?: CheckoutLinesAddResolvers<ContextType>;
  CheckoutLinesDelete?: CheckoutLinesDeleteResolvers<ContextType>;
  CheckoutLinesUpdate?: CheckoutLinesUpdateResolvers<ContextType>;
  CheckoutPaymentCreate?: CheckoutPaymentCreateResolvers<ContextType>;
  CheckoutRemovePromoCode?: CheckoutRemovePromoCodeResolvers<ContextType>;
  CheckoutShippingAddressUpdate?: CheckoutShippingAddressUpdateResolvers<ContextType>;
  CheckoutShippingMethodUpdate?: CheckoutShippingMethodUpdateResolvers<ContextType>;
  CheckoutUpdated?: CheckoutUpdatedResolvers<ContextType>;
  ChoiceValue?: ChoiceValueResolvers<ContextType>;
  Collection?: CollectionResolvers<ContextType>;
  CollectionAddProducts?: CollectionAddProductsResolvers<ContextType>;
  CollectionBulkDelete?: CollectionBulkDeleteResolvers<ContextType>;
  CollectionChannelListing?: CollectionChannelListingResolvers<ContextType>;
  CollectionChannelListingError?: CollectionChannelListingErrorResolvers<ContextType>;
  CollectionChannelListingUpdate?: CollectionChannelListingUpdateResolvers<ContextType>;
  CollectionCountableConnection?: CollectionCountableConnectionResolvers<ContextType>;
  CollectionCountableEdge?: CollectionCountableEdgeResolvers<ContextType>;
  CollectionCreate?: CollectionCreateResolvers<ContextType>;
  CollectionCreated?: CollectionCreatedResolvers<ContextType>;
  CollectionDelete?: CollectionDeleteResolvers<ContextType>;
  CollectionDeleted?: CollectionDeletedResolvers<ContextType>;
  CollectionError?: CollectionErrorResolvers<ContextType>;
  CollectionRemoveProducts?: CollectionRemoveProductsResolvers<ContextType>;
  CollectionReorderProducts?: CollectionReorderProductsResolvers<ContextType>;
  CollectionTranslatableContent?: CollectionTranslatableContentResolvers<ContextType>;
  CollectionTranslate?: CollectionTranslateResolvers<ContextType>;
  CollectionTranslation?: CollectionTranslationResolvers<ContextType>;
  CollectionUpdate?: CollectionUpdateResolvers<ContextType>;
  CollectionUpdated?: CollectionUpdatedResolvers<ContextType>;
  ConfigurationItem?: ConfigurationItemResolvers<ContextType>;
  ConfirmAccount?: ConfirmAccountResolvers<ContextType>;
  ConfirmEmailChange?: ConfirmEmailChangeResolvers<ContextType>;
  CountryDisplay?: CountryDisplayResolvers<ContextType>;
  CreateToken?: CreateTokenResolvers<ContextType>;
  CreditCard?: CreditCardResolvers<ContextType>;
  CustomerBulkDelete?: CustomerBulkDeleteResolvers<ContextType>;
  CustomerCreate?: CustomerCreateResolvers<ContextType>;
  CustomerCreated?: CustomerCreatedResolvers<ContextType>;
  CustomerDelete?: CustomerDeleteResolvers<ContextType>;
  CustomerEvent?: CustomerEventResolvers<ContextType>;
  CustomerUpdate?: CustomerUpdateResolvers<ContextType>;
  CustomerUpdated?: CustomerUpdatedResolvers<ContextType>;
  Date?: GraphQLScalarType;
  DateTime?: GraphQLScalarType;
  DeactivateAllUserTokens?: DeactivateAllUserTokensResolvers<ContextType>;
  DeleteMetadata?: DeleteMetadataResolvers<ContextType>;
  DeletePrivateMetadata?: DeletePrivateMetadataResolvers<ContextType>;
  DeliveryMethod?: DeliveryMethodResolvers<ContextType>;
  DigitalContent?: DigitalContentResolvers<ContextType>;
  DigitalContentCountableConnection?: DigitalContentCountableConnectionResolvers<ContextType>;
  DigitalContentCountableEdge?: DigitalContentCountableEdgeResolvers<ContextType>;
  DigitalContentCreate?: DigitalContentCreateResolvers<ContextType>;
  DigitalContentDelete?: DigitalContentDeleteResolvers<ContextType>;
  DigitalContentUpdate?: DigitalContentUpdateResolvers<ContextType>;
  DigitalContentUrl?: DigitalContentUrlResolvers<ContextType>;
  DigitalContentUrlCreate?: DigitalContentUrlCreateResolvers<ContextType>;
  DiscountError?: DiscountErrorResolvers<ContextType>;
  Domain?: DomainResolvers<ContextType>;
  DraftOrderBulkDelete?: DraftOrderBulkDeleteResolvers<ContextType>;
  DraftOrderComplete?: DraftOrderCompleteResolvers<ContextType>;
  DraftOrderCreate?: DraftOrderCreateResolvers<ContextType>;
  DraftOrderCreated?: DraftOrderCreatedResolvers<ContextType>;
  DraftOrderDelete?: DraftOrderDeleteResolvers<ContextType>;
  DraftOrderDeleted?: DraftOrderDeletedResolvers<ContextType>;
  DraftOrderLinesBulkDelete?: DraftOrderLinesBulkDeleteResolvers<ContextType>;
  DraftOrderUpdate?: DraftOrderUpdateResolvers<ContextType>;
  DraftOrderUpdated?: DraftOrderUpdatedResolvers<ContextType>;
  Event?: EventResolvers<ContextType>;
  EventDelivery?: EventDeliveryResolvers<ContextType>;
  EventDeliveryAttempt?: EventDeliveryAttemptResolvers<ContextType>;
  EventDeliveryAttemptCountableConnection?: EventDeliveryAttemptCountableConnectionResolvers<ContextType>;
  EventDeliveryAttemptCountableEdge?: EventDeliveryAttemptCountableEdgeResolvers<ContextType>;
  EventDeliveryCountableConnection?: EventDeliveryCountableConnectionResolvers<ContextType>;
  EventDeliveryCountableEdge?: EventDeliveryCountableEdgeResolvers<ContextType>;
  EventDeliveryRetry?: EventDeliveryRetryResolvers<ContextType>;
  ExportError?: ExportErrorResolvers<ContextType>;
  ExportEvent?: ExportEventResolvers<ContextType>;
  ExportFile?: ExportFileResolvers<ContextType>;
  ExportFileCountableConnection?: ExportFileCountableConnectionResolvers<ContextType>;
  ExportFileCountableEdge?: ExportFileCountableEdgeResolvers<ContextType>;
  ExportGiftCards?: ExportGiftCardsResolvers<ContextType>;
  ExportProducts?: ExportProductsResolvers<ContextType>;
  ExternalAuthentication?: ExternalAuthenticationResolvers<ContextType>;
  ExternalAuthenticationUrl?: ExternalAuthenticationUrlResolvers<ContextType>;
  ExternalLogout?: ExternalLogoutResolvers<ContextType>;
  ExternalNotificationError?: ExternalNotificationErrorResolvers<ContextType>;
  ExternalNotificationTrigger?: ExternalNotificationTriggerResolvers<ContextType>;
  ExternalObtainAccessTokens?: ExternalObtainAccessTokensResolvers<ContextType>;
  ExternalRefresh?: ExternalRefreshResolvers<ContextType>;
  ExternalVerify?: ExternalVerifyResolvers<ContextType>;
  File?: FileResolvers<ContextType>;
  FileUpload?: FileUploadResolvers<ContextType>;
  Fulfillment?: FulfillmentResolvers<ContextType>;
  FulfillmentApprove?: FulfillmentApproveResolvers<ContextType>;
  FulfillmentCancel?: FulfillmentCancelResolvers<ContextType>;
  FulfillmentCanceled?: FulfillmentCanceledResolvers<ContextType>;
  FulfillmentCreated?: FulfillmentCreatedResolvers<ContextType>;
  FulfillmentLine?: FulfillmentLineResolvers<ContextType>;
  FulfillmentRefundProducts?: FulfillmentRefundProductsResolvers<ContextType>;
  FulfillmentReturnProducts?: FulfillmentReturnProductsResolvers<ContextType>;
  FulfillmentUpdateTracking?: FulfillmentUpdateTrackingResolvers<ContextType>;
  GatewayConfigLine?: GatewayConfigLineResolvers<ContextType>;
  GenericScalar?: GraphQLScalarType;
  GiftCard?: GiftCardResolvers<ContextType>;
  GiftCardActivate?: GiftCardActivateResolvers<ContextType>;
  GiftCardAddNote?: GiftCardAddNoteResolvers<ContextType>;
  GiftCardBulkActivate?: GiftCardBulkActivateResolvers<ContextType>;
  GiftCardBulkCreate?: GiftCardBulkCreateResolvers<ContextType>;
  GiftCardBulkDeactivate?: GiftCardBulkDeactivateResolvers<ContextType>;
  GiftCardBulkDelete?: GiftCardBulkDeleteResolvers<ContextType>;
  GiftCardCountableConnection?: GiftCardCountableConnectionResolvers<ContextType>;
  GiftCardCountableEdge?: GiftCardCountableEdgeResolvers<ContextType>;
  GiftCardCreate?: GiftCardCreateResolvers<ContextType>;
  GiftCardCreated?: GiftCardCreatedResolvers<ContextType>;
  GiftCardDeactivate?: GiftCardDeactivateResolvers<ContextType>;
  GiftCardDelete?: GiftCardDeleteResolvers<ContextType>;
  GiftCardDeleted?: GiftCardDeletedResolvers<ContextType>;
  GiftCardError?: GiftCardErrorResolvers<ContextType>;
  GiftCardEvent?: GiftCardEventResolvers<ContextType>;
  GiftCardEventBalance?: GiftCardEventBalanceResolvers<ContextType>;
  GiftCardResend?: GiftCardResendResolvers<ContextType>;
  GiftCardSettings?: GiftCardSettingsResolvers<ContextType>;
  GiftCardSettingsError?: GiftCardSettingsErrorResolvers<ContextType>;
  GiftCardSettingsUpdate?: GiftCardSettingsUpdateResolvers<ContextType>;
  GiftCardStatusChanged?: GiftCardStatusChangedResolvers<ContextType>;
  GiftCardTag?: GiftCardTagResolvers<ContextType>;
  GiftCardTagCountableConnection?: GiftCardTagCountableConnectionResolvers<ContextType>;
  GiftCardTagCountableEdge?: GiftCardTagCountableEdgeResolvers<ContextType>;
  GiftCardUpdate?: GiftCardUpdateResolvers<ContextType>;
  GiftCardUpdated?: GiftCardUpdatedResolvers<ContextType>;
  Group?: GroupResolvers<ContextType>;
  GroupCountableConnection?: GroupCountableConnectionResolvers<ContextType>;
  GroupCountableEdge?: GroupCountableEdgeResolvers<ContextType>;
  Image?: ImageResolvers<ContextType>;
  Invoice?: InvoiceResolvers<ContextType>;
  InvoiceCreate?: InvoiceCreateResolvers<ContextType>;
  InvoiceDelete?: InvoiceDeleteResolvers<ContextType>;
  InvoiceDeleted?: InvoiceDeletedResolvers<ContextType>;
  InvoiceError?: InvoiceErrorResolvers<ContextType>;
  InvoiceRequest?: InvoiceRequestResolvers<ContextType>;
  InvoiceRequestDelete?: InvoiceRequestDeleteResolvers<ContextType>;
  InvoiceRequested?: InvoiceRequestedResolvers<ContextType>;
  InvoiceSendNotification?: InvoiceSendNotificationResolvers<ContextType>;
  InvoiceSent?: InvoiceSentResolvers<ContextType>;
  InvoiceUpdate?: InvoiceUpdateResolvers<ContextType>;
  JSONString?: GraphQLScalarType;
  Job?: JobResolvers<ContextType>;
  LanguageDisplay?: LanguageDisplayResolvers<ContextType>;
  LimitInfo?: LimitInfoResolvers<ContextType>;
  Limits?: LimitsResolvers<ContextType>;
  Manifest?: ManifestResolvers<ContextType>;
  Margin?: MarginResolvers<ContextType>;
  Menu?: MenuResolvers<ContextType>;
  MenuBulkDelete?: MenuBulkDeleteResolvers<ContextType>;
  MenuCountableConnection?: MenuCountableConnectionResolvers<ContextType>;
  MenuCountableEdge?: MenuCountableEdgeResolvers<ContextType>;
  MenuCreate?: MenuCreateResolvers<ContextType>;
  MenuDelete?: MenuDeleteResolvers<ContextType>;
  MenuError?: MenuErrorResolvers<ContextType>;
  MenuItem?: MenuItemResolvers<ContextType>;
  MenuItemBulkDelete?: MenuItemBulkDeleteResolvers<ContextType>;
  MenuItemCountableConnection?: MenuItemCountableConnectionResolvers<ContextType>;
  MenuItemCountableEdge?: MenuItemCountableEdgeResolvers<ContextType>;
  MenuItemCreate?: MenuItemCreateResolvers<ContextType>;
  MenuItemDelete?: MenuItemDeleteResolvers<ContextType>;
  MenuItemMove?: MenuItemMoveResolvers<ContextType>;
  MenuItemTranslatableContent?: MenuItemTranslatableContentResolvers<ContextType>;
  MenuItemTranslate?: MenuItemTranslateResolvers<ContextType>;
  MenuItemTranslation?: MenuItemTranslationResolvers<ContextType>;
  MenuItemUpdate?: MenuItemUpdateResolvers<ContextType>;
  MenuUpdate?: MenuUpdateResolvers<ContextType>;
  Metadata?: GraphQLScalarType;
  MetadataError?: MetadataErrorResolvers<ContextType>;
  MetadataItem?: MetadataItemResolvers<ContextType>;
  Money?: MoneyResolvers<ContextType>;
  MoneyRange?: MoneyRangeResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  ObjectWithMetadata?: ObjectWithMetadataResolvers<ContextType>;
  Order?: OrderResolvers<ContextType>;
  OrderAddNote?: OrderAddNoteResolvers<ContextType>;
  OrderBulkCancel?: OrderBulkCancelResolvers<ContextType>;
  OrderCancel?: OrderCancelResolvers<ContextType>;
  OrderCancelled?: OrderCancelledResolvers<ContextType>;
  OrderCapture?: OrderCaptureResolvers<ContextType>;
  OrderConfirm?: OrderConfirmResolvers<ContextType>;
  OrderConfirmed?: OrderConfirmedResolvers<ContextType>;
  OrderCountableConnection?: OrderCountableConnectionResolvers<ContextType>;
  OrderCountableEdge?: OrderCountableEdgeResolvers<ContextType>;
  OrderCreateFromCheckout?: OrderCreateFromCheckoutResolvers<ContextType>;
  OrderCreateFromCheckoutError?: OrderCreateFromCheckoutErrorResolvers<ContextType>;
  OrderCreated?: OrderCreatedResolvers<ContextType>;
  OrderDiscount?: OrderDiscountResolvers<ContextType>;
  OrderDiscountAdd?: OrderDiscountAddResolvers<ContextType>;
  OrderDiscountDelete?: OrderDiscountDeleteResolvers<ContextType>;
  OrderDiscountUpdate?: OrderDiscountUpdateResolvers<ContextType>;
  OrderError?: OrderErrorResolvers<ContextType>;
  OrderEvent?: OrderEventResolvers<ContextType>;
  OrderEventCountableConnection?: OrderEventCountableConnectionResolvers<ContextType>;
  OrderEventCountableEdge?: OrderEventCountableEdgeResolvers<ContextType>;
  OrderEventDiscountObject?: OrderEventDiscountObjectResolvers<ContextType>;
  OrderEventOrderLineObject?: OrderEventOrderLineObjectResolvers<ContextType>;
  OrderFulfill?: OrderFulfillResolvers<ContextType>;
  OrderFulfilled?: OrderFulfilledResolvers<ContextType>;
  OrderFullyPaid?: OrderFullyPaidResolvers<ContextType>;
  OrderLine?: OrderLineResolvers<ContextType>;
  OrderLineDelete?: OrderLineDeleteResolvers<ContextType>;
  OrderLineDiscountRemove?: OrderLineDiscountRemoveResolvers<ContextType>;
  OrderLineDiscountUpdate?: OrderLineDiscountUpdateResolvers<ContextType>;
  OrderLineUpdate?: OrderLineUpdateResolvers<ContextType>;
  OrderLinesCreate?: OrderLinesCreateResolvers<ContextType>;
  OrderMarkAsPaid?: OrderMarkAsPaidResolvers<ContextType>;
  OrderRefund?: OrderRefundResolvers<ContextType>;
  OrderSettings?: OrderSettingsResolvers<ContextType>;
  OrderSettingsError?: OrderSettingsErrorResolvers<ContextType>;
  OrderSettingsUpdate?: OrderSettingsUpdateResolvers<ContextType>;
  OrderUpdate?: OrderUpdateResolvers<ContextType>;
  OrderUpdateShipping?: OrderUpdateShippingResolvers<ContextType>;
  OrderUpdated?: OrderUpdatedResolvers<ContextType>;
  OrderVoid?: OrderVoidResolvers<ContextType>;
  Page?: PageResolvers<ContextType>;
  PageAttributeAssign?: PageAttributeAssignResolvers<ContextType>;
  PageAttributeUnassign?: PageAttributeUnassignResolvers<ContextType>;
  PageBulkDelete?: PageBulkDeleteResolvers<ContextType>;
  PageBulkPublish?: PageBulkPublishResolvers<ContextType>;
  PageCountableConnection?: PageCountableConnectionResolvers<ContextType>;
  PageCountableEdge?: PageCountableEdgeResolvers<ContextType>;
  PageCreate?: PageCreateResolvers<ContextType>;
  PageCreated?: PageCreatedResolvers<ContextType>;
  PageDelete?: PageDeleteResolvers<ContextType>;
  PageDeleted?: PageDeletedResolvers<ContextType>;
  PageError?: PageErrorResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PageReorderAttributeValues?: PageReorderAttributeValuesResolvers<ContextType>;
  PageTranslatableContent?: PageTranslatableContentResolvers<ContextType>;
  PageTranslate?: PageTranslateResolvers<ContextType>;
  PageTranslation?: PageTranslationResolvers<ContextType>;
  PageType?: PageTypeResolvers<ContextType>;
  PageTypeBulkDelete?: PageTypeBulkDeleteResolvers<ContextType>;
  PageTypeCountableConnection?: PageTypeCountableConnectionResolvers<ContextType>;
  PageTypeCountableEdge?: PageTypeCountableEdgeResolvers<ContextType>;
  PageTypeCreate?: PageTypeCreateResolvers<ContextType>;
  PageTypeDelete?: PageTypeDeleteResolvers<ContextType>;
  PageTypeReorderAttributes?: PageTypeReorderAttributesResolvers<ContextType>;
  PageTypeUpdate?: PageTypeUpdateResolvers<ContextType>;
  PageUpdate?: PageUpdateResolvers<ContextType>;
  PageUpdated?: PageUpdatedResolvers<ContextType>;
  PasswordChange?: PasswordChangeResolvers<ContextType>;
  Payment?: PaymentResolvers<ContextType>;
  PaymentCapture?: PaymentCaptureResolvers<ContextType>;
  PaymentCheckBalance?: PaymentCheckBalanceResolvers<ContextType>;
  PaymentCountableConnection?: PaymentCountableConnectionResolvers<ContextType>;
  PaymentCountableEdge?: PaymentCountableEdgeResolvers<ContextType>;
  PaymentError?: PaymentErrorResolvers<ContextType>;
  PaymentGateway?: PaymentGatewayResolvers<ContextType>;
  PaymentInitialize?: PaymentInitializeResolvers<ContextType>;
  PaymentInitialized?: PaymentInitializedResolvers<ContextType>;
  PaymentRefund?: PaymentRefundResolvers<ContextType>;
  PaymentSource?: PaymentSourceResolvers<ContextType>;
  PaymentVoid?: PaymentVoidResolvers<ContextType>;
  Permission?: PermissionResolvers<ContextType>;
  PermissionGroupCreate?: PermissionGroupCreateResolvers<ContextType>;
  PermissionGroupDelete?: PermissionGroupDeleteResolvers<ContextType>;
  PermissionGroupError?: PermissionGroupErrorResolvers<ContextType>;
  PermissionGroupUpdate?: PermissionGroupUpdateResolvers<ContextType>;
  Plugin?: PluginResolvers<ContextType>;
  PluginConfiguration?: PluginConfigurationResolvers<ContextType>;
  PluginCountableConnection?: PluginCountableConnectionResolvers<ContextType>;
  PluginCountableEdge?: PluginCountableEdgeResolvers<ContextType>;
  PluginError?: PluginErrorResolvers<ContextType>;
  PluginUpdate?: PluginUpdateResolvers<ContextType>;
  PositiveDecimal?: GraphQLScalarType;
  PreorderData?: PreorderDataResolvers<ContextType>;
  PreorderThreshold?: PreorderThresholdResolvers<ContextType>;
  Product?: ProductResolvers<ContextType>;
  ProductAttributeAssign?: ProductAttributeAssignResolvers<ContextType>;
  ProductAttributeAssignmentUpdate?: ProductAttributeAssignmentUpdateResolvers<ContextType>;
  ProductAttributeUnassign?: ProductAttributeUnassignResolvers<ContextType>;
  ProductBulkDelete?: ProductBulkDeleteResolvers<ContextType>;
  ProductChannelListing?: ProductChannelListingResolvers<ContextType>;
  ProductChannelListingError?: ProductChannelListingErrorResolvers<ContextType>;
  ProductChannelListingUpdate?: ProductChannelListingUpdateResolvers<ContextType>;
  ProductCountableConnection?: ProductCountableConnectionResolvers<ContextType>;
  ProductCountableEdge?: ProductCountableEdgeResolvers<ContextType>;
  ProductCreate?: ProductCreateResolvers<ContextType>;
  ProductCreated?: ProductCreatedResolvers<ContextType>;
  ProductDelete?: ProductDeleteResolvers<ContextType>;
  ProductDeleted?: ProductDeletedResolvers<ContextType>;
  ProductError?: ProductErrorResolvers<ContextType>;
  ProductImage?: ProductImageResolvers<ContextType>;
  ProductMedia?: ProductMediaResolvers<ContextType>;
  ProductMediaBulkDelete?: ProductMediaBulkDeleteResolvers<ContextType>;
  ProductMediaCreate?: ProductMediaCreateResolvers<ContextType>;
  ProductMediaDelete?: ProductMediaDeleteResolvers<ContextType>;
  ProductMediaReorder?: ProductMediaReorderResolvers<ContextType>;
  ProductMediaUpdate?: ProductMediaUpdateResolvers<ContextType>;
  ProductPricingInfo?: ProductPricingInfoResolvers<ContextType>;
  ProductReorderAttributeValues?: ProductReorderAttributeValuesResolvers<ContextType>;
  ProductTranslatableContent?: ProductTranslatableContentResolvers<ContextType>;
  ProductTranslate?: ProductTranslateResolvers<ContextType>;
  ProductTranslation?: ProductTranslationResolvers<ContextType>;
  ProductType?: ProductTypeResolvers<ContextType>;
  ProductTypeBulkDelete?: ProductTypeBulkDeleteResolvers<ContextType>;
  ProductTypeCountableConnection?: ProductTypeCountableConnectionResolvers<ContextType>;
  ProductTypeCountableEdge?: ProductTypeCountableEdgeResolvers<ContextType>;
  ProductTypeCreate?: ProductTypeCreateResolvers<ContextType>;
  ProductTypeDelete?: ProductTypeDeleteResolvers<ContextType>;
  ProductTypeReorderAttributes?: ProductTypeReorderAttributesResolvers<ContextType>;
  ProductTypeUpdate?: ProductTypeUpdateResolvers<ContextType>;
  ProductUpdate?: ProductUpdateResolvers<ContextType>;
  ProductUpdated?: ProductUpdatedResolvers<ContextType>;
  ProductVariant?: ProductVariantResolvers<ContextType>;
  ProductVariantBackInStock?: ProductVariantBackInStockResolvers<ContextType>;
  ProductVariantBulkCreate?: ProductVariantBulkCreateResolvers<ContextType>;
  ProductVariantBulkDelete?: ProductVariantBulkDeleteResolvers<ContextType>;
  ProductVariantChannelListing?: ProductVariantChannelListingResolvers<ContextType>;
  ProductVariantChannelListingUpdate?: ProductVariantChannelListingUpdateResolvers<ContextType>;
  ProductVariantCountableConnection?: ProductVariantCountableConnectionResolvers<ContextType>;
  ProductVariantCountableEdge?: ProductVariantCountableEdgeResolvers<ContextType>;
  ProductVariantCreate?: ProductVariantCreateResolvers<ContextType>;
  ProductVariantCreated?: ProductVariantCreatedResolvers<ContextType>;
  ProductVariantDelete?: ProductVariantDeleteResolvers<ContextType>;
  ProductVariantDeleted?: ProductVariantDeletedResolvers<ContextType>;
  ProductVariantOutOfStock?: ProductVariantOutOfStockResolvers<ContextType>;
  ProductVariantPreorderDeactivate?: ProductVariantPreorderDeactivateResolvers<ContextType>;
  ProductVariantReorder?: ProductVariantReorderResolvers<ContextType>;
  ProductVariantReorderAttributeValues?: ProductVariantReorderAttributeValuesResolvers<ContextType>;
  ProductVariantSetDefault?: ProductVariantSetDefaultResolvers<ContextType>;
  ProductVariantStocksCreate?: ProductVariantStocksCreateResolvers<ContextType>;
  ProductVariantStocksDelete?: ProductVariantStocksDeleteResolvers<ContextType>;
  ProductVariantStocksUpdate?: ProductVariantStocksUpdateResolvers<ContextType>;
  ProductVariantTranslatableContent?: ProductVariantTranslatableContentResolvers<ContextType>;
  ProductVariantTranslate?: ProductVariantTranslateResolvers<ContextType>;
  ProductVariantTranslation?: ProductVariantTranslationResolvers<ContextType>;
  ProductVariantUpdate?: ProductVariantUpdateResolvers<ContextType>;
  ProductVariantUpdated?: ProductVariantUpdatedResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  ReducedRate?: ReducedRateResolvers<ContextType>;
  RefreshToken?: RefreshTokenResolvers<ContextType>;
  RequestEmailChange?: RequestEmailChangeResolvers<ContextType>;
  RequestPasswordReset?: RequestPasswordResetResolvers<ContextType>;
  Sale?: SaleResolvers<ContextType>;
  SaleAddCatalogues?: SaleAddCataloguesResolvers<ContextType>;
  SaleBulkDelete?: SaleBulkDeleteResolvers<ContextType>;
  SaleChannelListing?: SaleChannelListingResolvers<ContextType>;
  SaleChannelListingUpdate?: SaleChannelListingUpdateResolvers<ContextType>;
  SaleCountableConnection?: SaleCountableConnectionResolvers<ContextType>;
  SaleCountableEdge?: SaleCountableEdgeResolvers<ContextType>;
  SaleCreate?: SaleCreateResolvers<ContextType>;
  SaleCreated?: SaleCreatedResolvers<ContextType>;
  SaleDelete?: SaleDeleteResolvers<ContextType>;
  SaleDeleted?: SaleDeletedResolvers<ContextType>;
  SaleRemoveCatalogues?: SaleRemoveCataloguesResolvers<ContextType>;
  SaleTranslatableContent?: SaleTranslatableContentResolvers<ContextType>;
  SaleTranslate?: SaleTranslateResolvers<ContextType>;
  SaleTranslation?: SaleTranslationResolvers<ContextType>;
  SaleUpdate?: SaleUpdateResolvers<ContextType>;
  SaleUpdated?: SaleUpdatedResolvers<ContextType>;
  SelectedAttribute?: SelectedAttributeResolvers<ContextType>;
  SetPassword?: SetPasswordResolvers<ContextType>;
  ShippingError?: ShippingErrorResolvers<ContextType>;
  ShippingMethod?: ShippingMethodResolvers<ContextType>;
  ShippingMethodChannelListing?: ShippingMethodChannelListingResolvers<ContextType>;
  ShippingMethodChannelListingUpdate?: ShippingMethodChannelListingUpdateResolvers<ContextType>;
  ShippingMethodPostalCodeRule?: ShippingMethodPostalCodeRuleResolvers<ContextType>;
  ShippingMethodTranslatableContent?: ShippingMethodTranslatableContentResolvers<ContextType>;
  ShippingMethodTranslation?: ShippingMethodTranslationResolvers<ContextType>;
  ShippingMethodType?: ShippingMethodTypeResolvers<ContextType>;
  ShippingPriceBulkDelete?: ShippingPriceBulkDeleteResolvers<ContextType>;
  ShippingPriceCreate?: ShippingPriceCreateResolvers<ContextType>;
  ShippingPriceCreated?: ShippingPriceCreatedResolvers<ContextType>;
  ShippingPriceDelete?: ShippingPriceDeleteResolvers<ContextType>;
  ShippingPriceDeleted?: ShippingPriceDeletedResolvers<ContextType>;
  ShippingPriceExcludeProducts?: ShippingPriceExcludeProductsResolvers<ContextType>;
  ShippingPriceRemoveProductFromExclude?: ShippingPriceRemoveProductFromExcludeResolvers<ContextType>;
  ShippingPriceTranslate?: ShippingPriceTranslateResolvers<ContextType>;
  ShippingPriceUpdate?: ShippingPriceUpdateResolvers<ContextType>;
  ShippingPriceUpdated?: ShippingPriceUpdatedResolvers<ContextType>;
  ShippingZone?: ShippingZoneResolvers<ContextType>;
  ShippingZoneBulkDelete?: ShippingZoneBulkDeleteResolvers<ContextType>;
  ShippingZoneCountableConnection?: ShippingZoneCountableConnectionResolvers<ContextType>;
  ShippingZoneCountableEdge?: ShippingZoneCountableEdgeResolvers<ContextType>;
  ShippingZoneCreate?: ShippingZoneCreateResolvers<ContextType>;
  ShippingZoneCreated?: ShippingZoneCreatedResolvers<ContextType>;
  ShippingZoneDelete?: ShippingZoneDeleteResolvers<ContextType>;
  ShippingZoneDeleted?: ShippingZoneDeletedResolvers<ContextType>;
  ShippingZoneUpdate?: ShippingZoneUpdateResolvers<ContextType>;
  ShippingZoneUpdated?: ShippingZoneUpdatedResolvers<ContextType>;
  Shop?: ShopResolvers<ContextType>;
  ShopAddressUpdate?: ShopAddressUpdateResolvers<ContextType>;
  ShopDomainUpdate?: ShopDomainUpdateResolvers<ContextType>;
  ShopError?: ShopErrorResolvers<ContextType>;
  ShopFetchTaxRates?: ShopFetchTaxRatesResolvers<ContextType>;
  ShopSettingsTranslate?: ShopSettingsTranslateResolvers<ContextType>;
  ShopSettingsUpdate?: ShopSettingsUpdateResolvers<ContextType>;
  ShopTranslation?: ShopTranslationResolvers<ContextType>;
  StaffBulkDelete?: StaffBulkDeleteResolvers<ContextType>;
  StaffCreate?: StaffCreateResolvers<ContextType>;
  StaffDelete?: StaffDeleteResolvers<ContextType>;
  StaffError?: StaffErrorResolvers<ContextType>;
  StaffNotificationRecipient?: StaffNotificationRecipientResolvers<ContextType>;
  StaffNotificationRecipientCreate?: StaffNotificationRecipientCreateResolvers<ContextType>;
  StaffNotificationRecipientDelete?: StaffNotificationRecipientDeleteResolvers<ContextType>;
  StaffNotificationRecipientUpdate?: StaffNotificationRecipientUpdateResolvers<ContextType>;
  StaffUpdate?: StaffUpdateResolvers<ContextType>;
  Stock?: StockResolvers<ContextType>;
  StockCountableConnection?: StockCountableConnectionResolvers<ContextType>;
  StockCountableEdge?: StockCountableEdgeResolvers<ContextType>;
  StockError?: StockErrorResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  TaxType?: TaxTypeResolvers<ContextType>;
  TaxedMoney?: TaxedMoneyResolvers<ContextType>;
  TaxedMoneyRange?: TaxedMoneyRangeResolvers<ContextType>;
  TimePeriod?: TimePeriodResolvers<ContextType>;
  Transaction?: TransactionResolvers<ContextType>;
  TranslatableItem?: TranslatableItemResolvers<ContextType>;
  TranslatableItemConnection?: TranslatableItemConnectionResolvers<ContextType>;
  TranslatableItemEdge?: TranslatableItemEdgeResolvers<ContextType>;
  TranslationCreated?: TranslationCreatedResolvers<ContextType>;
  TranslationError?: TranslationErrorResolvers<ContextType>;
  TranslationTypes?: TranslationTypesResolvers<ContextType>;
  TranslationUpdated?: TranslationUpdatedResolvers<ContextType>;
  UUID?: GraphQLScalarType;
  UpdateMetadata?: UpdateMetadataResolvers<ContextType>;
  UpdatePrivateMetadata?: UpdatePrivateMetadataResolvers<ContextType>;
  Upload?: GraphQLScalarType;
  UploadError?: UploadErrorResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserAvatarDelete?: UserAvatarDeleteResolvers<ContextType>;
  UserAvatarUpdate?: UserAvatarUpdateResolvers<ContextType>;
  UserBulkSetActive?: UserBulkSetActiveResolvers<ContextType>;
  UserCountableConnection?: UserCountableConnectionResolvers<ContextType>;
  UserCountableEdge?: UserCountableEdgeResolvers<ContextType>;
  UserPermission?: UserPermissionResolvers<ContextType>;
  VAT?: VatResolvers<ContextType>;
  VariantMediaAssign?: VariantMediaAssignResolvers<ContextType>;
  VariantMediaUnassign?: VariantMediaUnassignResolvers<ContextType>;
  VariantPricingInfo?: VariantPricingInfoResolvers<ContextType>;
  VerifyToken?: VerifyTokenResolvers<ContextType>;
  Voucher?: VoucherResolvers<ContextType>;
  VoucherAddCatalogues?: VoucherAddCataloguesResolvers<ContextType>;
  VoucherBulkDelete?: VoucherBulkDeleteResolvers<ContextType>;
  VoucherChannelListing?: VoucherChannelListingResolvers<ContextType>;
  VoucherChannelListingUpdate?: VoucherChannelListingUpdateResolvers<ContextType>;
  VoucherCountableConnection?: VoucherCountableConnectionResolvers<ContextType>;
  VoucherCountableEdge?: VoucherCountableEdgeResolvers<ContextType>;
  VoucherCreate?: VoucherCreateResolvers<ContextType>;
  VoucherDelete?: VoucherDeleteResolvers<ContextType>;
  VoucherRemoveCatalogues?: VoucherRemoveCataloguesResolvers<ContextType>;
  VoucherTranslatableContent?: VoucherTranslatableContentResolvers<ContextType>;
  VoucherTranslate?: VoucherTranslateResolvers<ContextType>;
  VoucherTranslation?: VoucherTranslationResolvers<ContextType>;
  VoucherUpdate?: VoucherUpdateResolvers<ContextType>;
  Warehouse?: WarehouseResolvers<ContextType>;
  WarehouseCountableConnection?: WarehouseCountableConnectionResolvers<ContextType>;
  WarehouseCountableEdge?: WarehouseCountableEdgeResolvers<ContextType>;
  WarehouseCreate?: WarehouseCreateResolvers<ContextType>;
  WarehouseDelete?: WarehouseDeleteResolvers<ContextType>;
  WarehouseError?: WarehouseErrorResolvers<ContextType>;
  WarehouseShippingZoneAssign?: WarehouseShippingZoneAssignResolvers<ContextType>;
  WarehouseShippingZoneUnassign?: WarehouseShippingZoneUnassignResolvers<ContextType>;
  WarehouseUpdate?: WarehouseUpdateResolvers<ContextType>;
  Webhook?: WebhookResolvers<ContextType>;
  WebhookCreate?: WebhookCreateResolvers<ContextType>;
  WebhookDelete?: WebhookDeleteResolvers<ContextType>;
  WebhookError?: WebhookErrorResolvers<ContextType>;
  WebhookEvent?: WebhookEventResolvers<ContextType>;
  WebhookEventAsync?: WebhookEventAsyncResolvers<ContextType>;
  WebhookEventSync?: WebhookEventSyncResolvers<ContextType>;
  WebhookUpdate?: WebhookUpdateResolvers<ContextType>;
  Weight?: WeightResolvers<ContextType>;
  WeightScalar?: GraphQLScalarType;
  _Any?: GraphQLScalarType;
  _Entity?: _EntityResolvers<ContextType>;
  _Service?: _ServiceResolvers<ContextType>;
};

